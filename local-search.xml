<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>📣 攻击实验</title>
    <link href="/2023/09/04/%F0%9F%93%A3-%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/09/04/%F0%9F%93%A3-%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-pattern后门攻击"><a href="#1-pattern后门攻击" class="headerlink" title="1.pattern后门攻击"></a>1.pattern后门攻击</h1><h2 id="1-单次攻击"><a href="#1-单次攻击" class="headerlink" title="1.单次攻击"></a>1.单次攻击</h2><h2 id="2-多次攻击"><a href="#2-多次攻击" class="headerlink" title="2.多次攻击"></a>2.多次攻击</h2><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><p>1.联邦学习的更新范数差别太大了，以至于损失值为Nan，在fl_task的get_update_norm函数中打印的范数。</p>]]></content>
    
    
    <categories>
      
      <category>论文实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>攻击实验</tag>
      
      <tag>持续更新中</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 每日复习内容</title>
    <link href="/2023/09/04/%F0%9F%93%A3-%E6%AF%8F%E6%97%A5%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <url>/2023/09/04/%F0%9F%93%A3-%E6%AF%8F%E6%97%A5%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="2023-09-04（一）"><a href="#2023-09-04（一）" class="headerlink" title="2023-09-04（一）"></a>2023-09-04（一）</h2><p>复习内容：水平垂直居中、css中的长度单位、css中隐藏元素、深拷贝,浅拷贝和赋值、手写深拷贝、轮播图的实现思路、localstorage和sessionstorage、session和cookie、数组常用方法</p><p>1.数组常用方法：</p><ul><li>会修改原数组的方法7<ul><li>push</li><li>pop</li><li>unshift</li><li>shift</li><li>reverse</li><li>sort</li><li>splice</li></ul></li><li>不修改原数组5<ul><li>concat</li><li>join</li><li>slice</li><li>indexOf</li><li>lastIndexOf</li></ul></li><li>es6新增的方法<ul><li>forEach</li><li>map</li><li>filter</li><li>every</li><li>some</li><li>reduce</li></ul></li></ul><h1 id="2023-09-05（二）"><a href="#2023-09-05（二）" class="headerlink" title="2023-09-05（二）"></a>2023-09-05（二）</h1><p>复习内容：</p><h1 id="2023-09-05（三）"><a href="#2023-09-05（三）" class="headerlink" title="2023-09-05（三）"></a>2023-09-05（三）</h1><p>复习内容：</p>]]></content>
    
    
    <categories>
      
      <category>每日复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续更新中</tag>
      
      <tag>每日复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 分析实验过程</title>
    <link href="/2023/09/04/%F0%9F%93%A3-%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/09/04/%F0%9F%93%A3-%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-联邦学习过程"><a href="#1-联邦学习过程" class="headerlink" title="1.联邦学习过程"></a>1.联邦学习过程</h1><p>从main出发——&gt; fl_run（联邦学习总的训练过程）——&gt; run_fl_round（联邦学习的一轮训练）——&gt;test（每轮进行测试–测试正常样本和后门样本）——&gt;save_model（保存模型）</p><h1 id="2-联邦学习一轮训练"><a href="#2-联邦学习一轮训练" class="headerlink" title="2.联邦学习一轮训练"></a>2.联邦学习一轮训练</h1><h2 id="1-helper里能干的事情"><a href="#1-helper里能干的事情" class="headerlink" title="1.helper里能干的事情"></a>1.helper里能干的事情</h2><ol><li>初始化任务<ul><li>给params赋值</li><li><code>make_task</code> 找到运行联邦任务的py文件</li><li><code>make_synthesizer</code>找到后门攻击对应的py文件，并初始化攻击</li></ul></li><li>保存模型</li><li>保存断点</li></ol><h2 id="2-run-fl-round中干的事情"><a href="#2-run-fl-round中干的事情" class="headerlink" title="2.run_fl_round中干的事情"></a>2.<code>run_fl_round</code>中干的事情</h2><ol><li>加载全局模型和局部模型</li><li>随机选择参与者（可能包括恶意参与者）：fl_task文件中</li><li>创建一个新的权重累积字典</li><li>接着每个参与者在本地训练全局模型，得到上传更新</li><li>然后更新全局模型</li></ol><h1 id="3-对参与者进行中毒和随机选择参与者"><a href="#3-对参与者进行中毒和随机选择参与者" class="headerlink" title="3.对参与者进行中毒和随机选择参与者"></a>3.对参与者进行中毒和随机选择参与者</h1><h2 id="1-随机选择10个客户端"><a href="#1-随机选择10个客户端" class="headerlink" title="1.随机选择10个客户端"></a>1.随机选择10个客户端</h2><p><strong>实现</strong>：<code>fl_task</code>文件中<code>sample_users_for_round</code></p><p>里面的实现思路：</p><ol><li>在100个参与者中随机选择10个参与者，是从100个id中选择10个id</li><li>新建一个参与者样本列表</li><li>对于这10个用户，来查看其是否是恶意的，并对每个用户打标记（恶意和非恶意）</li><li>将打了标记的10个参与者加入参与者样本列表</li></ol><h2 id="2-给参与者打标记"><a href="#2-给参与者打标记" class="headerlink" title="2.给参与者打标记"></a>2.给参与者打标记</h2><p><strong>实现</strong>：<code>fl_task</code>文件中<code>check_user_compromised</code></p><p>里面的实现思路：</p><ol><li>先让参与者为正常参与者</li><li>根据单轮攻击还是多轮攻击中的攻击者列表来给当前参与者打标记</li><li>返回标记</li></ol><h1 id="4-参与者本地的训练过程"><a href="#4-参与者本地的训练过程" class="headerlink" title="4.参与者本地的训练过程"></a>4.参与者本地的训练过程</h1><p><strong>实现</strong>：<code>training</code>文件里</p><p>实现思路如下：</p><ol><li>将全局模型复制到本地模型中，实现：<code>fl_task</code>文件中<code>copy_params</code></li><li>选择优化器SGD-随机梯度下降算法，用于优化损失函数，实现：<code>task</code>文件中的<code>make_optimizer</code></li><li>开始本地轮次的训练：<ol><li>如果是恶意参与者，就怎么训练</li><li>如果是正常参与者，就怎么训练</li></ol></li><li>计算本地更新，<ol><li>正常参与者，实现：<code>fl_task</code>文件中<code>get_fl_update</code>。</li><li>恶意参与者，还会乘上一个数，实现：<code>attack</code>文件中的<code>fl_scale_update</code></li></ol></li><li>积累权重然后记录到权重累积字典，实现：<code>fl_task</code>文件中<code>accumulate_weights</code></li><li>更新全局模型，实现：<code>fl_task</code>文件中<code>update_global_model</code></li></ol><h1 id="5-本地模型训练的过程"><a href="#5-本地模型训练的过程" class="headerlink" title="5.本地模型训练的过程"></a>5.本地模型训练的过程</h1><p><strong>实现</strong>：training文件中</p><p>实现的思路如下：</p><ol><li>确定损失函数：交叉熵，实现：<code>task</code>文件中的<code>make_criterion</code></li><li>开启训练模式</li><li>开始本地轮次的批次训练：<ol><li>获得当前的batch，把数据加载到设备上</li><li>梯度为0</li><li>计算损失，实现：<code>attack.py</code>中的<code>compute_blind_loss</code></li><li>将损失loss 向输入侧进行反向传播</li><li>SGD优化器对值进行更新</li><li>打印训练时期的精度和损失等info信息，实现：<code>helper.py</code>中的<code>report_training_losses_scales</code></li></ol></li></ol><h1 id="6-本地模型计算损失的过程"><a href="#6-本地模型计算损失的过程" class="headerlink" title="6.本地模型计算损失的过程"></a>6.本地模型计算损失的过程</h1><p><strong>实现</strong>：<code>attack.py</code>中的<code>compute_blind_loss</code></p><p>实现的思路如下：</p><ol><li>记录训练的任务是什么，是后门任务和正常任务</li><li>获得后门训练批次，这里是加后门攻击的过程，实现：<code>synthesizer</code>中<code>make_backdoor_batch</code></li><li>利用多梯度下降算法来计算损失和梯度，实现：<code>losses.loss_functions</code>中的<code>compute_all_losses_and_grads</code></li></ol><h2 id="1-多梯度下降算法MGDA"><a href="#1-多梯度下降算法MGDA" class="headerlink" title="1.多梯度下降算法MGDA"></a>1.多梯度下降算法MGDA</h2><p><strong>前置知识：</strong></p><p>多梯度下降算法（Multi-Gradient Descent Algorithm，简称MGDA）是一种优化算法，旨在解决多目标优化问题，也就是在一个优化问题中存在多个目标函数需要最小化或最大化的情况。MGDA 的思路是通过协调多个目标函数的优化过程，以在不同目标之间取得平衡。</p><p>下面是 MGDA 算法的基本思路：</p><ol><li><strong>多目标问题设定：</strong> 首先，确定一个多目标优化问题，其中有多个待优化的目标函数。这里是正常任务和后门任务</li><li><strong>权衡策略：</strong> 在 MGDA 中，需要定义一个<strong>权衡策略</strong>，该策略决定了如何将多个目标函数结合起来形成一个综合目标，以便进行单一的优化。这个权衡策略通常包括权重或权衡参数，用于调整不同目标函数的相对重要性。这里的权衡策略是什么？</li><li><strong>梯度计算：</strong> 对于每个目标函数，计算其相对于优化变量的梯度。这意味着对每个目标函数进行单独的梯度计算。</li><li><strong>合并梯度：</strong> 使用权衡策略将不同目标函数的梯度合并为一个综合梯度。这通常涉及将不同目标函数的梯度按照其权重进行加权求和。</li><li><strong>参数更新：</strong> 使用合并的综合梯度来更新优化变量，通常使用标准的梯度下降或其他优化方法来实现。</li><li><strong>迭代优化：</strong> 重复步骤 3 到步骤 5，直到满足停止条件（例如达到最大迭代次数或梯度阈值）。</li><li><strong>结果分析：</strong> 最终的优化结果是一个在多个目标函数下达到权衡的解决方案。</li></ol><p>MGDA 的主要挑战在于权衡策略的选择，因为不同的权衡策略可能会导致不同的最终解决方案。因此，需要根据具体问题的性质和需求来选择适当的权衡策略。</p><p>总的来说，MGDA 旨在处理多目标优化问题，通过协调不同目标函数的优化过程，寻找一个在多个目标之间取得平衡的解决方案。它在多领域的优化问题中都有应用，包括机器学习、控制系统、工程优化等领域。</p><p>以下是一个简单的例子，说明如何使用MGDA来解决一个多目标优化问题：</p><p>假设你是一家制造公司的经理，你需要决定生产两种不同的产品A和B。你有两个关键的目标：最大化产品A的利润和最大化产品B的销售量。然而，这两个目标之间存在权衡，因为提高产品A的利润可能会导致产品B的销售量下降，反之亦然。</p><p>问题设定如下：</p><ul><li>目标1：最大化产品A的利润（表示为Profit_A）</li><li>目标2：最大化产品B的销售量（表示为Sales_B）</li></ul><p>你可以使用MGDA来解决这个问题的优化过程：</p><ol><li>定义权衡策略：你需要定义一个权衡策略来决定在优化过程中分配多少资源（生产能力、广告预算等）给产品A和产品B。例如，你可以分配权重alpha给产品A的利润，权重(1-alpha)给产品B的销售量，其中alpha是一个介于0和1之间的参数，表示你对产品A和产品B的相对重要性。</li><li>梯度计算：针对每个目标函数，计算其相对于资源分配（例如生产量、广告投入等）的梯度。这将涉及计算Profit_A和Sales_B关于资源分配的梯度。</li><li>合并梯度：使用权衡策略中的权重alpha和(1-alpha)将两个目标函数的梯度加权合并为一个综合梯度。</li><li>参数更新：使用合并的综合梯度来更新资源分配的变量。这可能涉及使用标准的梯度下降或其他优化算法来更新资源分配。</li><li>迭代优化：重复步骤3和步骤4，直到达到停止条件，例如达到最大迭代次数或梯度变化很小。</li><li>结果分析：最终的优化结果是一组资源分配，这些资源分配在产品A的利润和产品B的销售量之间取得了权衡。</li></ol><p>通过调整权衡策略中的参数alpha，你可以探索不同的权衡点，以找到最适合公司目标的资源分配策略。这个例子说明了如何使用MGDA来处理多目标优化问题，并在不同目标之间进行权衡，以找到最佳解决方案。</p><p><strong>实现</strong>：<code>losses.loss_functions</code>中的<code>compute_all_losses_and_grads</code></p><p><strong>实现思路如下：</strong></p><ol><li>新建一个损失和梯度空字典</li><li>对任务进行分类：<ol><li>正常任务，实现：<code>losses.loss_functions</code>中的<code>compute_normal_loss</code></li><li>后门任务，实现：<code>losses.loss_functions</code>中的<code>compute_backdoor_loss</code></li></ol></li></ol><p>对于正常任务计算损失和梯度，思路如下：</p><ol><li>得到模型的输出</li><li>利用交叉熵计算损失</li><li></li></ol><h1 id="7-得到本地上传更新的过程"><a href="#7-得到本地上传更新的过程" class="headerlink" title="7.得到本地上传更新的过程"></a>7.得到本地上传更新的过程</h1>]]></content>
    
    
    <categories>
      
      <category>论文实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续更新中</tag>
      
      <tag>backdoors101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣-面试八股文-html-css-js（持续更新中）</title>
    <link href="/2023/09/03/%F0%9F%93%A3-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <url>/2023/09/03/%F0%9F%93%A3-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="📚-html-和-h5"><a href="#📚-html-和-h5" class="headerlink" title="📚 html 和 h5"></a>📚 html 和 h5</h1><h2 id="1-h5新增了哪些新特性√"><a href="#1-h5新增了哪些新特性√" class="headerlink" title="1. h5新增了哪些新特性√"></a>1. h5新增了哪些新特性√</h2><ol><li>语义化标签，例如header，footer，section，article等。 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；还新增了一些状态标签、列表标签、文本标签。</li><li>新增媒体元素，audio、video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API</li><li>新增的表单控件：calendar、date、time、email、url、search </li><li>用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的<strong>canvas</strong>元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。</li><li>新增本地存储方式：sessionStorage、localStorage。sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。</li><li>新的技术：webworker、websocket。 webworker：用于多线程编程；websocket：客户端与服务端双向数据通信协议</li></ol><h2 id="2-localstorage、sessionstorage可以跨域吗✓"><a href="#2-localstorage、sessionstorage可以跨域吗✓" class="headerlink" title="2.localstorage、sessionstorage可以跨域吗✓"></a>2.localstorage、sessionstorage可以跨域吗✓</h2><p>本地存储和会话存储都存储键值对。</p><p><strong>本地存储和会话存储的主要区别在于</strong>，<strong>在关闭浏览器后</strong>，<strong>存储在会话存储中的键值对会丢失</strong>。下面是基本的使用（两者API一样，这里列举的是会话存储）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存键值对、获取键值对</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>, <span class="hljs-string">&#x27;uiu&#x27;</span>);<br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>);<br><br><span class="hljs-comment">// 保存数组，获取数据，如果不用JSON.parse()，则得到的是字符串</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">ProgrammingLanguage</span> = [<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;GO+&#x27;</span>]<br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;favoriteProgrammingLanguage&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title class_">ProgrammingLanguage</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;favoriteProgrammingLanguage&#x27;</span>)));<br><br><span class="hljs-comment">// 清除本地存储或会话存储</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>()<br><br><span class="hljs-comment">// 移除某个键值对</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-本地存储和会话存储的相同点、不同点"><a href="#1-本地存储和会话存储的相同点、不同点" class="headerlink" title="1.本地存储和会话存储的相同点、不同点"></a>1.本地存储和会话存储的相同点、不同点</h3><p><strong>相同点：</strong></p><p>1、存储大小均为5M左右<br>2、<font color=red><strong>都有同源策略限制</strong></font><br>3、仅在客户端中保存，不参与和服务器的通信</p><p><strong>不同点：</strong></p><p>1、<code>生命周期</code> —— 数据可以存储多少时间</p><ul><li>localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。</li><li>sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。</li></ul><p>2、<code>作用域</code> —— 谁拥有数据的访问权</p><ul><li>localStorage: 在同一个浏览器内，<code>同源文档</code>之间共享 localStorage 数据，可以互相读取、覆盖。</li><li>sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。</li></ul><p>为了更好的理解<code>sessionStorage</code>,我们来看个例子：</p><p>例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的<code>iframe</code>元素的话，这两个<code>iframe</code>的 sessionStorage 是可以互通的。</p><h2 id="3-cookie有哪些属性，cookie和session的区别√"><a href="#3-cookie有哪些属性，cookie和session的区别√" class="headerlink" title="3. cookie有哪些属性，cookie和session的区别√"></a>3. cookie有哪些属性，cookie和session的区别√</h2><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h3><p>Cookie是小甜饼的意思，主要有以下特点：</p><p>1、顾名思义，Cookie 确实非常小，它的大小限制为4KB左右</p><p>2、主要用途是保存登录信息和标记用户(比如购物车)等，不过随着localStorage的出现，现在购物车的工作Cookie承担的较少了</p><p>3、一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</p><p>4、每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p><p>5、原生API不如storage友好，需要自己封装函数</p><p><strong>用法(API)</strong></p><p>服务端向客户端发送的cookie(HTTP头,不带参数)：<br><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</code> (name可选)</p><p>服务端向客户端发送的cookie(HTTP头，带参数)：<br><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2)</code></p><p>客户端设置cookie：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&quot;&lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>可选参数：</strong></p><p>下图是Chrome浏览器中的Cookie截图，属性分别有<strong>Name</strong>、<strong>Value</strong>、<strong>Domain</strong>、<strong>Path</strong>、<strong>Expires&#x2F;Max-age</strong>、<strong>Size</strong>、<strong>HttpOnly</strong>、<strong>Secure</strong>、<strong>SameSite</strong>和<strong>Priority</strong>。</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ffd6fde7194438bf2f2c92a8480f5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1187&h=92&s=14975&e=png&b=f8f8f8"  width="80%"/></p><p><code>Domain=&lt;domain-value&gt;</code>：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Domain设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(“.”)开始。</p><p><code>Path=&lt;path-value&gt;</code>：指定一个URL，和<strong>Domain</strong>类似，也对子路径生效，例如指定path&#x3D;&#x2F;docs，则 ”&#x2F;docs” 、 ”&#x2F;docs&#x2F;Web&#x2F;“ 、”&#x2F;docs&#x2F;Web&#x2F;Http”均满足匹配条件。如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 &#x2F;b&#x2F;,而Cookie2的Path为 &#x2F;b&#x2F;c&#x2F;,则在a.com&#x2F;b页面时只可以访问Cookie1，在a.com&#x2F;b&#x2F;c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“&#x2F;”结尾。</p><p><code>Expires/Max-age</code>：<br>    <code>Expires</code>和<code>Max-age</code>均为Cookie的有效期，<code>Expires</code>是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不设置则默认页面关闭时删除该Cookie。<br>    <code>Max-age</code>也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0，则立刻失效，设置为负数，则在页面关闭时失效。Max-age默认为 -1。</p><p><code>HttpOnly</code>：<strong>HttpOnly</strong>值为 <em>true</em> 或 <em>false</em>,若设置为<em>true</em>，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。</p><p><code>Secure</code>：<strong>Secure</strong>为Cookie的安全属性，若设置为<em>true</em>，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。</p><p><code>SameSite</code>SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：</p><p>​Strict：Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie</p><p>​Lax：Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p><p>​None：网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p><p><strong>关闭SameSite的方法</strong></p><ul><li>操作方法谷歌浏览器地址栏输入：chrome:&#x2F;&#x2F;flags&#x2F;</li><li>找到：SameSite by default cookies、Cookies without SameSite must be secure设置上面这两项设置成 Disable</li></ul><p><code>Priority</code><br>优先级，chrome的提案，定义了三种优先级，Low&#x2F;Medium&#x2F;High，当cookie数量超出时，低优先级的cookie会被优先清除。在360极速浏览器和FireFox中，不存在Priority属性，不清楚在此类浏览器中设置该属性后是否生效。</p><p>示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Set-Cookie: <span class="hljs-attribute">sessionid</span>=aes7a8; HttpOnly; <span class="hljs-attribute">Path</span>=/<br><br>document.cookie = <span class="hljs-string">&quot;KMKNKK=1234;Sercure&quot;</span><br></code></pre></td></tr></table></figure><p>可选前缀：<br><code>__Secure-</code>：以<code>__Secure-</code>为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）</p><p><code>__Host-</code>：以<code>__Host-</code>为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）。必须不能设置domian属性（这样可以防止二级域名获取一级域名的cookie），path属性的值必须为”&#x2F;“。</p><p>前缀使用示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">复制代码Set-Cookie: <span class="hljs-attribute">__Secure-ID</span>=123; Secure; <span class="hljs-attribute">Domain</span>=example.com<br>Set-Cookie: <span class="hljs-attribute">__Host-ID</span>=123; Secure; <span class="hljs-attribute">Path</span>=/<br><br>document.cookie = <span class="hljs-string">&quot;__Secure-KMKNKK=1234;Sercure&quot;</span><br>document.cookie = <span class="hljs-string">&quot;__Host-KMKNKK=1234;Sercure;path=/&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-Session"><a href="#2-Session" class="headerlink" title="2.Session"></a>2.Session</h3><p><strong>基本概念</strong></p><p>Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。</p><p>在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。</p><p>大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器</p><p><strong>与Cookie的关系与区别：</strong></p><p>1、<code>Session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，<code>Cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p><p>2、<code>Cookie</code>的<code>安全性</code>一般，他人可通过分析存放在本地的<code>Cookie</code>并进行<code>Cookie</code>欺骗。在安全性第一的前提下，选择<code>Session</code>更优。重要交互信息比如权限等就要放在<code>Session</code>中，一般的信息记录放<code>Cookie</code>就好了。 </p><p>3、单个<code>Cookie</code>保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个<code>Cookie</code>。 当访问增多时，<code>Session</code>会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用<code>Cookie</code>。 </p><p>4、<code>Session</code>的运行依赖<code>Session ID</code>，而<code>Session ID</code>是存在 Cookie 中的。也就是说，如果浏览器禁用了<code>Cookie</code>,<code>Session</code>也会失效（但是可以通过其它方式实现，比如在<code>url</code>中传递<code>Session ID</code>,即sid&#x3D;xxxx）。</p><h1 id="📚-css-c3"><a href="#📚-css-c3" class="headerlink" title="📚 css+c3"></a>📚 css+c3</h1><h2 id="1-长度单位有哪些？√"><a href="#1-长度单位有哪些？√" class="headerlink" title="1.长度单位有哪些？√"></a>1.长度单位有哪些？√</h2><p>A：答案如下：这里写了8个</p><ul><li><a href="https://www.w3school.com.cn/cssref/css_units.asp">CSS中的长度单位</a></li><li>CSS 有几种表示长度的不同单位。许多 CSS 属性接受“长度”值，诸如 <code>width</code>、<code>margin</code>、<code>padding</code>、<code>font-size</code> 等。长度是一个后面跟着长度单位的数字，诸如 <code>10px</code>、<code>2em</code> 等。</li><li>绝对单位有：<ul><li>px 像素：我们的电脑屏幕是由一个一个“小点”组成的，每个“小点”，就是一个像素（px）。 一个像素的大小主要取决于显示器的分辨率，相同面积不同分辨率的显示屏，其像素点大小就不相同。 像素点越小，呈现的内容就越清晰、越细腻。</li><li>cm 厘米：可以用在网页设计，但是不太精细</li><li>nm 纳米</li></ul></li><li>相对单位有：<ul><li>em：相对于<strong>font-size</strong>的大小，即为font-size的倍数。如果当前元素没有font-size，则往上一级一层一层的找，如果在根元素都没有找到，则选择浏览器默认的font-size。</li><li>rem：相对<strong>根元素</strong>的字体大小，即html的font-size</li><li>%：相对<strong>父元素</strong>的大小</li><li>vm：相对于视口宽度大小的1%，1vm&#x3D;视口宽度*1%</li><li>vh：相对于视口高度大小的1%，1vm&#x3D;视口高度*1%</li><li>vmin：1vmin &#x3D; 1vw 或 1vh，以较小者为准。</li><li>vmax：1vmax &#x3D; 1vw 或 1vh，以较小者为准。</li></ul></li></ul><p>查看视口宽度的宽度：<code>console.log(document.documentElement.clientWidth)</code></p><h2 id="2-如何实现水平垂直居中？√"><a href="#2-如何实现水平垂直居中？√" class="headerlink" title="2.如何实现水平垂直居中？√"></a>2.如何实现水平垂直居中？√</h2><p>如果要在父元素中实现水平垂直居中：</p><ul><li><p>子元素为行内元素&#x2F;行内块元素：（可以将行内元素和行内块元素当做文本处理）</p><ul><li>水平：<code>text-align:center</code></li><li>垂直：父元素设置行号：<code>line-height=height</code>，每个子元素加上：<code>vertical-align:middle</code><ul><li>如果想要实现绝对的垂直居中，可以让父元素的字体大小为0，因为vertical-align本就是受字体大小的影响</li></ul></li></ul></li><li><p>子元素为块元素：</p><ul><li><p>①使用<code>margin</code>，子元素需要高度</p><ul><li>水平：子元素设置<code>margin:0 auto</code></li><li>垂直：子元素设置<code>margin-top:(父元素内容-子元素盒子总高) / 2  </code></li></ul></li><li><p>②使用绝对定位（有3种）</p><ul><li><p>绝对定位+位移</p><ul><li><p>父元素设置相对定位</p></li><li><pre><code class="JavaScript">position: absolute;left: 50%;top: 50%;            transform: translate(-50%, -50%);<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- 绝对定位+`<span class="hljs-attribute">margin</span>`：<span class="hljs-number">2</span>种<br><br>  - ```css<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>:<span class="hljs-number">0</span><br>    margin: auto;<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="css">position: absolute;left: 50%;/*负的一半width*/margin-left: -25px; <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- ③ 弹性布局：<span class="hljs-number">2</span>种<br><br>  - 方式二：父容器开启 <span class="hljs-attribute">flex</span> 布局，随后子元素 <span class="hljs-attribute">margin</span>: auto <br><br>  - 加在父元素<br><br>    - ```JavaScript<br>      display: flex; <br>      <span class="hljs-attribute">justify-content</span>: center; <br>      <span class="hljs-attribute">align-items</span>: center;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li></ul><h2 id="3-CSS中隐藏元素有几种实现方式？√"><a href="#3-CSS中隐藏元素有几种实现方式？√" class="headerlink" title="3.CSS中隐藏元素有几种实现方式？√"></a>3.<strong>CSS</strong>中隐藏元素有几种实现方式？√</h2><p>参考：[css隐藏元素的六种方法_css hidden_muzidigbig的博客-CSDN博客](<a href="https://blog.csdn.net/muzidigbig/article/details/80967143#:~:text=css%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95">https://blog.csdn.net/muzidigbig/article/details/80967143#:~:text=css隐藏元素的六种方法</a> 1 display%3Anone (通过隐藏盒子属性，脱标) 2 visibility%3Ahidden (通过隐藏盒子属性，不脱标) 3,(通过裁剪盒子，不脱标) 6 position%3Aabsolute%3B与clip%3Arect (0px 0px 0px 0px)配合 (通过裁剪绝对定位的盒子，脱标))</p><p>A：方式如下：</p><ul><li><p>① visibility: hidden </p><ul><li>特点：可以隐藏元素，占位</li></ul></li><li><p>② display：none</p><ul><li>特点：不占位</li></ul></li><li><p>③ 给元素加hidden属性，这是html5中的全局属性</p><ul><li>特点：和display一样，不占位</li></ul></li><li><p>④ opacity: 0</p><ul><li>特点：占位</li></ul></li><li><p>⑤ 绝对定位：</p><ul><li>主要是将其移出屏幕，优点：既能响应，也不影响布局</li><li><pre><code class="JavaScript">position：relative;left:-99999px;top:-90999px;<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">  <br>- ⑥ <span class="hljs-attribute">z-index</span><br>  - 特点：不占据空间<br>  - ```JavaScript<br>    <span class="hljs-selector-class">.hide</span>&#123;<br>        <span class="hljs-attribute">position</span>:absolute;<br>        <span class="hljs-attribute">z-index</span>:-<span class="hljs-number">1000</span>;<span class="hljs-comment">/* 不占据空间，无法点击 */</span><br>    &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>⑦ 位移:</p><ul><li>特点：占据空间</li><li><code>transform: scale(0,0)/* 占据空间，无法点击 */</code></li></ul></li></ul> <table>    <tr>        <th>方法比较</th>        <th>visibility: hidden</th>        <th>opacity: 0</th>        <th>overflow:hidden;</th>        <th>绝对定位</th>        <th>位移</th>        <th>z-index</th>        <th>display:none</th>        <th>加hidden属性</th>    </tr>    <tr>        <td>是否占位？</td>        <td>√</td>        <td>√</td>        <td>√</td>        <td>√</td>        <td>√</td>        <td>×</td>        <td>×</td>        <td>×</td>    </tr>    <tr>        <td>性能</td>        <td>会引起重绘，不会引起回流</td>        <td>只造成本元素重绘，性能消耗较少</td>        <td>用来隐藏元素溢出部分，无法响应点击事件</td>        <td></td>        <td></td>        <td></td>        <td>无法响应事件，引起页面回流与重绘，性能消耗大</td>        <td></td>    </tr></table><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6a89c749c884a578e3552abc83d033f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1368&h=436&s=204522&e=png&a=1&b=d8dbda" alt="image.png"  width="80%"/></p><h1 id="📚-js"><a href="#📚-js" class="headerlink" title="📚 js"></a>📚 js</h1><h2 id="1-js取整的方法，parseInt第二个参数是什么-（√）"><a href="#1-js取整的方法，parseInt第二个参数是什么-（√）" class="headerlink" title="1.js取整的方法，parseInt第二个参数是什么?（√）"></a>1.js取整的方法，parseInt第二个参数是什么?（√）</h2><p>1、丢弃小数部分，保留整数部分：</p><pre><code class="hljs">parseInt(d);Math.trunc(d); </code></pre><p>两者的区别：parseInt 常常接收一个字符串作为参数，而 Math.trunc 则可以接收一个数字参数，所以如果要对数字取整，还是建议使用 Math.trunc。使用 parseInt 的时候，如果你传入的不是字符串，比如传入一个数字，parseInt 会先调用数字的 toString() 方法。</p><blockquote><p>【知识点】parseInt()方法：字符串转数字</p><p>parseInt接收两个参数：</p><ul><li>第一个参数<code>string</code>：要被解析的字符串，如果不是字符串会被转换，忽视空格符</li><li>第二个参数<code>radix</code>：要解析的数字的基数。该值介于2~36之间。默认值为10，表示十进制。<strong>这个参数表示将前面的字符从radix进制转化为十进制</strong><ul><li>1.在没有指定基数，或者基数为0的情况下，parseInt()会根据<code>string</code>参数来判断数字的基数。<ul><li>如果字符串<code>string</code>以”0x”或者”0X”开头, 则基数是16 (16进制).</li><li>如果字符串<code>string</code>以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。</li><li>如果字符串<code>string</code>以其它任何值开头，则基数是10 (十进制)。</li></ul></li><li>2.如果<code>radix</code>在<code>2 ~ 36之外</code>会返回NaN。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 例1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>));  <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 例2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 例3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>));  <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 例4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 例5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">123</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 结果为38</span><br></code></pre></td></tr></table></figure><p><strong>解析如下</strong>：</p><ul><li><strong>例1</strong>： <code>parseInt</code>里面有两个参数，第二个参数是8，表示要将<code>八进制</code>的3转换为十进制的结果，八进制中有3，转化为十进制还是3，所以返回结果为3</li><li><strong>例2</strong>： <code>parseInt</code>里面有两个参数，第二个参数是2，表示要将<code>二进制</code>的3转化为十进制，额…，不好意思，二进制中并没有3，所以返回<code>NaN</code></li><li><strong>例3</strong>： <code>parseInt</code>里面有两个参数，第二个参数是0，根据规则1，默认就是十进制，直接返回3</li><li><strong>例4</strong>： <code>parseInt</code>里面有两个参数，第二个参数是1，根据规则2，1在<code>2 ~ 36之外</code>，直接返回<code>NaN</code>。</li><li><strong>例5</strong>： <code>parseInt</code>里面有两个参数，第二个参数是5，表示要将<code>五进制</code>的123转化为十进制，结果为38 &#x3D;&gt; (<code>1*5^2 + 2*5^1 + 3*5^0 = 38</code>)</li></ul></blockquote><p>2、向上取整，有小数就整数部分加1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 11.1取整后得到12；</span><br><span class="hljs-comment">// -11.1取整后得到-11。</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(d);<br></code></pre></td></tr></table></figure><p>3、向下取整，正数舍弃小数位，负数整数位减一：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">11.1取整后得到11；<br><br><span class="hljs-string">-11</span>.1取整后得到<span class="hljs-string">-12</span>。<br><br>Math.floor(d);<br></code></pre></td></tr></table></figure><p>4、四舍五入：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Math.round(d)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="2-数组转字符串、字符串转数组（√）"><a href="#2-数组转字符串、字符串转数组（√）" class="headerlink" title="2.数组转字符串、字符串转数组（√）"></a>2.数组转字符串、字符串转数组（√）</h2><h3 id="一、数组转字符串（3种方法）"><a href="#一、数组转字符串（3种方法）" class="headerlink" title="一、数组转字符串（3种方法）"></a>一、数组转字符串（3种方法）</h3><p>同样是数组转字符串，toString()，toLocaleString()，join()，join(’,’)的区别是什么？</p><p>JavaScript 允许数组与字符串之间相互转换。其中 Array 方法对象定义了 3 个方法，可以把数组转换为字符串，如表所示。</p><table><thead><tr><th>数组方法</th><th>说明</th></tr></thead><tbody><tr><td>toString()</td><td>将数组转换成一个字符串</td></tr><tr><td>toLocaleString()</td><td>把数组转换成本地约定的字符串</td></tr><tr><td>join()</td><td>将数组元素连接起来以构建一个字符串</td></tr></tbody></table><p><strong>1. join()方法用于把数组中的所有元素放入一个字符串</strong></p><p>元素是通过指定的分隔符进行分隔的</p><table><thead><tr><th>join()指定的分隔符</th><th>说明</th></tr></thead><tbody><tr><td>join()</td><td>可理解为直接变成字符串，默认逗号分隔</td></tr><tr><td>join(’ ‘）</td><td>空连接</td></tr><tr><td>join(’ ，’)或者 join(’ - ‘)或者 join(’ 。’)</td><td>中间这个逗号是手动添加的，也可以改成别的比如、。! -等等都可以</td></tr></tbody></table><p><strong>2. toString()方法可把一个逻辑值转换为字符串，并返回结果</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> str = arr.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//把数组转换为字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> str); <span class="hljs-comment">//返回字符串string，说明是字符串类型</span><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 10,true,30,40</span><br><span class="hljs-comment">// string</span><br></code></pre></td></tr></table></figure><p>toString()方法不可以指定分隔符，但是我们可以通过replace()方法指定替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/,/gi</span>, <span class="hljs-string">&quot;-&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// 10-true-30-40</span><br></code></pre></td></tr></table></figure><p>**3. toLocaleString()**：把数组转换成本地约定的字符串</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> str = arr.toLocaleString(); <span class="hljs-comment">//把数组转换为字符串</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str); <span class="hljs-comment">// 10,true,30,40</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> str); <span class="hljs-comment">//返回字符串string，说明是字符串类型</span><br><br></code></pre></td></tr></table></figure><h3 id="二、字符串转数组（2种方法）"><a href="#二、字符串转数组（2种方法）" class="headerlink" title="二、字符串转数组（2种方法）"></a>二、字符串转数组（2种方法）</h3><table><thead><tr><th>字符串方法</th><th>说明</th></tr></thead><tbody><tr><td>split() 方法</td><td>将字符串转换成一个数组</td></tr><tr><td>扩展运算符（…）</td><td>es6里面的扩展运算符</td></tr></tbody></table><p><strong>1.split() 方法用于把一个字符串分割成字符串数组</strong></p><p>同样是用于把一个字符串分割成字符串数组，split(’,’)，split()，split(‘’）的区别是什么？</p><table><thead><tr><th>split()方法</th><th>说明</th></tr></thead><tbody><tr><td>split(“,”)</td><td>以逗号分隔的转换为数组</td></tr><tr><td>split(‘’）空字符串</td><td>每个字符之间都会被分割</td></tr><tr><td>split()</td><td>可理解为直接变成数组</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;aa, bb, cc, dd&quot;</span>;<br><span class="hljs-keyword">var</span> str1 = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">var</span> str2 = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">var</span> str3 = str.<span class="hljs-title function_">split</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1); <span class="hljs-comment">// [ &#x27;aa&#x27;, &#x27; bb&#x27;, &#x27; cc&#x27;, &#x27; dd&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;b&#x27;, &#x27;b&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;c&#x27;, &#x27;c&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;d&#x27;, &#x27;d&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str3); <span class="hljs-comment">// [ &#x27;aa, bb, cc, dd&#x27; ]</span><br></code></pre></td></tr></table></figure><p><strong>2.扩展运算符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;aa,bb,cc,dd&quot;</span>;<br><span class="hljs-keyword">var</span> str1 = [...str];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27;b&#x27;,&#x27;b&#x27;, &#x27;,&#x27;, &#x27;c&#x27;, &#x27;c&#x27;,&#x27;,&#x27;, &#x27;d&#x27;, &#x27;d&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="3-数组常用方法（√）"><a href="#3-数组常用方法（√）" class="headerlink" title="3.数组常用方法（√）"></a>3.数组常用方法（√）</h2><h3 id="一、改变原数组的方法7个"><a href="#一、改变原数组的方法7个" class="headerlink" title="一、改变原数组的方法7个"></a>一、改变原数组的方法7个</h3><p>总结：push、pop</p><p><strong>1.push()末尾添加数据</strong></p><p><strong>语法:</strong> <strong>数组名.push(</strong> <strong>数据)</strong></p><p><strong>作用:</strong> 就是往数组末尾添加数据</p><p><strong>返回值:</strong> 就是这个数组的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br>res = arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[10,20,30,40,20]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p><strong>2.pop() 末尾处删除数据</strong></p><p><strong>语法:</strong> <strong>数组名.pop()</strong></p><p><strong>作用:</strong> 就是从数组的末尾删除一个数据</p><p><strong>返回值:</strong> 就是你删除的那个数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>] <br>res =arr.<span class="hljs-title function_">pop</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[10,20,30]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//40</span><br></code></pre></td></tr></table></figure><p><strong>3.unshift() 头部添加数据</strong></p><p><strong>语法:</strong> <strong>数组名.unshift(</strong> <strong>数据)</strong></p><p><strong>作用:</strong>  就是在数组的头部添加数据</p><p><strong>返回值:</strong> 就是数组的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br> res=arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">99</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[99,10,20,30,40]</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p><strong>4.shift()头部删除数据</strong></p><p><strong>语法:</strong> <strong>数组名.shift()</strong></p><p><strong>作用:</strong>  头部删除一个数据</p><p><strong>返回值:</strong>  就是删除掉的那个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //shift">//shift复制代码 var arr = [10, 20, 30, 40]<br> res=arr.shift()<br> console.log(arr);[20,30,40]<br> console.log(res);10<br></code></pre></td></tr></table></figure><p><strong>5.reverse() 翻转数组</strong></p><p><strong>语法:</strong> <strong>数组名.reverse()</strong></p><p><strong>作用:</strong> 就是用来翻转数组的</p><p><strong>返回值:</strong> 就是翻转好的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //reverse">//reverse复制代码var arr = [10, 20, 30, 40]<br>res=arr.reverse()<br>console.log(arr);//[40,30,20,10]<br>console.log(res);//[40,30,20,10]<br></code></pre></td></tr></table></figure><p><strong>6.sort() 排序</strong></p><p><strong>语法一</strong>: 数组名.sort()   会排序，会按照位排序</p><p><strong>语法二</strong>: 数组名.sort(function (a,b) {return a-b})  会正序排列</p><p><strong>语法三</strong>: 数组名.sort(function (a,b) {return b-a})  会倒序排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">63</span>, <span class="hljs-number">48</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">75</span>, <span class="hljs-number">69</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>]<br>arr.<span class="hljs-title function_">sort</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 11, 2, 23, 4, 48, 5, 63, 69, 75]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span>(a-b)&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [2,  4,  5, 11, 23, 48, 63, 69, 75     ]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span>(b-a)&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [75, 69, 63, 48, 23, 11,  5,  4,  2]</span><br></code></pre></td></tr></table></figure><p><strong>7.splice()  截取数组</strong></p><p><strong>语法一</strong>: 数组名.splice(开始索引,多少个)</p><p>​作用: 就是用来截取数组的</p><p>​返回值: 是一个新数组 里面就是你截取出来的数据</p><p><strong>语法二</strong>: 数组名.splice(开始索引,多少个,你要插入的数据)</p><p>​作用: 删除并插入数据</p><p>​注意: 从你的开始索引起</p><p>​返回值: 是一个新数组 里面就是你截取出来的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //splice()">var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,2)<br>console.log(arr); // [ 2, 5, 4, 75 ]<br>console.log(res); // [ 63, 48 ]<br>//******************************<br>//splice() 语法二<br>var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,1,99999,88888)<br>console.log(arr); // [2, 99999, 88888, 48, 5, 4, 75]<br>console.log(res); // [ 63 ]<br></code></pre></td></tr></table></figure><h3 id="二、不改变原数组的方法5个"><a href="#二、不改变原数组的方法5个" class="headerlink" title="二、不改变原数组的方法5个"></a>二、不改变原数组的方法5个</h3><p><strong>1.concat() 合并数组</strong></p><p><strong>语法:</strong> <strong>数组名.concat(</strong> <strong>数据)</strong></p><p><strong>作用:</strong>  合并数组的</p><p><strong>返回值:</strong>  一个新的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>res = arr.<span class="hljs-title function_">concat</span>(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;小敏&quot;</span>,<span class="hljs-number">50</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [10, 20, 10, 30, 40, 50, 60]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// [10, 20, 10, 30, 40, 50, 60, 20,&quot;小敏&quot;,50]</span><br></code></pre></td></tr></table></figure><p><strong>2.join()  数组转字符串</strong></p><p><strong>语法:</strong> **数组名.join(‘**<strong>连接符’)</strong></p><p><strong>作用:</strong> 就是把一个数组转成字符串</p><p><strong>返回值:</strong>  就是转好的一个字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>res = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;+&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// var arr = [10, 20, 10, 30, 40, 50, 60]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 10+20+10+30+40+50+60</span><br></code></pre></td></tr></table></figure><p><strong>3.slice() 截取数组的一部分数据</strong></p><p><strong>语法:</strong> <strong>数组名.slice(</strong> <strong>开始索引,</strong> <strong>结束索引)</strong></p><p><strong>作用:</strong> 就是截取数组中的一部分数据</p><p><strong>返回值:</strong> 就是截取出来的数据 放到一个新的数组中</p><p><strong>注意:</strong> 包前不好后 包含开始索引不包含结束索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //slice">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.slice(1,4)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // [20, 10, 30]<br></code></pre></td></tr></table></figure><p><strong>4.indexOf() 从左检查数组中有没有这个数值</strong></p><p><strong>语法一:</strong> <strong>数组名.indexOf(要查询的数据)</strong></p><p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p><p>如果有就返回该数据<strong>第一次</strong>出现的索引</p><p>如果没有返回 -1</p><p><strong>语法二:</strong> <strong>数组名.indexOf(要查询的数据, 开始索引)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //indexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // 0<br>//*************************************<br>//indexOf  语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10,1)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // 2<br></code></pre></td></tr></table></figure><p><strong>5.lastIndexOf() 从右检查数组中有没有这个数值</strong></p><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p><p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p><p>如果有就返回该数据<strong>第一次</strong>出现的索引</p><p>如果没有返回 -1</p><p><strong>语法二:</strong> <strong>数组名.lastIndexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //lastIndexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50)<br>console.log(arr) <br>console.log(res);<br>//*************************************<br>//lastIndexOf 语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50,4)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure><h3 id="三、ES6新增的数组方法7个（都不改变原数组）"><a href="#三、ES6新增的数组方法7个（都不改变原数组）" class="headerlink" title="三、ES6新增的数组方法7个（都不改变原数组）"></a>三、ES6新增的数组方法7个（都不改变原数组）</h3><p><strong>1. forEach()  用来循环遍历数组</strong></p><p><strong>语法</strong>: 数组名.forEach(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来循环遍历数组的 代替了我们的for</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //forEach">var arr = [1, 2, 3, 4, 5]<br>var res = arr.forEach(function (item, index, arr) &#123;<br>    console.log(item, &quot;------&quot;, index, &quot;-------&quot;, arr);<br>&#125;)<br>// 输出：<br>// 1 ------ 0 ------- [ 1, 2, 3, 4, 5 ]<br>// 2 ------ 1 ------- [ 1, 2, 3, 4, 5 ]<br>// 3 ------ 2 ------- [ 1, 2, 3, 4, 5 ]<br>// 4 ------ 3 ------- [ 1, 2, 3, 4, 5 ]<br>// 5 ------ 4 ------- [ 1, 2, 3, 4, 5 ]<br></code></pre></td></tr></table></figure><p><strong>2.map()  映射数组</strong></p><p><strong>语法:</strong> 数组名.map(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来数组映射</p><p><strong>返回值:</strong> 必然是一个映射完毕的数组；这个数组和原数组长度一样，不改变原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">return</span> item*<span class="hljs-number">1000</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><span class="hljs-comment">// 返回值：</span><br><span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-comment">// [ 1000, 2000, 3000, 4000, 5000 ]</span><br></code></pre></td></tr></table></figure><p><strong>3.filter()  过滤数组</strong></p><p><strong>语法</strong>: 数组名.filter(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 用来过滤数组的</p><p><strong>返回值</strong>: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs //filter">var arr = [1, 2, 3, 4, 5]<br>var res = arr.filter(function (item) &#123;<br>    return item &gt; 2<br>&#125;)<br>console.log(arr);<br>console.log(res);<br>// 返回值：<br>// [ 1, 2, 3, 4, 5 ]<br>// [ 3, 4, 5 ]<br></code></pre></td></tr></table></figure><p><strong>4.every()  判断数组是不是满足所有条件</strong></p><p><strong>语法</strong>: 数组名.every(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 主要是用来判断数组中是不是 每一个 都满足条件。只有所有的都满足条件返回的是true，只要有一个不满足返回的就是false</p><p><strong>返回值</strong>: 是一个布尔值 </p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //every">//every复制代码var arr = [1, 2, 3, 4, 5]<br>var res = arr.every(function (item) &#123;<br>    return item &gt; 0<br>&#125;)<br>console.log(res);//打印结果  true<br></code></pre></td></tr></table></figure><p><strong>5.some() 数组中有没有满足条件的</strong></p><p><strong>语法</strong>: 数组名.some(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 主要是用来判断数组中是不是 每一个 都满足条件。只有有一个满足条件返回的是true，只要都不满足返回的就是false</p><p><strong>返回值</strong>: 是一个布尔值</p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //some">var arr = [1, 2, 3, 4, 5]<br>var res = arr.some(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res); //true<br></code></pre></td></tr></table></figure><p><strong>6.find() 用来获取数组中满足条件的第一个数据</strong></p><p><strong>语法</strong>: 数组名.find(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 用来获取数组中满足条件的数据</p><p><strong>返回值</strong>: 如果有 就是满足条件的第一个数据；如果没有就是undefined</p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //find">var arr = [1, 2, 3, 4, 5]<br>var res = arr.find(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res) //4<br></code></pre></td></tr></table></figure><p><strong>7.reduce() 累加后的效果</strong></p><p><strong>语法</strong>: 数组名.reduce(function (prev,item,index,arr) {},初始值)</p><ul><li>prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果</li><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来累加的</p><p><strong>返回值</strong>: 就是累加后的结果</p><p><strong>注意</strong>: 以return的形式书写返回条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prev, item</span>) &#123;<br>    <span class="hljs-keyword">return</span> prev *= item<br>&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">//120</span><br></code></pre></td></tr></table></figure><h2 id="4-深拷贝和浅拷贝、赋值（√）"><a href="#4-深拷贝和浅拷贝、赋值（√）" class="headerlink" title="4.深拷贝和浅拷贝、赋值（√）"></a>4.深拷贝和浅拷贝、赋值（√）</h2><p><strong>其他问法</strong>：数组深拷贝方法</p><p>参考：<a href="https://juejin.cn/post/7134970746580762637?searchId=20230903212139B6B7DB5B5E108D8F55BD">前端面试 第三篇 js之路 深拷贝与浅拷贝 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/6994453856063062053#heading-6">JavaScript深拷贝和浅拷贝看这篇就够了 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/7020348927643746312">前端数组、对象的浅拷贝和深拷贝 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/6844904197595332622">浅拷贝与深拷贝 - 掘金 (juejin.cn)</a></p><p><strong>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。</strong></p><p><strong>浅拷贝</strong>: ① 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。② 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以<strong>如果其中一个对象改变了这个地址里的内容，就会影响到另一个对象</strong>。（只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃）；</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715c839f767d41dc98669788c9705772~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=277&s=82226&e=png&b=fdf9f8" alt="image.png"  width="50%"/></p><p><strong>深拷贝</strong>: ① 创建一个新对象，将原始对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，新旧对象不共享同一块内存，且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样可以避免指针悬挂）</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5058d13e4a548a3b40e0ae074ffbb92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=373&s=84518&e=png&b=fefdfd" alt="image.png"  width="50%"/></p><p>【默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝。】</p><p><font color=red><strong>赋值和深&#x2F;浅拷贝的区别</strong></font>，比较的前提都是<strong>针对引用类型</strong>：</p><ul><li>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li><li>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。</li></ul><table>    <tr>        <th  colspan=4 align="center">对原始数据的影响</th>    </tr>    <tr>        <th width=100px bgcolor=skyblue></th>        <th bgcolor=skyblue>和原数据是否指向同一对象</th>        <th bgcolor=skyblue>第一层数据为基本数据类型</th>        <th bgcolor=skyblue>原数据包含子对象（引用数据类型）</th>    </tr>    <tr>        <td>赋值</td>        <td>是</td>        <td>赋值后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>        <td>赋值后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>    </tr>    <tr>        <td>浅拷贝</td>        <td>否</td>        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>        <td>浅拷贝后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>    </tr>    <tr>        <td>深拷贝</td>        <td>否</td>        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>    </tr></table><p>举例：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 对象赋值</span><br>let obj1 = &#123;<br> <span class="hljs-keyword">name</span>: <span class="hljs-string">&quot;Chen&quot;</span>,<br> age: <span class="hljs-number">18</span>,<br> hobby: [<span class="hljs-string">&quot;see a film&quot;</span>, <span class="hljs-string">&quot;write the code&quot;</span>, <span class="hljs-string">&quot;play basketball&quot;</span>, <span class="hljs-string">&quot;tourism&quot;</span>],<br>&#125;;<br>let obj2 = obj1;<br>obj2.<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;Forever&quot;</span>;<br>obj2.hobby[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;swim&quot;</span>;<br>obj2.hobby[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;alpinism&quot;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;obj1===&gt;&quot;</span>, obj1);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;obj2===&gt;&quot;</span>, obj2);<br><span class="hljs-comment">// 输出为：</span><br>obj1===&gt; &#123;<br>  <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  hobby: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br>obj2===&gt; &#123;<br>  <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  hobby: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br><span class="hljs-comment">// 结论：对象中基本属性和引用属性都发生改变</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 浅拷贝</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Chen&quot;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br> <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&quot;see a film&quot;</span>, <span class="hljs-string">&quot;write the code&quot;</span>, <span class="hljs-string">&quot;play basketball&quot;</span>, <span class="hljs-string">&quot;tourism&quot;</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj3 = &#123; ...obj1 &#125;;<br>obj3.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Forever&quot;</span>;<br>obj3.<span class="hljs-property">hobby</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;swim&quot;</span>;<br>obj3.<span class="hljs-property">hobby</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;alpinism&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj1===&gt;&quot;</span>, obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj3===&gt;&quot;</span>, obj3);<br><span class="hljs-comment">// 输出为：</span><br>obj1===&gt; &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Chen&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">hobby</span>: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br>obj3===&gt; &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">hobby</span>: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br><span class="hljs-comment">// 结论：浅拷贝时，对象中基本属性不变，引用属性发生变化</span><br></code></pre></td></tr></table></figure><p><strong>注意：当拷贝对象只有一层的时候，是深拷贝</strong></p><h3 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h3><ol><li><strong>Object.assign()</strong></li></ol><p>参考资料：<a href="https://juejin.cn/post/6844903984675684366">Object.assign()基本用法、注意点、用法</a></p><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象<code>source</code>复制到目标对象。</p><p><strong>参数：</strong>第一个参数是目标对象，后面的参数都是源对象。</p><p><strong>返回：</strong>目标对象<code>target</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<br><span class="hljs-keyword">const</span> source = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span> &#125;<br><span class="hljs-keyword">const</span> returnedTarget = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source)<br>target <span class="hljs-comment">// &#123; a: 1, b: 4, c: 5 &#125;</span><br>returnedTarget  <span class="hljs-comment">// &#123; a: 1, b: 4, c: 5 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p></li><li><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p></li><li><p>如果该参数不是对象，则会先转成对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为第一个参数，就会报错。如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，<u>除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</u></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit">let obj = &#123;a: <span class="hljs-number">1</span>&#125;<br>Object.<span class="hljs-built_in">assign</span>(obj, undefined) === obj // <span class="hljs-literal">true</span><br>Object.<span class="hljs-built_in">assign</span>(obj, <span class="hljs-literal">null</span>) === obj   // <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">const</span> v1 = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">const</span> v2 = <span class="hljs-literal">true</span><br><span class="hljs-keyword">const</span> v3 = <span class="hljs-number">10</span><br><span class="hljs-keyword">const</span> obj = Object.<span class="hljs-built_in">assign</span>(&#123;&#125;, v1, v2, v3)<br>obj // &#123; <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;c&quot;</span> &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p></li></ul><p>数组的处理 <code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<span class="hljs-comment">// [4, 5, 3]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.assign</code>把数组视为属性名为 <code>0、1、2</code> 的对象，因此源数组的 <code>0</code> 号属性<code>4</code>覆盖了目标数组的 <code>0</code> 号属性<code>1</code>。</p><ol start="2"><li><strong>函数库lodash的_.clone方法</strong></li></ol><p>该函数库也有提供_.clone用来做浅拷贝，后面我们会再介绍利用这个库实现深拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">clone</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>扩展运算符…</strong></li></ol><p>提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Kobe&#x27;</span>, <span class="hljs-attr">address</span>:&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">100</span>&#125;&#125;<br><span class="hljs-keyword">let</span> obj2= &#123;... obj1&#125;<br>obj1.<span class="hljs-property">address</span>.<span class="hljs-property">x</span> = <span class="hljs-number">200</span>;<br>obj1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj2&#x27;</span>,obj2) <span class="hljs-comment">// obj2 &#123; name: &#x27;Kobe&#x27;, address: &#123; x: 200, y: 100 &#125; &#125;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>Array.prototype.concat()</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;kobe&#x27;</span><br>    &#125;];<br><span class="hljs-keyword">let</span> arr2 = arr.<span class="hljs-title function_">concat</span>();    <br>arr2[<span class="hljs-number">2</span>].<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;wade&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">//[ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>Array.prototype.slice()</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27; kobe&#x27;</span><br>    &#125;];<br><span class="hljs-keyword">let</span> arr3 = arr.<span class="hljs-title function_">slice</span>();<br>arr3[<span class="hljs-number">2</span>].<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><h3 id="深拷贝的实现："><a href="#深拷贝的实现：" class="headerlink" title="深拷贝的实现："></a>深拷贝的实现：</h3><ol><li><strong>JSON.parse(JSON.stringify())</strong></li></ol><p>利用<code>JSON.stringify</code>将对象转成JSON字符串，再用<code>JSON.parse</code>把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p><ol start="2"><li><strong>函数库lodash的_.cloneDeep方法</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>jQuery.extend()方法</strong></li></ol><p>jquery 有提供一個<code>$.extend</code>可以用来做 Deep Copy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">extend</span>(deepCopy, target, object1, [objectN])  <span class="hljs-comment">//第一个参数为true,就是深拷贝</span><br><br><span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = $.<span class="hljs-title function_">extend</span>(<span class="hljs-literal">true</span>, &#123;&#125;, obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>); <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>手写递归方法</strong></li></ol><p>递归方法实现深度拷贝原理：<strong>遍历 对象或数组 直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong>。</p><p>有种特殊情况需注意就是对象存在<strong>循环引用</strong>的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。关于这块如有疑惑，请仔细阅读<code>ConardLi大佬</code><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000020255831">如何写出一个惊艳面试官的深拷贝?</a>这篇文章。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 如果是null或者undefined我就不进行拷贝操作</span><br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj);<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj);<br>  <span class="hljs-comment">// 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> obj;<br>  <span class="hljs-comment">// 是对象的话就要进行深拷贝</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">get</span>(obj)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj);<br>  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br>  <span class="hljs-comment">// 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span><br>  hash.<span class="hljs-title function_">set</span>(obj, cloneObj);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-comment">// 实现一个递归拷贝</span><br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj;<br>&#125;<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">address</span>: &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">100</span> &#125; &#125;;<br>obj.<span class="hljs-property">o</span> = obj; <span class="hljs-comment">// 对象存在循环引用的情况</span><br><span class="hljs-keyword">let</span> d = <span class="hljs-title function_">deepClone</span>(obj);<br>obj.<span class="hljs-property">address</span>.<span class="hljs-property">x</span> = <span class="hljs-number">200</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d);<br></code></pre></td></tr></table></figure><p>数组实现深拷贝可以使用以下方法</p><ul><li>使用<code>slice()</code></li><li>使用<code>concat()</code></li><li>ES6扩展运算符[…str]</li><li>Array.from()</li></ul><h2 id="5-手写深拷贝函数-（√）"><a href="#5-手写深拷贝函数-（√）" class="headerlink" title="5.手写深拷贝函数 （√）"></a>5.手写深拷贝函数 （√）</h2><p>这里写了三种，参考资料：<a href="https://juejin.cn/post/7264208575974834231?searchId=20230904153935A317FD4976A2592BDE92#heading-8">手写深浅拷贝</a></p><ol><li>简单版（JSON）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">jobs</span>: &#123;<br>        <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;FE&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a))<br>a.<span class="hljs-property">jobs</span>.<span class="hljs-property">first</span> = <span class="hljs-string">&#x27;native&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">jobs</span>.<span class="hljs-property">first</span>) <span class="hljs-comment">// FE</span><br></code></pre></td></tr></table></figure><ol start="2"><li>基础版（手写递归）</li></ol><p>下面是一个实现 <code>deepClone</code> 函数封装的例子，通过 <code>for in</code> 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;<br>  <span class="hljs-attr">a</span>:&#123;<br>    <span class="hljs-attr">b</span>:<span class="hljs-number">1</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123; <br>  <span class="hljs-keyword">let</span> cloneObj = &#123;&#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;                 <span class="hljs-comment">//遍历</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[key] ===<span class="hljs-string">&#x27;object&#x27;</span>) &#123; <br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key])  <span class="hljs-comment">//是对象就再次调用该函数递归</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cloneObj[key] = obj[key]  <span class="hljs-comment">//基本类型的话直接复制值</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title function_">deepClone</span>(obj1);<br>obj1.<span class="hljs-property">a</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2);   <span class="hljs-comment">//  &#123;a:&#123;b:1&#125;&#125;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>进阶版（递归实现）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断一个对象是否为复杂数据类型，即对象或函数类型，且不为 null</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isComplexDataType</span> = obj =&gt; (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;function&#x27;</span>) &amp;&amp; (obj !== <span class="hljs-literal">null</span>)<br><br><span class="hljs-comment">// 定义深拷贝函数 deepClone，接受两个参数：obj 为要进行深拷贝的目标对象，hash 为已经拷贝过的对象的哈希表（用于解决循环引用问题）</span><br><span class="hljs-keyword">const</span> deepClone = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-comment">// 1.如果目标对象是日期对象，则直接返回一个新的日期对象，避免修改原日期对象</span><br>  <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Date</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>  &#125;<br>  <span class="hljs-comment">// 2.如果目标对象是正则对象，则直接返回一个新的正则对象，避免修改原正则对象</span><br>  <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">RegExp</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<br>  &#125;<br>  <span class="hljs-comment">// 3.如果目标对象已经被拷贝过，则从 hash 中获取已经拷贝过的对象并返回，避免出现循环引用问题</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) &#123;<br>    <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj)<br>  &#125;<br>  <span class="hljs-comment">// 获取目标对象的所有属性描述符</span><br>  <span class="hljs-keyword">let</span> allDesc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(obj)<br>  <span class="hljs-comment">// 创建一个新对象 cloneObj，并将其原型链指向 obj 的原型对象</span><br>  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj), allDesc)<br>  <span class="hljs-comment">// 将目标对象和克隆对象的映射关系存入 hash 中，用于解决循环引用问题</span><br>  hash.<span class="hljs-title function_">set</span>(obj, cloneObj)<br>  <span class="hljs-comment">// 遍历目标对象的所有属性（包括字符串类型和 Symbol 类型的属性名）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)) &#123; <br>    <span class="hljs-comment">// 如果目标对象的属性值是复杂数据类型（即对象或数组），则递归调用 deepClone 函数进行深拷贝，并将拷贝结果赋值给克隆对象的对应属性</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isComplexDataType</span>(obj[key]) &amp;&amp; <span class="hljs-keyword">typeof</span> obj[key] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果目标对象的属性值不是复杂数据类型，则直接将其赋值给克隆对象的对应属性</span><br>      cloneObj[key] = obj[key]<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回深拷贝后的新对象</span><br>  <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-call、bind、apply的作用和区别？"><a href="#6-call、bind、apply的作用和区别？" class="headerlink" title="6.call、bind、apply的作用和区别？"></a>6.call、bind、apply的作用和区别？</h2><p>其他问法：改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是</p><h2 id="7-轮播图实现思路-（√）"><a href="#7-轮播图实现思路-（√）" class="headerlink" title="7.轮播图实现思路 （√）"></a>7.轮播图实现思路 （√）</h2><p>实现前端轮播图（也称为轮播幻灯片或轮播广告）通常涉及以下主要步骤和思路：</p><ol><li><strong>HTML结构：</strong> 首先，在HTML中创建轮播图的基本结构。通常会使用一个包含图像或内容的容器，并为每个轮播项创建一个子元素。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;carousel&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;carousel-item&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 内容或图像1 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;carousel-item&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 内容或图像2 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 更多轮播项 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>CSS样式：</strong> 使用CSS样式来定义轮播图容器的外观，包括宽度、高度、位置等。还可以设置轮播项的布局和过渡效果。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.carousel</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.carousel-item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: none; <span class="hljs-comment">/* 隐藏所有项，除了当前活动的项 */</span><br>  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1s</span>; <span class="hljs-comment">/* 过渡效果 */</span><br>&#125;<br><span class="hljs-selector-class">.carousel-item</span><span class="hljs-selector-class">.active</span> &#123;<br>  <span class="hljs-attribute">display</span>: block; <span class="hljs-comment">/* 显示当前活动的项 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>JavaScript交互：</strong> 使用JavaScript来实现轮播图的交互逻辑。以下是一些常见的实现思路：<ul><li><strong>自动播放：</strong> 设置定时器，以一定的时间间隔自动切换到下一张轮播项。</li><li><strong>手动控制：</strong> 添加前进和后退按钮，以允许用户手动浏览轮播项。</li><li><strong>指示器：</strong> 创建轮播指示器，以显示当前轮播项的位置，并允许用户通过点击指示器来切换轮播项。</li><li><strong>循环播放：</strong> 当到达最后一张轮播项时，循环回到第一张。</li><li><strong>响应式设计：</strong> 确保轮播图在不同屏幕尺寸下适应，并且图像大小和数量能够自动调整。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentSlide = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> slides = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.carousel-item&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showSlide</span>(<span class="hljs-params">index</span>) &#123;<br>  slides[currentSlide].<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>  slides[index].<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>  currentSlide = index;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextSlide</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> next = (currentSlide + <span class="hljs-number">1</span>) % slides.<span class="hljs-property">length</span>;<br>  <span class="hljs-title function_">showSlide</span>(next);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">prevSlide</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> prev = (currentSlide - <span class="hljs-number">1</span> + slides.<span class="hljs-property">length</span>) % slides.<span class="hljs-property">length</span>;<br>  <span class="hljs-title function_">showSlide</span>(prev);<br>&#125;<br><br><span class="hljs-comment">// 自动播放</span><br><span class="hljs-built_in">setInterval</span>(nextSlide, <span class="hljs-number">5000</span>);<br><br><span class="hljs-comment">// 手动控制按钮</span><br><span class="hljs-keyword">const</span> nextButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;next-button&#x27;</span>);<br><span class="hljs-keyword">const</span> prevButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;prev-button&#x27;</span>);<br><br>nextButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, nextSlide);<br>prevButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, prevSlide);<br></code></pre></td></tr></table></figure><p><strong>优化和性能：</strong> 对于包含大量图像的轮播图，应考虑性能优化，如懒加载图像，压缩图像大小等。</p><h2 id="8-闭包的原理"><a href="#8-闭包的原理" class="headerlink" title="8.闭包的原理"></a>8.闭包的原理</h2><h2 id="9-手写promise"><a href="#9-手写promise" class="headerlink" title="9.手写promise"></a>9.手写promise</h2><h2 id="10-原型链的理解"><a href="#10-原型链的理解" class="headerlink" title="10.原型链的理解"></a>10.原型链的理解</h2><h2 id="11-对继承有什么了解吗？有几种方式？优劣？"><a href="#11-对继承有什么了解吗？有几种方式？优劣？" class="headerlink" title="11.对继承有什么了解吗？有几种方式？优劣？"></a>11.对继承有什么了解吗？有几种方式？优劣？</h2><h2 id="12-对异步编程有什么了解？就回调函数、Promise，async-await，具体的是指什么？"><a href="#12-对异步编程有什么了解？就回调函数、Promise，async-await，具体的是指什么？" class="headerlink" title="12.对异步编程有什么了解？就回调函数、Promise，async&#x2F;await，具体的是指什么？"></a>12.对异步编程有什么了解？就回调函数、Promise，async&#x2F;await，具体的是指什么？</h2><h2 id="13-作用域"><a href="#13-作用域" class="headerlink" title="13.作用域"></a>13.作用域</h2><h2 id="14-事件循环"><a href="#14-事件循环" class="headerlink" title="14.事件循环"></a>14.事件循环</h2><p>给一段代码，事件循环结果输出是什么</p><p>1 实习内容介绍，你们的分页怎么实现，假如不给你total值，你可以实现分页吗，你觉得一个分页组件的核心要素是什么（有没有佬解答一下）<br>7渲染10w条数据怎么优化，虚拟列表技术上怎么实现，闪烁怎么解决<br>8常见性能优化手段<br>9假如用户打开了你的网站，但是是白屏你怎么解决<br>10说一下hashmap，常见数据结构<br>12nodejs有没有接触<br>13你对前端的看法，你更想做前端的哪个方向</p><h1 id="📚-ES6"><a href="#📚-ES6" class="headerlink" title="📚 ES6"></a>📚 ES6</h1><h2 id="1-ES6模块化"><a href="#1-ES6模块化" class="headerlink" title="1.ES6模块化"></a>1.ES6模块化</h2><h2 id="2-Promise和async-await"><a href="#2-Promise和async-await" class="headerlink" title="2.Promise和async&#x2F;await"></a>2.Promise和async&#x2F;await</h2><h1 id="📚-浏览器"><a href="#📚-浏览器" class="headerlink" title="📚 浏览器"></a>📚 浏览器</h1><h2 id="1-浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别"><a href="#1-浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别" class="headerlink" title="1.浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别"></a>1.浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别</h2><h2 id="2-前端缓存方法"><a href="#2-前端缓存方法" class="headerlink" title="2.前端缓存方法"></a>2.前端缓存方法</h2><h2 id="3-输入URL到页面渲染的过程"><a href="#3-输入URL到页面渲染的过程" class="headerlink" title="3.输入URL到页面渲染的过程"></a>3.输入URL到页面渲染的过程</h2><h2 id="4-同源策略和跨域"><a href="#4-同源策略和跨域" class="headerlink" title="4.同源策略和跨域"></a>4.同源策略和跨域</h2><h1 id="📚-计算机网络"><a href="#📚-计算机网络" class="headerlink" title="📚 计算机网络"></a>📚 计算机网络</h1><h2 id="1-介绍一下Http各个版本"><a href="#1-介绍一下Http各个版本" class="headerlink" title="1.介绍一下Http各个版本"></a>1.介绍一下Http各个版本</h2><h1 id="📚-性能优化"><a href="#📚-性能优化" class="headerlink" title="📚 性能优化"></a>📚 性能优化</h1><h2 id="1-防抖和节流的实现方式"><a href="#1-防抖和节流的实现方式" class="headerlink" title="1.防抖和节流的实现方式"></a>1.防抖和节流的实现方式</h2><h2 id="2-图片懒加载"><a href="#2-图片懒加载" class="headerlink" title="2.图片懒加载"></a>2.图片懒加载</h2><h1 id="📚-vue2-vue3"><a href="#📚-vue2-vue3" class="headerlink" title="📚 vue2+vue3"></a>📚 vue2+vue3</h1><h2 id="1-Vue-diff算法"><a href="#1-Vue-diff算法" class="headerlink" title="1.Vue diff算法"></a>1.Vue diff算法</h2><h2 id="2-Vue组件通信"><a href="#2-Vue组件通信" class="headerlink" title="2.Vue组件通信"></a>2.Vue组件通信</h2><p>包括父子组件通信：父传子，子传父，兄弟组件通信</p><p>项目用的vue2 问会不会vue3</p><p>vue3取消了mixin，用什么代替<br>适配是怎么实现的 为啥要适配<br>采用px-vw不会造成拉伸吗<br>axios发送的请求如何取消<br>404要怎么实现<br>如何在登录前防止用户访问<br>前后端分离相较前后端不分离的区别<br>用的什么打包工具<br>使用webpack做了什么<br>webpack如何打包import<br>封装过什么组件<br>对项目提出过什么改进</p><h1 id="📚-面试题带坑"><a href="#📚-面试题带坑" class="headerlink" title="📚 面试题带坑"></a>📚 面试题带坑</h1><h2 id="1-console-log-“1”-“2”-“3”-map-parseInt-的输出值是多少？"><a href="#1-console-log-“1”-“2”-“3”-map-parseInt-的输出值是多少？" class="headerlink" title="1.console.log([“1”, “2”, “3”].map(parseInt));的输出值是多少？"></a>1.console.log([“1”, “2”, “3”].map(parseInt));的输出值是多少？</h2><p>来源：<a href="https://juejin.cn/post/7049161354703273998">parseInt()函数绝不是你想的那么简单~~ - 掘金 (juejin.cn)</a></p><p>【知识点】：map()和parseInt()</p><p>【分析】<code>map</code>方法可以将一个数组映射为一个新数组。它接收一个<code>callback</code>回调函数作为参数，这个回调函数体现了将原数组映射成新数组的映射关系。原数组在循环遍历数组每一项时，都会调用一次<code>callback</code>回调函数，并传入三个参数：</p><ul><li>当前正在遍历的元素</li><li>元素索引</li><li>原数组本身 (这个参数基本不使用)</li></ul><p><code>callback</code>函数对当前遍历的元素进行包装执行，得到的返回值就是新数组中对应的结果</p><p><code>parseInt</code>接收两个参数：</p><ul><li>第一个参数<code>string</code>：要被解析的字符串，如果不是字符串会被转换，忽视空格符</li><li>第二个参数<code>radix</code>：要解析的数字的基数。该值介于<code>2 ~ 36</code>之间。默认值为10，表示十进制。这个参数表示<strong>将前面的字符从radix进制转化为十进制</strong></li></ul><p>把上面的代码的完整写法为：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<br>  [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, arr</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item + <span class="hljs-string">&quot;-----&quot;</span> + index);<br>    <span class="hljs-keyword">return</span> parseInt(item, index);<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><p>每次每一项给parseInt传入的值为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><span class="hljs-comment">-----0</span><br><span class="hljs-number">2</span><span class="hljs-comment">-----1</span><br><span class="hljs-number">3</span><span class="hljs-comment">-----2</span><br></code></pre></td></tr></table></figure><p>所以最终结果为：[ 1, NaN, NaN ]</p><p>其他：</p><p>PC端和移动端项目CSS的适配区别<br>\3. rem是怎么设置的，手动算的还是用了库<br>\4. rem和em的区别<br>\5. 屏幕大小变化的时候是如何适配的<br>\6. 直接写rem计算屏幕的宽高是怎么获取的<br>\7. 其他移动端适配的方法？<br>\8. 上一题提示：vw，vh<br>\9. 逻辑像素和物理像素的区别<br>\10. 浏览器渲染是如何解析渲染html文档的<br>\11. css下载的过程会阻塞js的下载吗<br>\12. 为什么阻塞？<br>\13. 项目性能优化的方式<br>\14. tree shaking的限制条件？比如模块化方式commonJS或ES6module的方法能实现吗<br>\15. 原生JS 类的实现方法，比如new一个函数的过程<br>\16. ES6的class编译完成后产物是什么样的，比如是函数or对象or数组<br>\17. 可以用var a &#x3D; new<br>\18. ES6中继承的原理？<br>\19. 原型链<br>\20. function的prototype是什么<br>\21. 闭包原理<br>\22. ES5有哪些作用域，ES6呢<br>\23. 项目中用过的异步方法怎么实现的<br>\24. promise传的参数(resolve，reject)执行时机是异步还是同步的<br>\25. 函数里有error会怎么样<br>\26. 必须catch吗，用then呢<br>\27. then后面再有then，是会进入resolve还是reject的回调<br>\28. async await原理<br>\29. await后面跟一个1或者字符串可以吗<br>\30. Generator函数接触过吗<br>\31. 浏览器的Eventloop和node的Eventloop区别<br>\32. 提示：事件循环<br>\33. 异步任务挂起之后还可以给下一个用户提供服务吗，(挂起期间有新用户访问)<br>\34. git用到哪些命令多一些<br>\35. merge用过吗<br>\36. 跨域问题如何解决<br>\37. 跨域请求的时候带cookie怎么带<br>\38. react 了解过吗，如果让你上手做可以做吗<br>\39. hook听过吗</p><p>做题<br>\1. 最长连续递增数组，复杂度多少，能优化到多少<br>\2. 二叉树层数</p><p>304状态码是什么，说一下这个请求的过程</p><p>详细说下协商缓存</p><p>HTTP2.0的多路复用是什么</p><p>CSRF是什么</p><p>如果是第三方的链接，直接拒绝访问是不是也可以，就是CSRF怎么达到一种攻击的状态，攻击了用户的什么东西</p><p>CSRF如何防御</p><p>CORS跨域的请求响应过程</p><p>origin的请求跨域网站头，能放很多域名吗</p><p>以上的流程和细节多学习</p><p>Vue的源码</p><p>如何监听一个对象属性的改变</p><p>浏览器如何解析Vue的模板，最终在浏览器中如何使用</p><p>Vue模板会解析成什么样子的东西，又没有了解</p><p>Vue的diff算法是什么</p><p>写一个div，第一个子元素用v-if控制，如何第一个元素v-if&#x3D;false，其中的子div会不会塌陷和挤压，结合diff算法来说</p><p>技术栈是react和Angluar，写游戏页面里的H5</p><p>面完十分钟秒挂，我说要是技术栈和业务方向 学历不匹配可以别面，别浪费彼此时间</p><p>webpack 原理？</p><p>Tree shaking 的原理？<br>- 想用 Tree Shaking 可以有哪些方式？<br>- 所有 ES6 写的都可以用 Tree Shaking 吗？<br>- Tree Shaking 有哪些限制？<br>- 如果我一个导入依赖另一个依赖 另一个依赖被 tree-shaking 掉了怎么办， CSS 引用复杂，CSS 没打进去怎么办？<br>- 微前端了解吗？<br>- 为什么需要微前端？<br>- 各种微前端的原理是什么？<br>- JS 全局隔离怎么做？<br>- 这种方法老版本兼容性不太好，有没有解决方案？<br>- webpack 的联邦模块要先加载 container，在去取 remotes，有性能浪费，能不能直接将主应用和子应用（remotes）同时加载，应该怎么做？<br>- B 端开发的时候有没有碰到什么问题、痛点？<br>- 实习问题、怎么解决的？<br>- 项目问，一个功能解决什么问题？<br>- 鉴权为什么要存 token？<br>- webworker 解决什么问题？<br>- Token 和 cookie ssession 方案？<br>- 这样会有什么安全问题？</p><p>js做数据循环用了哪些方法，如何实现的，这些方法哪种性能最好，哪种最不好<br>（我答的for最好，for…of最不好，也不知道对不对）<br>2、http2和http1.1的区别<br>3、axios库的原理<br>4、设计一个sdk实现前端发送的请求前加一个header，无论谁引用sdk，都会加header（偏场景题）<br>面试官给了一个aop埋点的思路<br>5、防抖和节流<br>6、vue双向绑定源码<br>7、promise常用的几种静态方法<br>8、react的jsx怎么转换成dom结构</p><p>美团（成都 到家事业群）前端面试记录</p><p>一面：<br>1 ts Partial<br>2 正则表达式匹配替换<br>3 Get是完全幂等的吗？<br>4 不适用js实现一个点击显示悬浮窗 active<br>5 webview上h5的屏幕适配<br>6 节流和防抖，应用场景<br>7 git代码出错标准处理<br>8 webpack打包优化和配置<br>9 babel和polyfill<br>10 盒模型 box-sizing<br>11 BFC<br>12 跨域和解决方案<br>13 dom操作 querySelectorAll（编程）<br>14 在Array原型链上添加flat()方法（编程）<br>15 驼峰命名转短横线命名（编程）</p><p>二面：<br>1 项目进度管理和质量保证<br>2 着重讲一下某个项目，遇到的具体难点是什么？<br>3 文件里面有一万个数，范围[0, 1000]，缓存大小只有2k，怎么实现排序及其优化？<br>4 节流函数（编程）<br>5 数组的左移右移实现（编程）<br>6 state变化到页面变化的整个过程</p><h1 id="OPPO前端面试记录"><a href="#OPPO前端面试记录" class="headerlink" title="OPPO前端面试记录"></a>OPPO前端面试记录</h1><p>1 为什么学习前端？<br>2 你对前端行业的认识？<br>3 Vue和React区别<br>4 Vue3和React16的新功能<br>5 前端性能优化策略<br>6 前端错误定位？<br>7 浏览器性能调试api？<br>8 事件循环<br>9 手机端h5适配方法？<br>10 尾递归</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续更新中</tag>
      
      <tag>html~css~js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 处理hexo博客中图片不显示问题</title>
    <link href="/2023/08/31/%F0%9F%93%A3-%E5%A4%84%E7%90%86hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/31/%F0%9F%93%A3-%E5%A4%84%E7%90%86hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>在解决这个问题的过程中，我经历了三个阶段，很磨人最终还是回到了起点，发现最初的方法最好，如果赶时间，可以直接看第三个阶段。</p><h1 id="🌸第一阶段：将图片保存在本地"><a href="#🌸第一阶段：将图片保存在本地" class="headerlink" title="🌸第一阶段：将图片保存在本地"></a>🌸第一阶段：将图片保存在本地</h1><p>搭建好个人博客网站之后，写了两篇markdown文章（这时候我图片用的是网络地址），然后按照hexo三连上传了文章，最后在浏览器打开发现图像不显示：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a0dd8fb049474f93f6d088d8dc2471~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=235&s=32490&e=png&b=fbfbfb" width="60%" /></p><p>一般图片显示不出来很大的原因是路径不对。于是我去查看了图片路径，确实找不到相应的图片。然后我参考<a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">相关资料</a>了解到<code>hexo g</code>指令是将md文件生成html页面，然后每篇博文生成的html页面最后都是放在用年月日做文件夹的下面，例如：<code>E:\myblog\public\2023\08\31\test</code>。</p><p>下面是我参考<a href="https://leay.net/2019/12/25/hexo/">养恐龙</a>、<a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">ETRD</a>、<a href="https://blog.csdn.net/m0_43401436/article/details/107191688">金牛大王</a>三位的回答，最终解决了我的问题。</p><p><strong>第一步</strong>：确保你的Hexo的配置文件_config.yml里面有这个选项配置，并将其置为true</p><pre><code class="hljs">post_asset_folder: true</code></pre><p>这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用<code>hexo n &quot;文章名&quot;</code>生成一篇新文章时，会在<code>\source\_posts</code>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66e0f2f20d7f4791a68b3973bf2f2734~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=225&s=31200&e=png&b=ffffff"  width=" 60%"/></p><p>【注】你也可以自己在 _posts 文件夹下自动生成md文件和相同名字的文件夹（用于存放图片）</p><p><strong>第二步</strong>：typora中的图像保存位置设置</p><p>点开文件——&gt;偏好设置，设置如下：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993af5c7afec466eaec981af9ac662ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1613&h=657&s=64676&e=png&b=fafafa" width="60%"/></p><p>修改好后，图片引用路径就在和博文同名的文件夹（新建博文名为test）的图片，如图所示：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc88f5524f094d118bedc8456e650126~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918&h=103&s=12423&e=png&b=ffffff" width="60%"/></p><p><strong>第三步</strong>：安装插件</p><p>在根目录下打开git bash，然后运行以下命令，如果有安装淘宝镜像，第一个改为cnpm即可。</p><pre><code class="hljs">npm install https://github.com/xcodebuild/hexo-asset-image.git</code></pre><p>运行结果如下图所示，图为安装成功：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/059d60bdaded4a0fa0f1ac61286f187e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=242&s=25251&e=png&b=000000" width="70%"/></p><p>该插件的作用：将图片等静态资源的引用路径转化为绝对路径。</p><p>【注】我最开始不是用的上面命令安装的，用的是<code>npm install hexo-asset-image -- save</code>，该命令安装的是插件 hexo-asset-image 1.0 ，这个版本有点问题，安装后图片不能正常显示，查看图片路径被渲染成了 <code>/.xx/abc.png</code> 的格式（xx 是域名后缀）。最后采用上面的命令才成功。</p><p>如何卸载该插件？路径：<code>\blog\node_modules\hexo-asset-image</code>，直接删除文件夹，我试过没问题。</p><h1 id="🌸-第二阶段：将图片保存到图床"><a href="#🌸-第二阶段：将图片保存到图床" class="headerlink" title="🌸 第二阶段：将图片保存到图床"></a>🌸 第二阶段：将图片保存到图床</h1><p>网上查了一些有关md文件中图片的保存位置，发现除了在本地保存外，还可以采用图床进行保存，可以尝试一下<a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 这个图床上传工具，也方便md文件在其他站的上传。</p><p>参考资料：<a href="https://blog.csdn.net/weixin_61529967/article/details/132273065">前端小雪</a>、<a href="https://blog.csdn.net/weixin_43447266/article/details/132490718">刘昕hrf</a>、<a href="https://blog.csdn.net/weixin_45525272/article/details/125387761">杨 戬</a></p><p>我根据上面三个参考回答实现了将图片保存到gitee图床中。</p><p>我的图床：gitee平台</p><h1 id="🌸-第三阶段：图片采用网络地址"><a href="#🌸-第三阶段：图片采用网络地址" class="headerlink" title="🌸 第三阶段：图片采用网络地址"></a>🌸 第三阶段：图片采用网络地址</h1><p>参考<a href="https://blog.csdn.net/mqdxiaoxiao/article/details/96770756">野猿新一</a>的回答，图片路径还是引用网络地址，想要在hexo博客中查看到网络地址的图片，直接在文章Front-matter下加一句：<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code>即可，如下图所示：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0f3200872db4755a847a50c37e6327a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=291&s=28703&e=png&b=f9f9f9" width="70%"/></p><p>最终发现就是加了这一句就可以显示网络地址图片了，我哭死┭┮﹏┭┮。也不需要插件了，也不需要找个地方保存图片！</p><p>还有一个小问题就是，hexo博客网络图片下方可能会出现image.png，如果所示：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4cccaa212ee4ca0ac5b2cd4f85c41d7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=809&h=170&s=55087&e=png&b=f5f5f5" width="60%" /></p><p>解决办法就是把alt这一块（下图圈的地方）去掉即可：</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43fc18d732d14116a6f8fedf7de8de30~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1331&h=174&s=61361&e=png&b=fffefe" width="60%" /></p><p>本篇结束！</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 git基本操作（上），命令总结清单在最后</title>
    <link href="/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95%E5%9C%A8%E6%9C%80%E5%90%8E/"/>
    <url>/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95%E5%9C%A8%E6%9C%80%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本篇是学习(<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">廖雪峰Git学习</a>)所写的学习总结笔记</p><h1 id="📚-git简介"><a href="#📚-git简介" class="headerlink" title="📚 git简介"></a>📚 git简介</h1><p>git 是一个版本控制工具，可以用于团队协作。git可以记录之前修改过的内容版本，方便在需要的时候回退到之前的版本，还支持团队内部进行协作更新内容。</p><p>用起来大概就是下面这样子，可以记录修改的版本，谁修改的，修改了哪些内容以及日期：</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecd727d76fe64229bfd2e1d715d2fd02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1154&h=335&e=png&b=ffffff" width:"50%" /></p><p>Git是分布式版本控制系统，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。</p><p>Git还具有极其强大的分支管理</p><h1 id="📚-git安装"><a href="#📚-git安装" class="headerlink" title="📚 git安装"></a>📚 git安装</h1><p>在这里只描述windows上安装git</p><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>因为是分布式版本控制系统，所以需要知道你是谁。注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="🌸-名词解释"><a href="#🌸-名词解释" class="headerlink" title="🌸 名词解释"></a>🌸 名词解释</h2><ul><li><p><strong>工作区</strong>：本地电脑存放文件的文件夹</p></li><li><p>**暂存区(index&#x2F;stage)**：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。版本库中包含2个部分，一部分就是暂存区,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；</p></li><li><p><strong>本地仓库</strong>：.git文件夹里还包括git自动创建的第一个分支：master，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；</p></li><li><p><strong>远程仓库</strong>：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，更新后推送到远程仓库中即可；</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1e326bcd19941c1816661245c2a40e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=795&h=427&e=png&b=fdfdfd"  width="50%"/></p></li></ul><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h2 id="🌸-本地仓库"><a href="#🌸-本地仓库" class="headerlink" title="🌸 本地仓库"></a>🌸 本地仓库</h2><p><strong>1.创建版本库：</strong><br>    什么是版本库呢？英文名<strong>repository</strong>，可以简单理解为一个文件夹，该文件夹下的文件都可以被Git管理起来。</p><p>通过<code>git init</code>命令将这个文件夹变为git可以管理的仓库。建好仓库之后，会出现一个.git文件，该文件是git跟踪管理版本库的，千万不能修改！如果没有该文件，说明是默认隐藏的，输入<code>ls -ah</code>就可以看见。</p><p><strong>2.在版本库中加文件</strong></p><p>所有的版本控制系统其实只能监控文本文件的改动，比如txt文件，网页，所有的程序代码等，git也不例外。而图片、视频这些二进制文件，虽然也能用版本控制系统管理，但是不能跟踪文件的变化，word文件也是二进制文件。</p><p>接下来就是上次文件的步骤：首先新建一个readme.txt文件，并随便写入一些内容</p><ul><li><code>git add readme.txt</code></li><li><code>git commit -m &quot;write readme txt&quot;</code></li></ul><p><code>git add readme.txt</code> 表示告诉git,将文件添加到暂存区中，无输出则成功。也可以采用<code>git add .</code>表示添加变更的文件到暂存区；</p><p><code>git commit -m &quot;本次提交的说明&quot;</code> 表示告诉git，将代码提交到仓库，后面附带对本次提交的说明。该语句执行完会返回一个文件被修改，插入了n行内容（取决于你写了多少内容）。为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件。</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70ca0240e2ca4c1193b646f0e9a1df1d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=156&e=png&b=000000" width="50%" /><p>如果文件有修改，则再执行以上2个步骤即可。</p><h1 id="📚-时光穿梭机"><a href="#📚-时光穿梭机" class="headerlink" title="📚 时光穿梭机"></a>📚 时光穿梭机</h1><h2 id="🌸-版本回退"><a href="#🌸-版本回退" class="headerlink" title="🌸 版本回退"></a>🌸 版本回退</h2><p>要回到之前的版本，我们可以使用<code>git log --pretty=oneline</code>命令显示从最近到最远的提交日志。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6d23155076742b1a7dcace8365cc55f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=84&e=png&b=000000"  width="70%"/></p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本。假如我们要回到第一版本，可以使用<code>git reset --hard 版本号</code>，版本号就是黄色的那一个字符串。</p><p>1.回退到第一版本，当前在第三版本</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7111c1745a1242c29dd0e5c9f5818686~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=362&s=52170&e=png&b=000000" width="50%" /><p>2.回退到第三版本，当前在第一版本</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94fd6cce736346f5941d55d1530a7ee8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=157&e=png&b=000000" width="50%" /><p>3.如果想回到新的版本，但是找不到版本号：可以使用git reflog来查看你的每一次命令（从近到远）</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f53986ed2b84dca806390fe52c19b8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=410&e=png&b=000000" width="50%" /><p>在上图中就可以找到最新版本的版本号，版本号可以不写全，但也不能写太少，防止版本号重复。</p><h2 id="🌸-撤销修改"><a href="#🌸-撤销修改" class="headerlink" title="🌸 撤销修改"></a>🌸 撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改，意思就是，把文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li><p>文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；利用<code>cat</code>命令可以查看文件里的内容，这里要撤销最新的修改，最后一行（已成功）</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9163aac12fa247a9b317752e7513c3e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=483&h=233&e=png&b=000000"  width="50%" /></p></li><li><p>文件已经添加到暂存区(stage)。可以使用<code>git reset HEAD 文件名+后缀</code>来把暂存区的修改撤销掉（unstage），重新放回工作区。然后<code>git checkout -- file</code>即可</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d07765f66a4466b52c60ee8848975e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=459&h=386&e=png&b=000000"  width="40%"/></p></li></ul><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程，如果提交到远程仓库就G啦。</p><h2 id="🌸-删除文件"><a href="#🌸-删除文件" class="headerlink" title="🌸 删除文件"></a>🌸 删除文件</h2><p>在工作区删除文件之后，工作区和版本库就不一样了，git status可以告知你删除了什么文件。下面分为2种情况</p><ul><li>确实要删除文件，在版本库中也有删除。则直接用命令<code>git rm &lt;file&gt;</code>删掉，并且<code>git commit</code></li><li>如果是误删。在工作区删除了文件，但是版本库中还有，则恢复文件：<code>git checkout -- &lt;file&gt;</code>。<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul><blockquote><p>【注】未添加到版本库的文件被删除掉是不能被恢复的！</p></blockquote><p>常见错误的解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">//取消http代理<br>git config --global --unset http.proxy<br>//取消https代理 <br>git config --global --unset https.proxy<br><br>git config --global http.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure><h2 id="🌸-命令总结："><a href="#🌸-命令总结：" class="headerlink" title="🌸 命令总结："></a>🌸 命令总结：</h2><ul><li><p>初始化版本库</p><ul><li><code>git init</code> 创建版本库</li></ul></li><li><p>添加文件</p><ul><li><code>git add &lt;file&gt;</code> 将文件加入版本库，<code>git add .</code>添加所有的变更文件到暂存区</li><li><code>git commit -m &quot;提交说明内容&quot;</code> 将文件提交到版本库</li></ul></li><li><p>回退文件版本</p><ul><li><code>git status</code> 查看仓库当前的状态</li><li><code>git diff 文件名+后缀</code> 查看某文件的更改内容</li><li><code>git log</code> 显示从最近到最远的提交日志，<code>git log --pretty=oneline</code>显示的内容更精简。</li><li><code>git reset --hard 版本号</code> 回退到某个版本</li><li><code>git reflog</code> 如果不知道版本号，可以查看之前使用过的命令，从而找到版本号</li></ul></li><li><p>撤销修改</p><ul><li><code>git checkout -- &lt;file&gt;</code>可以丢弃工作区的修改</li><li><code>git reset HEAD 文件名+后缀</code>来把暂存区的修改撤销掉（unstage）</li></ul></li></ul><p>上篇在此结束，您花了5分钟又学到了新的知识，如果对你还有一点帮助的话，不妨给个小赞鼓励一下吧😊，感谢观看！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 用hexo搭建个人博客（持续更新中）</title>
    <link href="/2023/08/30/%F0%9F%93%A3-%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <url>/2023/08/30/%F0%9F%93%A3-%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本文记录自己搭建个人博客的历程，欢迎收看~</p><h1 id="📚-搭建基础的个人博客"><a href="#📚-搭建基础的个人博客" class="headerlink" title="📚 搭建基础的个人博客"></a>📚 搭建基础的个人博客</h1><blockquote><p><strong>前提：需安装了git 和 nodejs</strong></p></blockquote><ol><li>安装hexo。先新建一个文件夹，在该文件夹下打开git bash，然后运行<code>npm install -g hexo-cli</code></li></ol>  <p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cf3229ac3df4442b4be56bd18e0aea4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=708&h=353&s=35036&e=png&b=f7f7f7" width="50%"/></p>  <ol start="2"><li>初始化hexo，命令为：<code>hexo init</code> ，出现下图结果就表示初始化成功！</li></ol>  <p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26b0a3e34474736ad89da964b780fce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=101&s=10725&e=png&b=000000" width="70%"/></p>  <p>  新建完成后，在路径下会产生一些文件和文件夹：</p>  <p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b966396263f42a8b814307a95898acc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=319&s=29387&e=png&b=fffefe" width="50%" /></p>    <ul><li><code>_config.yml</code>：俗称站点配置文件，很多与博客网站的格式、内容相关的设置都需要在里面改。</li><li><code>node_modules</code>:存储Hexo插件的文件，可以实现各种扩展功能。一般不需要管。</li><li><code>package.json</code>：相关描述的，比如名字、版本。</li><li><code>scaffolds</code>：模板文件夹，里面的<code>post.md</code>文件可以设置每一篇博客的模板。具体用起来就知道能干嘛了。</li><li><code>source</code>：非常重要。所有的个人文件都在里面！</li><li><code>themes</code>：主题文件夹，可以从<a href="https://link.juejin.cn/?target=https://hexo.io/themes/" title="https://hexo.io/themes/">Hexo主题官网</a>或者网上大神的Github主页下载各种各样美观的主题，让自己的网站变得逼格高端的关键！</li></ul><ol start="3"><li>启动服务器</li></ol><p>命令为：<code>hexo server</code>，或者简写：<code>hexo s</code>，然后打开浏览器，在地址栏输入：localhost:4000回车就可以得到如下结果：(ctrl+c可关闭服务)</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f108fb71f11e48a393a221ea96c47829~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1844&h=1084&s=647678&e=png&b=f4f3f3" alt="image.png" width="50%" /></p><p>至此，您的Hexo博客已经搭建在本地。</p><p>4.上传到github</p><p>在github创建仓库，仓库名为：&lt;Github账号名称&gt;.github.io（必须是这个，否则后续打不开）。安装<code>hexo-deployer-git</code>插件。在命令行（即Git Bash）运行以下命令即可（也可以走淘宝镜像，淘宝镜像就是换成cnpm）：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>添加SSH key，如果已添加可以不用管。如果未添加，可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">添加SSH key</a>，我这里已经添加，接着下一步；</p><ol start="5"><li>修改<code>_config.yml</code>（在站点目录下）。文件末尾修改为：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Deployment</span><br><span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:LuoyNothing/LuoyNothing.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure>6.生成页面并上传到github</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 生成页面：<br>hexo g<br><span class="hljs-regexp">//</span> 上传到github: <br>hexo d<br></code></pre></td></tr></table></figure><p>执行完上面两个命令，并出现下图结果即表示上传成功。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d714419ddf40fc9c44f7d6ac4a8eb8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=303&s=44296&e=png&b=000000" width="50%" /></p><p>至此，您的Hexo博客已经搭建在GitHub上，访问域名为：<a href="https://luoynothing.github.io/">https://luoynothing.github.io/</a></p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe722b935d254d849c4a5f8a24f29300~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1086&s=911964&e=png&b=f5f4f4" width="50%" /></p><p>访问博客，开始的页面是初始化页面，没有做美化和增加内容。</p><h2 id="🌸-域名绑定"><a href="#🌸-域名绑定" class="headerlink" title="🌸 域名绑定"></a>🌸 域名绑定</h2><p>还未绑定</p><h1 id="📚-文档学习"><a href="#📚-文档学习" class="headerlink" title="📚 文档学习"></a>📚 文档学习</h1><p>官网文档：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><h2 id="🌸-修改主题"><a href="#🌸-修改主题" class="headerlink" title="🌸 修改主题"></a>🌸 修改主题</h2><p>我的博客修改的主题是fluid（<a href="https://hexo.fluid-dev.com/docs/start/"> Hexo Fluid 用户手册</a>）,github(<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid Hexo 主题</a>)，以下是详细步骤：</p><ol><li>下载主题</li></ol><p><strong>方式一</strong>：推荐通过 npm 直接安装，进入博客目录执行命令：<code>npm install --save hexo-theme-fluid</code></p><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的_config.yml内容复制过去。</p><p><strong>方式二</strong>：下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a>解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p>我采用的是方式二。</p><ol start="2"><li>然后采用hexo三连，就可以在本地查看到主题修改<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 启动本地服务器，用于预览主题。<br>hexo s<br></code></pre></td></tr></table></figure>下图表示换主题成功！然后可以用<code>localhost:4000</code>来访问个人博客</li></ol><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5643b5e6987401997f520c8cad74c84~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=631&s=57034&e=png&b=000000" width="50%" /></p><ol start="3"><li>部署到github上：</li></ol><p>hexo三连：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 部署到远程仓库里<br>hexo d<br></code></pre></td></tr></table></figure><p>然后可以用<a href="https://luoynothing.github.io/">https://luoynothing.github.io/</a> 来访问个人博客了。</p><h2 id="🌸-发布文章"><a href="#🌸-发布文章" class="headerlink" title="🌸 发布文章"></a>🌸 发布文章</h2><p>1.新建md文件。在网站根目录下git bash，输入<code>hexo new &lt;title&gt;</code>，执行该命令，Hexo会在<code>/source/_posts</code>目录下创建一篇新的文章。</p><p>2.上传到github，就是hexo三连操作。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 部署到远程仓库里<br>hexo d<br></code></pre></td></tr></table></figure><h1 id="📚-博客更新说明"><a href="#📚-博客更新说明" class="headerlink" title="📚 博客更新说明"></a>📚 博客更新说明</h1><p><strong>2023-8-30</strong></p><p>1.成功搭建博客</p><p>2.博客文章：</p><p>​1.封面字段：标题、发布时间、关键字</p><p>​摘要：去掉摘要</p><p>​2.封面进去：发布时间、更新时间、字数、阅读时长​</p><p>3.标签和分类：</p><p>分类1：前端</p><p>​子类：html css等</p><p>分类2：持续更新</p><p>标签：相当于关键字吧，里面的某个知识点</p><p>4.博客中的图片不显示问题</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
