<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>📣-面试八股文-html-css-js（持续更新中）</title>
    <link href="/2023/09/03/%F0%9F%93%A3-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <url>/2023/09/03/%F0%9F%93%A3-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="📚-html-和-h5"><a href="#📚-html-和-h5" class="headerlink" title="📚 html 和 h5"></a>📚 html 和 h5</h1><h2 id="1-h5新增了哪些新特性√"><a href="#1-h5新增了哪些新特性√" class="headerlink" title="1. h5新增了哪些新特性√"></a>1. h5新增了哪些新特性√</h2><ol><li>语义化标签，例如header，footer，section，article等 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；还新增了一些状态标签、列表标签、文本标签。</li><li>新增媒体元素，audio、video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API</li><li>新增的表单控件：calendar、date、time、email、url、search </li><li>用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的<strong>canvas</strong>元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。</li><li>新增本地存储方式：sessionStorage、localStorage sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。<br> localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。</li><li>新的技术：webworker、websocket webworker：用于多线程编程<br>websocket：客户端与服务端双向数据通信协议</li></ol><h2 id="2-localstorage、sessionstorage可以跨域吗，cookie有哪些属性√"><a href="#2-localstorage、sessionstorage可以跨域吗，cookie有哪些属性√" class="headerlink" title="2.localstorage、sessionstorage可以跨域吗，cookie有哪些属性√"></a>2.localstorage、sessionstorage可以跨域吗，cookie有哪些属性√</h2><p>本地存储和会话存储都存储键值对。</p><p><strong>本地存储和会话存储的主要区别在于</strong>，<strong>在关闭浏览器后</strong>，<strong>存储在会话存储中的键值对会丢失</strong>。下面是基本的使用（两者API一样，这里列举的是会话存储）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存键值对、获取键值对</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>, <span class="hljs-string">&#x27;uiu&#x27;</span>);<br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>);<br><br><span class="hljs-comment">// 保存数组，获取数据，如果不用JSON.parse()，则得到的是字符串</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">ProgrammingLanguage</span> = [<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;GO+&#x27;</span>]<br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;favoriteProgrammingLanguage&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title class_">ProgrammingLanguage</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;favoriteProgrammingLanguage&#x27;</span>)));<br><br><span class="hljs-comment">// 清除本地存储或会话存储</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>()<br><br><span class="hljs-comment">// 移除某个键值对</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-本地存储和会话存储的相同点、不同点"><a href="#1-本地存储和会话存储的相同点、不同点" class="headerlink" title="1.本地存储和会话存储的相同点、不同点"></a>1.本地存储和会话存储的相同点、不同点</h3><p><strong>相同点：</strong></p><p>1、存储大小均为5M左右<br>2、<font color=red><strong>都有同源策略限制</strong></font><br>3、仅在客户端中保存，不参与和服务器的通信</p><p><strong>不同点：</strong></p><p>1、<code>生命周期</code> —— 数据可以存储多少时间</p><ul><li>localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。</li><li>sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。</li></ul><p>2、<code>作用域</code> —— 谁拥有数据的访问权</p><ul><li>localStorage: 在同一个浏览器内，<code>同源文档</code>之间共享 localStorage 数据，可以互相读取、覆盖。</li><li>sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。</li></ul><p>为了更好的理解<code>sessionStorage</code>,我们来看个例子：</p><p>例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的<code>iframe</code>元素的话，这两个<code>iframe</code>的 sessionStorage 是可以互通的。</p><h3 id="2-cookie"><a href="#2-cookie" class="headerlink" title="2.cookie"></a>2.cookie</h3><p>Cookie是小甜饼的意思，主要有以下特点：</p><p>1、顾名思义，Cookie 确实非常小，它的大小限制为4KB左右</p><p>2、主要用途是保存登录信息和标记用户(比如购物车)等，不过随着localStorage的出现，现在购物车的工作Cookie承担的较少了</p><p>3、一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</p><p>4、每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p><p>5、原生API不如storage友好，需要自己封装函数</p><p><strong>用法(API)</strong></p><p>服务端向客户端发送的cookie(HTTP头,不带参数)：<br><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</code> (name可选)</p><p>服务端向客户端发送的cookie(HTTP头，带参数)：<br><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2)</code></p><p>客户端设置cookie：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&quot;&lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>可选参数：</strong></p><p>下图是Chrome浏览器中的Cookie截图，属性分别有<strong>Name</strong>、<strong>Value</strong>、<strong>Domain</strong>、<strong>Path</strong>、<strong>Expires&#x2F;Max-age</strong>、<strong>Size</strong>、<strong>HttpOnly</strong>、<strong>Secure</strong>、<strong>SameSite</strong>和<strong>Priority</strong>。</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ffd6fde7194438bf2f2c92a8480f5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1187&h=92&s=14975&e=png&b=f8f8f8"  width="80%"/></p><p><code>Domain=&lt;domain-value&gt;</code>：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Domain设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(“.”)开始。</p><p><code>Path=&lt;path-value&gt;</code>：指定一个URL，和<strong>Domain</strong>类似，也对子路径生效，例如指定path&#x3D;&#x2F;docs，则 ”&#x2F;docs” 、 ”&#x2F;docs&#x2F;Web&#x2F;“ 、”&#x2F;docs&#x2F;Web&#x2F;Http”均满足匹配条件。如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 &#x2F;b&#x2F;,而Cookie2的Path为 &#x2F;b&#x2F;c&#x2F;,则在a.com&#x2F;b页面时只可以访问Cookie1，在a.com&#x2F;b&#x2F;c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“&#x2F;”结尾。</p><p><code>Expires/Max-age</code>：<br>    <code>Expires</code>和<code>Max-age</code>均为Cookie的有效期，<code>Expires</code>是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不设置则默认页面关闭时删除该Cookie。<br>    <code>Max-age</code>也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0，则立刻失效，设置为负数，则在页面关闭时失效。Max-age默认为 -1。</p><p><code>HttpOnly</code>：<strong>HttpOnly</strong>值为 <em>true</em> 或 <em>false</em>,若设置为<em>true</em>，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。</p><p><code>Secure</code>：<strong>Secure</strong>为Cookie的安全属性，若设置为<em>true</em>，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。</p><p><code>SameSite</code>SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：</p><p>​Strict：Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie</p><p>​Lax：Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p><p>​None：网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p><p><strong>关闭SameSite的方法</strong></p><ul><li>操作方法谷歌浏览器地址栏输入：chrome:&#x2F;&#x2F;flags&#x2F;</li><li>找到：SameSite by default cookies、Cookies without SameSite must be secure设置上面这两项设置成 Disable</li></ul><p><code>Priority</code><br>优先级，chrome的提案，定义了三种优先级，Low&#x2F;Medium&#x2F;High，当cookie数量超出时，低优先级的cookie会被优先清除。在360极速浏览器和FireFox中，不存在Priority属性，不清楚在此类浏览器中设置该属性后是否生效。</p><p>示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Set-Cookie: <span class="hljs-attribute">sessionid</span>=aes7a8; HttpOnly; <span class="hljs-attribute">Path</span>=/<br><br>document.cookie = <span class="hljs-string">&quot;KMKNKK=1234;Sercure&quot;</span><br></code></pre></td></tr></table></figure><p>可选前缀：<br><code>__Secure-</code>：以<code>__Secure-</code>为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）</p><p><code>__Host-</code>：以<code>__Host-</code>为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）。必须不能设置domian属性（这样可以防止二级域名获取一级域名的cookie），path属性的值必须为”&#x2F;“。</p><p>前缀使用示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">复制代码Set-Cookie: <span class="hljs-attribute">__Secure-ID</span>=123; Secure; <span class="hljs-attribute">Domain</span>=example.com<br>Set-Cookie: <span class="hljs-attribute">__Host-ID</span>=123; Secure; <span class="hljs-attribute">Path</span>=/<br><br>document.cookie = <span class="hljs-string">&quot;__Secure-KMKNKK=1234;Sercure&quot;</span><br>document.cookie = <span class="hljs-string">&quot;__Host-KMKNKK=1234;Sercure;path=/&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-Session"><a href="#3-Session" class="headerlink" title="3.Session"></a>3.Session</h3><p><strong>基本概念</strong></p><p>Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。</p><p>在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。</p><p>大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器</p><p><strong>与Cookie的关系与区别：</strong></p><p>1、<code>Session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，<code>Cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p><p>2、<code>Cookie</code>的<code>安全性</code>一般，他人可通过分析存放在本地的<code>Cookie</code>并进行<code>Cookie</code>欺骗。在安全性第一的前提下，选择<code>Session</code>更优。重要交互信息比如权限等就要放在<code>Session</code>中，一般的信息记录放<code>Cookie</code>就好了。 </p><p>3、单个<code>Cookie</code>保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个<code>Cookie</code>。 </p><p>4、当访问增多时，<code>Session</code>会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用<code>Cookie</code>。 </p><p>5、<code>Session</code>的运行依赖<code>Session ID</code>，而<code>Session ID</code>是存在 Cookie 中的。也就是说，如果浏览器禁用了<code>Cookie</code>,<code>Session</code>也会失效（但是可以通过其它方式实现，比如在<code>url</code>中传递<code>Session ID</code>,即sid&#x3D;xxxx）。</p><h1 id="📚-css-c3"><a href="#📚-css-c3" class="headerlink" title="📚 css+c3"></a>📚 css+c3</h1><h1 id="📚-js"><a href="#📚-js" class="headerlink" title="📚 js"></a>📚 js</h1><h2 id="1-js取整的方法，parseInt第二个参数是什么-（√）"><a href="#1-js取整的方法，parseInt第二个参数是什么-（√）" class="headerlink" title="1.js取整的方法，parseInt第二个参数是什么?（√）"></a>1.js取整的方法，parseInt第二个参数是什么?（√）</h2><p>1、丢弃小数部分，保留整数部分：</p><pre><code class="hljs">parseInt(d);Math.trunc(d); </code></pre><p>两者的区别：parseInt 常常接收一个字符串作为参数，而 Math.trunc 则可以接收一个数字参数，所以如果要对数字取整，还是建议使用 Math.trunc。使用 parseInt 的时候，如果你传入的不是字符串，比如传入一个数字，parseInt 会先调用数字的 toString() 方法。</p><blockquote><p>【知识点】parseInt()方法：字符串转数字</p><p>parseInt接收两个参数：</p><ul><li>第一个参数<code>string</code>：要被解析的字符串，如果不是字符串会被转换，忽视空格符</li><li>第二个参数<code>radix</code>：要解析的数字的基数。该值介于2~36之间。默认值为10，表示十进制。<strong>这个参数表示将前面的字符从radix进制转化为十进制</strong><ul><li>1.在没有指定基数，或者基数为0的情况下，parseInt()会根据<code>string</code>参数来判断数字的基数。<ul><li>如果字符串<code>string</code>以”0x”或者”0X”开头, 则基数是16 (16进制).</li><li>如果字符串<code>string</code>以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。</li><li>如果字符串<code>string</code>以其它任何值开头，则基数是10 (十进制)。</li></ul></li><li>2.如果<code>radix</code>在<code>2 ~ 36之外</code>会返回NaN。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 例1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>));  <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 例2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 例3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>));  <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 例4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 例5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">123</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 结果为38</span><br></code></pre></td></tr></table></figure><p><strong>解析如下</strong>：</p><ul><li><strong>例1</strong>： <code>parseInt</code>里面有两个参数，第二个参数是8，表示要将<code>八进制</code>的3转换为十进制的结果，八进制中有3，转化为十进制还是3，所以返回结果为3</li><li><strong>例2</strong>： <code>parseInt</code>里面有两个参数，第二个参数是2，表示要将<code>二进制</code>的3转化为十进制，额…，不好意思，二进制中并没有3，所以返回<code>NaN</code></li><li><strong>例3</strong>： <code>parseInt</code>里面有两个参数，第二个参数是0，根据规则1，默认就是十进制，直接返回3</li><li><strong>例4</strong>： <code>parseInt</code>里面有两个参数，第二个参数是1，根据规则2，1在<code>2 ~ 36之外</code>，直接返回<code>NaN</code>。</li><li><strong>例5</strong>： <code>parseInt</code>里面有两个参数，第二个参数是5，表示要将<code>五进制</code>的123转化为十进制，结果为38 &#x3D;&gt; (<code>1*5^2 + 2*5^1 + 3*5^0 = 38</code>)</li></ul></blockquote><p>2、向上取整，有小数就整数部分加1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 11.1取整后得到12；</span><br><span class="hljs-comment">// -11.1取整后得到-11。</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(d);<br></code></pre></td></tr></table></figure><p>3、向下取整，正数舍弃小数位，负数整数位减一：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">11.1取整后得到11；<br><br><span class="hljs-string">-11</span>.1取整后得到<span class="hljs-string">-12</span>。<br><br>Math.floor(d);<br></code></pre></td></tr></table></figure><p>4、四舍五入：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Math.round(d)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="2-数组转字符串、字符串转数组（√）"><a href="#2-数组转字符串、字符串转数组（√）" class="headerlink" title="2.数组转字符串、字符串转数组（√）"></a>2.数组转字符串、字符串转数组（√）</h2><h3 id="一、数组转字符串（3种方法）"><a href="#一、数组转字符串（3种方法）" class="headerlink" title="一、数组转字符串（3种方法）"></a>一、数组转字符串（3种方法）</h3><p>同样是数组转字符串，toString()，toLocaleString()，join()，join(’,’)的区别是什么？</p><p>JavaScript 允许数组与字符串之间相互转换。其中 Array 方法对象定义了 3 个方法，可以把数组转换为字符串，如表所示。</p><table><thead><tr><th>数组方法</th><th>说明</th></tr></thead><tbody><tr><td>toString()</td><td>将数组转换成一个字符串</td></tr><tr><td>toLocaleString()</td><td>把数组转换成本地约定的字符串</td></tr><tr><td>join()</td><td>将数组元素连接起来以构建一个字符串</td></tr></tbody></table><p><strong>1. join()方法用于把数组中的所有元素放入一个字符串</strong></p><p>元素是通过指定的分隔符进行分隔的</p><table><thead><tr><th>join()指定的分隔符</th><th>说明</th></tr></thead><tbody><tr><td>join()</td><td>可理解为直接变成字符串，默认逗号分隔</td></tr><tr><td>join(’ ‘）</td><td>空连接</td></tr><tr><td>join(’ ，’)或者 join(’ - ‘)或者 join(’ 。’)</td><td>中间这个逗号是手动添加的，也可以改成别的比如、。! -等等都可以</td></tr></tbody></table><p><strong>2. toString()方法可把一个逻辑值转换为字符串，并返回结果</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> str = arr.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//把数组转换为字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> str); <span class="hljs-comment">//返回字符串string，说明是字符串类型</span><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 10,true,30,40</span><br><span class="hljs-comment">// string</span><br></code></pre></td></tr></table></figure><p>toString()方法不可以指定分隔符，但是我们可以通过replace()方法指定替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/,/gi</span>, <span class="hljs-string">&quot;-&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// 10-true-30-40</span><br></code></pre></td></tr></table></figure><p>**3. toLocaleString()**：把数组转换成本地约定的字符串</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> str = arr.toLocaleString(); <span class="hljs-comment">//把数组转换为字符串</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str); <span class="hljs-comment">// 10,true,30,40</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> str); <span class="hljs-comment">//返回字符串string，说明是字符串类型</span><br><br></code></pre></td></tr></table></figure><h3 id="二、字符串转数组（2种方法）"><a href="#二、字符串转数组（2种方法）" class="headerlink" title="二、字符串转数组（2种方法）"></a>二、字符串转数组（2种方法）</h3><table><thead><tr><th>字符串方法</th><th>说明</th></tr></thead><tbody><tr><td>split() 方法</td><td>将字符串转换成一个数组</td></tr><tr><td>扩展运算符（…）</td><td>es6里面的扩展运算符</td></tr></tbody></table><p><strong>1.split() 方法用于把一个字符串分割成字符串数组</strong></p><p>同样是用于把一个字符串分割成字符串数组，split(’,’)，split()，split(‘’）的区别是什么？</p><table><thead><tr><th>split()方法</th><th>说明</th></tr></thead><tbody><tr><td>split(“,”)</td><td>以逗号分隔的转换为数组</td></tr><tr><td>split(‘’）空字符串</td><td>每个字符之间都会被分割</td></tr><tr><td>split()</td><td>可理解为直接变成数组</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;aa, bb, cc, dd&quot;</span>;<br><span class="hljs-keyword">var</span> str1 = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">var</span> str2 = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">var</span> str3 = str.<span class="hljs-title function_">split</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1); <span class="hljs-comment">// [ &#x27;aa&#x27;, &#x27; bb&#x27;, &#x27; cc&#x27;, &#x27; dd&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;b&#x27;, &#x27;b&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;c&#x27;, &#x27;c&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;d&#x27;, &#x27;d&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str3); <span class="hljs-comment">// [ &#x27;aa, bb, cc, dd&#x27; ]</span><br></code></pre></td></tr></table></figure><p><strong>2.扩展运算符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;aa,bb,cc,dd&quot;</span>;<br><span class="hljs-keyword">var</span> str1 = [...str];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27;b&#x27;,&#x27;b&#x27;, &#x27;,&#x27;, &#x27;c&#x27;, &#x27;c&#x27;,&#x27;,&#x27;, &#x27;d&#x27;, &#x27;d&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="3-数组常用方法（√）"><a href="#3-数组常用方法（√）" class="headerlink" title="3.数组常用方法（√）"></a>3.数组常用方法（√）</h2><h3 id="一、改变原数组的方法7个"><a href="#一、改变原数组的方法7个" class="headerlink" title="一、改变原数组的方法7个"></a>一、改变原数组的方法7个</h3><p>总结：push、pop</p><p><strong>1.push()末尾添加数据</strong></p><p><strong>语法:</strong> <strong>数组名.push(</strong> <strong>数据)</strong></p><p><strong>作用:</strong> 就是往数组末尾添加数据</p><p><strong>返回值:</strong> 就是这个数组的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br>res = arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[10,20,30,40,20]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p><strong>2.pop() 末尾处删除数据</strong></p><p><strong>语法:</strong> <strong>数组名.pop()</strong></p><p><strong>作用:</strong> 就是从数组的末尾删除一个数据</p><p><strong>返回值:</strong> 就是你删除的那个数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>] <br>res =arr.<span class="hljs-title function_">pop</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[10,20,30]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//40</span><br></code></pre></td></tr></table></figure><p><strong>3.unshift() 头部添加数据</strong></p><p><strong>语法:</strong> <strong>数组名.unshift(</strong> <strong>数据)</strong></p><p><strong>作用:</strong>  就是在数组的头部添加数据</p><p><strong>返回值:</strong> 就是数组的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br> res=arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">99</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[99,10,20,30,40]</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p><strong>4.shift()头部删除数据</strong></p><p><strong>语法:</strong> <strong>数组名.shift()</strong></p><p><strong>作用:</strong>  头部删除一个数据</p><p><strong>返回值:</strong>  就是删除掉的那个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //shift">//shift复制代码 var arr = [10, 20, 30, 40]<br> res=arr.shift()<br> console.log(arr);[20,30,40]<br> console.log(res);10<br></code></pre></td></tr></table></figure><p><strong>5.reverse() 翻转数组</strong></p><p><strong>语法:</strong> <strong>数组名.reverse()</strong></p><p><strong>作用:</strong> 就是用来翻转数组的</p><p><strong>返回值:</strong> 就是翻转好的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //reverse">//reverse复制代码var arr = [10, 20, 30, 40]<br>res=arr.reverse()<br>console.log(arr);//[40,30,20,10]<br>console.log(res);//[40,30,20,10]<br></code></pre></td></tr></table></figure><p><strong>6.sort() 排序</strong></p><p><strong>语法一</strong>: 数组名.sort()   会排序，会按照位排序</p><p><strong>语法二</strong>: 数组名.sort(function (a,b) {return a-b})  会正序排列</p><p><strong>语法三</strong>: 数组名.sort(function (a,b) {return b-a})  会倒序排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">63</span>, <span class="hljs-number">48</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">75</span>, <span class="hljs-number">69</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>]<br>arr.<span class="hljs-title function_">sort</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 11, 2, 23, 4, 48, 5, 63, 69, 75]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span>(a-b)&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [2,  4,  5, 11, 23, 48, 63, 69, 75     ]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span>(b-a)&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [75, 69, 63, 48, 23, 11,  5,  4,  2]</span><br></code></pre></td></tr></table></figure><p><strong>7.splice()  截取数组</strong></p><p><strong>语法一</strong>: 数组名.splice(开始索引,多少个)</p><p>​作用: 就是用来截取数组的</p><p>​返回值: 是一个新数组 里面就是你截取出来的数据</p><p><strong>语法二</strong>: 数组名.splice(开始索引,多少个,你要插入的数据)</p><p>​作用: 删除并插入数据</p><p>​注意: 从你的开始索引起</p><p>​返回值: 是一个新数组 里面就是你截取出来的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //splice()">var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,2)<br>console.log(arr); // [ 2, 5, 4, 75 ]<br>console.log(res); // [ 63, 48 ]<br>//******************************<br>//splice() 语法二<br>var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,1,99999,88888)<br>console.log(arr); // [2, 99999, 88888, 48, 5, 4, 75]<br>console.log(res); // [ 63 ]<br></code></pre></td></tr></table></figure><h3 id="二、不改变原数组的方法5个"><a href="#二、不改变原数组的方法5个" class="headerlink" title="二、不改变原数组的方法5个"></a>二、不改变原数组的方法5个</h3><p><strong>1.concat() 合并数组</strong></p><p><strong>语法:</strong> <strong>数组名.concat(</strong> <strong>数据)</strong></p><p><strong>作用:</strong>  合并数组的</p><p><strong>返回值:</strong>  一个新的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>res = arr.<span class="hljs-title function_">concat</span>(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;小敏&quot;</span>,<span class="hljs-number">50</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [10, 20, 10, 30, 40, 50, 60]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// [10, 20, 10, 30, 40, 50, 60, 20,&quot;小敏&quot;,50]</span><br></code></pre></td></tr></table></figure><p><strong>2.join()  数组转字符串</strong></p><p><strong>语法:</strong> **数组名.join(‘**<strong>连接符’)</strong></p><p><strong>作用:</strong> 就是把一个数组转成字符串</p><p><strong>返回值:</strong>  就是转好的一个字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>res = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;+&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// var arr = [10, 20, 10, 30, 40, 50, 60]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 10+20+10+30+40+50+60</span><br></code></pre></td></tr></table></figure><p><strong>3.slice() 截取数组的一部分数据</strong></p><p><strong>语法:</strong> <strong>数组名.slice(</strong> <strong>开始索引,</strong> <strong>结束索引)</strong></p><p><strong>作用:</strong> 就是截取数组中的一部分数据</p><p><strong>返回值:</strong> 就是截取出来的数据 放到一个新的数组中</p><p><strong>注意:</strong> 包前不好后 包含开始索引不包含结束索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //slice">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.slice(1,4)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // [20, 10, 30]<br></code></pre></td></tr></table></figure><p><strong>4.indexOf() 从左检查数组中有没有这个数值</strong></p><p><strong>语法一:</strong> <strong>数组名.indexOf(要查询的数据)</strong></p><p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p><p>如果有就返回该数据<strong>第一次</strong>出现的索引</p><p>如果没有返回 -1</p><p><strong>语法二:</strong> <strong>数组名.indexOf(要查询的数据, 开始索引)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //indexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // 0<br>//*************************************<br>//indexOf  语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10,1)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // 2<br></code></pre></td></tr></table></figure><p><strong>5.lastIndexOf() 从右检查数组中有没有这个数值</strong></p><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p><p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p><p>如果有就返回该数据<strong>第一次</strong>出现的索引</p><p>如果没有返回 -1</p><p><strong>语法二:</strong> <strong>数组名.lastIndexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //lastIndexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50)<br>console.log(arr) <br>console.log(res);<br>//*************************************<br>//lastIndexOf 语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50,4)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure><h3 id="三、ES6新增的数组方法7个（都不改变原数组）"><a href="#三、ES6新增的数组方法7个（都不改变原数组）" class="headerlink" title="三、ES6新增的数组方法7个（都不改变原数组）"></a>三、ES6新增的数组方法7个（都不改变原数组）</h3><p><strong>1. forEach()  用来循环遍历数组</strong></p><p><strong>语法</strong>: 数组名.forEach(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来循环遍历数组的 代替了我们的for</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //forEach">var arr = [1, 2, 3, 4, 5]<br>var res = arr.forEach(function (item, index, arr) &#123;<br>    console.log(item, &quot;------&quot;, index, &quot;-------&quot;, arr);<br>&#125;)<br>// 输出：<br>// 1 ------ 0 ------- [ 1, 2, 3, 4, 5 ]<br>// 2 ------ 1 ------- [ 1, 2, 3, 4, 5 ]<br>// 3 ------ 2 ------- [ 1, 2, 3, 4, 5 ]<br>// 4 ------ 3 ------- [ 1, 2, 3, 4, 5 ]<br>// 5 ------ 4 ------- [ 1, 2, 3, 4, 5 ]<br></code></pre></td></tr></table></figure><p><strong>2.map()  映射数组</strong></p><p><strong>语法:</strong> 数组名.map(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来数组映射</p><p><strong>返回值:</strong> 必然是一个映射完毕的数组；这个数组和原数组长度一样，不改变原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">return</span> item*<span class="hljs-number">1000</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><span class="hljs-comment">// 返回值：</span><br><span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-comment">// [ 1000, 2000, 3000, 4000, 5000 ]</span><br></code></pre></td></tr></table></figure><p><strong>3.filter()  过滤数组</strong></p><p><strong>语法</strong>: 数组名.filter(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 用来过滤数组的</p><p><strong>返回值</strong>: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs //filter">var arr = [1, 2, 3, 4, 5]<br>var res = arr.filter(function (item) &#123;<br>    return item &gt; 2<br>&#125;)<br>console.log(arr);<br>console.log(res);<br>// 返回值：<br>// [ 1, 2, 3, 4, 5 ]<br>// [ 3, 4, 5 ]<br></code></pre></td></tr></table></figure><p><strong>4.every()  判断数组是不是满足所有条件</strong></p><p><strong>语法</strong>: 数组名.every(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 主要是用来判断数组中是不是 每一个 都满足条件。只有所有的都满足条件返回的是true，只要有一个不满足返回的就是false</p><p><strong>返回值</strong>: 是一个布尔值 </p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //every">//every复制代码var arr = [1, 2, 3, 4, 5]<br>var res = arr.every(function (item) &#123;<br>    return item &gt; 0<br>&#125;)<br>console.log(res);//打印结果  true<br></code></pre></td></tr></table></figure><p><strong>5.some() 数组中有没有满足条件的</strong></p><p><strong>语法</strong>: 数组名.some(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 主要是用来判断数组中是不是 每一个 都满足条件。只有有一个满足条件返回的是true，只要都不满足返回的就是false</p><p><strong>返回值</strong>: 是一个布尔值</p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //some">var arr = [1, 2, 3, 4, 5]<br>var res = arr.some(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res); //true<br></code></pre></td></tr></table></figure><p><strong>6.find() 用来获取数组中满足条件的第一个数据</strong></p><p><strong>语法</strong>: 数组名.find(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 用来获取数组中满足条件的数据</p><p><strong>返回值</strong>: 如果有 就是满足条件的第一个数据；如果没有就是undefined</p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //find">var arr = [1, 2, 3, 4, 5]<br>var res = arr.find(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res) //4<br></code></pre></td></tr></table></figure><p><strong>7.reduce() 累加后的效果</strong></p><p><strong>语法</strong>: 数组名.reduce(function (prev,item,index,arr) {},初始值)</p><ul><li>prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果</li><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来累加的</p><p><strong>返回值</strong>: 就是累加后的结果</p><p><strong>注意</strong>: 以return的形式书写返回条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prev, item</span>) &#123;<br>    <span class="hljs-keyword">return</span> prev *= item<br>&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">//120</span><br></code></pre></td></tr></table></figure><h2 id="4-数组深拷贝方法"><a href="#4-数组深拷贝方法" class="headerlink" title="4.数组深拷贝方法"></a>4.数组深拷贝方法</h2><p>参考：<a href="https://juejin.cn/post/7134970746580762637?searchId=20230903212139B6B7DB5B5E108D8F55BD">前端面试 第三篇 js之路 深拷贝与浅拷贝 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/6994453856063062053#heading-6">JavaScript深拷贝和浅拷贝看这篇就够了 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/7020348927643746312">前端数组、对象的浅拷贝和深拷贝 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/6844904197595332622">浅拷贝与深拷贝 - 掘金 (juejin.cn)</a></p><p><strong>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。</strong></p><p><strong>浅拷贝</strong>: 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。（只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃）；</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715c839f767d41dc98669788c9705772~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=277&s=82226&e=png&b=fdf9f8" alt="image.png"  width="50%"/></p><p><strong>深拷贝</strong>: 深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象（新旧对象不共享同一块内存），且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样每个可以避免指针悬挂）</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5058d13e4a548a3b40e0ae074ffbb92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=373&s=84518&e=png&b=fefdfd" alt="image.png"  width="50%"/></p><p>【默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝。】</p><p><font color=red><strong>赋值和深&#x2F;浅拷贝的区别</strong></font>，比较的前提都是<strong>针对引用类型</strong>：</p><ul><li>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象的在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li><li>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li></ul><table>    <tr>        <th  colspan=4 align="center">对原始数据的影响</th>    </tr>    <tr>        <th width=100px bgcolor=skyblue></th>        <th bgcolor=skyblue>和原数据是否指向同一对象</th>        <th bgcolor=skyblue>第一层数据为基本数据类型</th>        <th bgcolor=skyblue>原数据包含子对象（引用数据类型）</th>    </tr>    <tr>        <td>赋值</td>        <td>是</td>        <td>赋值后的数据改变，会使原数据一同改变</td>        <td>赋值后的数据改变，会使原数据一同改变</td>    </tr>    <tr>        <td>浅拷贝</td>        <td>否</td>        <td>浅拷贝后的数据改变，不会使原数据一同改变</td>        <td>浅拷贝后的数据改变，会使原数据一同改变</td>    </tr></table><p>举例：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 对象赋值</span><br>let obj1 = &#123;<br> <span class="hljs-keyword">name</span>: <span class="hljs-string">&quot;Chen&quot;</span>,<br> age: <span class="hljs-number">18</span>,<br> hobby: [<span class="hljs-string">&quot;see a film&quot;</span>, <span class="hljs-string">&quot;write the code&quot;</span>, <span class="hljs-string">&quot;play basketball&quot;</span>, <span class="hljs-string">&quot;tourism&quot;</span>],<br>&#125;;<br>let obj2 = obj1;<br>obj2.<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;Forever&quot;</span>;<br>obj2.hobby[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;swim&quot;</span>;<br>obj2.hobby[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;alpinism&quot;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;obj1===&gt;&quot;</span>, obj1);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;obj2===&gt;&quot;</span>, obj2);<br><span class="hljs-comment">// 输出为：</span><br>obj1===&gt; &#123;<br>  <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  hobby: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br>obj2===&gt; &#123;<br>  <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  hobby: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br><span class="hljs-comment">// 结论：对象中基本属性和引用属性都发生改变</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 浅拷贝</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Chen&quot;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br> <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&quot;see a film&quot;</span>, <span class="hljs-string">&quot;write the code&quot;</span>, <span class="hljs-string">&quot;play basketball&quot;</span>, <span class="hljs-string">&quot;tourism&quot;</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj3 = &#123; ...obj1 &#125;;<br>obj3.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Forever&quot;</span>;<br>obj3.<span class="hljs-property">hobby</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;swim&quot;</span>;<br>obj3.<span class="hljs-property">hobby</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;alpinism&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj1===&gt;&quot;</span>, obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj3===&gt;&quot;</span>, obj3);<br><span class="hljs-comment">// 输出为：</span><br>obj1===&gt; &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Chen&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">hobby</span>: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br>obj3===&gt; &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">hobby</span>: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br><span class="hljs-comment">// 结论：浅拷贝时，对象中基本属性不变，引用属性发生变化</span><br></code></pre></td></tr></table></figure><p><strong>注意：当拷贝对象只有一层的时候，是深拷贝</strong></p><h3 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h3><p>Object.assign()</p><ol><li>数组实现深拷贝可以使用以下方法</li></ol><ul><li>使用<code>slice()</code></li><li>使用<code>concat()</code></li><li>ES6扩展运算符[…str]</li><li>Array.from()</li><li></li></ul><h3 id="深拷贝的实现："><a href="#深拷贝的实现：" class="headerlink" title="深拷贝的实现："></a>深拷贝的实现：</h3><ul><li><p>JSON.parse(JSON.stringify())</p></li><li><p>jQuery.extend()方法</p></li></ul><h2 id="5-改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是"><a href="#5-改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是" class="headerlink" title="5.改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是"></a>5.改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是</h2><h2 id="6-轮播图实现思路"><a href="#6-轮播图实现思路" class="headerlink" title="6.轮播图实现思路"></a>6.轮播图实现思路</h2><p>1 实习内容介绍，你们的分页怎么实现，假如不给你total值，你可以实现分页吗，你觉得一个分页组件的核心要素是什么（有没有佬解答一下）<br>7渲染10w条数据怎么优化，虚拟列表技术上怎么实现，闪烁怎么解决<br>8常见性能优化手段<br>9假如用户打开了你的网站，但是是白屏你怎么解决<br>10说一下hashmap，常见数据结构<br>12nodejs有没有接触<br>13你对前端的看法，你更想做前端的哪个方向</p><h1 id="📚-浏览器"><a href="#📚-浏览器" class="headerlink" title="📚 浏览器"></a>📚 浏览器</h1><h2 id="1-跨域，强缓存协商缓存"><a href="#1-跨域，强缓存协商缓存" class="headerlink" title="1.跨域，强缓存协商缓存"></a>1.跨域，强缓存协商缓存</h2><h2 id="2-前端缓存方法"><a href="#2-前端缓存方法" class="headerlink" title="2.前端缓存方法"></a>2.前端缓存方法</h2><h1 id="📚-面试题带坑"><a href="#📚-面试题带坑" class="headerlink" title="📚 面试题带坑"></a>📚 面试题带坑</h1><h2 id="1-console-log-“1”-“2”-“3”-map-parseInt-的输出值是多少？"><a href="#1-console-log-“1”-“2”-“3”-map-parseInt-的输出值是多少？" class="headerlink" title="1.console.log([“1”, “2”, “3”].map(parseInt));的输出值是多少？"></a>1.console.log([“1”, “2”, “3”].map(parseInt));的输出值是多少？</h2><p>来源：<a href="https://juejin.cn/post/7049161354703273998">parseInt()函数绝不是你想的那么简单~~ - 掘金 (juejin.cn)</a></p><p>【知识点】：map()和parseInt()</p><p>【分析】<code>map</code>方法可以将一个数组映射为一个新数组。它接收一个<code>callback</code>回调函数作为参数，这个回调函数体现了将原数组映射成新数组的映射关系。原数组在循环遍历数组每一项时，都会调用一次<code>callback</code>回调函数，并传入三个参数：</p><ul><li>当前正在遍历的元素</li><li>元素索引</li><li>原数组本身 (这个参数基本不使用)</li></ul><p><code>callback</code>函数对当前遍历的元素进行包装执行，得到的返回值就是新数组中对应的结果</p><p><code>parseInt</code>接收两个参数：</p><ul><li>第一个参数<code>string</code>：要被解析的字符串，如果不是字符串会被转换，忽视空格符</li><li>第二个参数<code>radix</code>：要解析的数字的基数。该值介于<code>2 ~ 36</code>之间。默认值为10，表示十进制。这个参数表示<strong>将前面的字符从radix进制转化为十进制</strong></li></ul><p>把上面的代码的完整写法为：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<br>  [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, arr</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item + <span class="hljs-string">&quot;-----&quot;</span> + index);<br>    <span class="hljs-keyword">return</span> parseInt(item, index);<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><p>每次每一项给parseInt传入的值为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><span class="hljs-comment">-----0</span><br><span class="hljs-number">2</span><span class="hljs-comment">-----1</span><br><span class="hljs-number">3</span><span class="hljs-comment">-----2</span><br></code></pre></td></tr></table></figure><p>所以最终结果为：[ 1, NaN, NaN ]</p>]]></content>
    
    
    <categories>
      
      <category>八股文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html~css~js</tag>
      
      <tag>持续更新中</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 git基本操作（下），欢迎食用~</title>
    <link href="/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%8C%E6%AC%A2%E8%BF%8E%E9%A3%9F%E7%94%A8/"/>
    <url>/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%8C%E6%AC%A2%E8%BF%8E%E9%A3%9F%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本篇是学习(<a href="https://link.juejin.cn/?target=https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440" title="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">廖雪峰Git学习</a>)所写的学习总结笔记，方便自己后续回顾复习。</p><h1 id="📚-远程仓库"><a href="#📚-远程仓库" class="headerlink" title="📚 远程仓库"></a>📚 远程仓库</h1><p>在上篇中学到的git功能，其实在集中式版本管理系统中也能实现。Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。下面介绍一下git杀手级功能之一：远程仓库。</p><p>首先需要先注册github账号，github是提供Git仓库托管服务的，所以只要注册一个GitHub账号，就可以免费获得Git远程仓库。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><p><strong>第1步：创建SSH Key。</strong></p><p>在用户主目录下（我的电脑C:\Users\Administrator），看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制代码">ssh-keygen -t rsa -C &quot;填写你的邮箱&quot;<br></code></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a216ec3ad4594c3fba913f6996d8c3fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=79&s=11141&e=png&b=000000" width="70%" /></p><p>可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>第2步：登陆GitHub，增加SSH Keys</strong></p><p>步骤为：①setting–&gt; ②SSH and GPG keys –&gt; ③new SSH key</p><p>填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件（公钥）的内容即可</p><blockquote><p>为什么GitHub需要SSH Key呢？</p><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p></blockquote><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><h2 id="🌸-添加远程仓库"><a href="#🌸-添加远程仓库" class="headerlink" title="🌸 添加远程仓库"></a>🌸 添加远程仓库</h2><p><strong>本地仓库–&gt;远程仓库</strong></p><p>现在你在本地有一个git仓库，然后你想在github新建一个git远程仓库并让两个仓库进行同步，这样github上的仓库既可以用于备份，也可以让其他人通过该仓库进行协作。</p><p><strong>1.在github上新建仓库，名字可以和本地仓库不同。</strong></p><p>新建仓库后可以根据GitHub给的提示来进行操作，提示如下：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b313b7b908a848fc8a0910284548378c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=162&s=24628&e=png&b=f5f8fa"  width="70%"/></p><p>在本地仓库git bash中运行下列代码（根据自己的远程仓库提示来操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制代码">git remote add origin git@github.com:LuoyNothing/mygit.git<br></code></pre></td></tr></table></figure><p>添加后，远程库的名字就是<code>origin</code>，这里的<strong>origin为本地客户端认为的远程仓库的名字</strong>，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><blockquote><p>在多人协作的时候，每个人都有自己的git本地客户端和本地仓库，每个人都可以给同一个远程仓库在本地指定不同的名字。</p><p>只不过，origin是git客户端默认的远程仓库的名字，如果我们在关联时将远程仓库的名字指定为origin，在push的时候可以不指定远程仓库的名字，默认push到origin关联的远程仓库。如果修改了名字，在push的时候必须写上指定的远程仓库的名字。</p></blockquote><p><strong>2.把本地库的所有内容推送到远程库上</strong></p><p>在本地仓库git bash中接着运行：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u &lt;远程分支&gt; &lt;本地分支&gt;<br>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送步骤完成。<br>以后在本地仓库进行修改后要推送到远程仓库，直接执行<code>git push origin master</code></p><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h2 id="🌸-删除远程仓库"><a href="#🌸-删除远程仓库" class="headerlink" title="🌸 删除远程仓库"></a>🌸 删除远程仓库</h2><p><strong>1.解绑远程仓库和本地仓库连接</strong></p><p>可以先查看一下远程库信息：<code>git remote -v</code>。然后根据名字删除，比如删除origin：<code>git remote rm origin</code></p><p><strong>2.在github上真正删除远程仓库</strong></p><h2 id="🌸-从远程仓库克隆"><a href="#🌸-从远程仓库克隆" class="headerlink" title="🌸 从远程仓库克隆"></a>🌸 从远程仓库克隆</h2><p>使用<code>git clone 地址</code>就可以克隆完成。地址中Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><h1 id="📚-分支管理"><a href="#📚-分支管理" class="headerlink" title="📚 分支管理"></a>📚 分支管理</h1><h2 id="🌸-分支的理解"><a href="#🌸-分支的理解" class="headerlink" title="🌸 分支的理解"></a>🌸 分支的理解</h2><p>在开发一个项目的时候，团队负责人会给每个团队成员划分不同的任务。如果每个人都在主分支上进行项目开发，这样会影响其他人的工作。因此为了不影响其他人的工作，可以每个人新开一个分支来完成自己的任务，最后测试没问题再合并到主分支上，最后所有人的任务分支都合并到主分支上则可完成项目协作开发。当然实际开发中，可能有些许不同，比如按照任务来新建分支，然后安排某人来开发这个分支，或者几个人负责一个分支，然后根据提交的情况来查看每个人的工作量。</p><p>每个人都有本地仓库和远程仓库，一般在项目开发中，自己本地开发完之后提交到远程仓库中属于自己的分支，避免数据遗失。</p><p>每一次commit都会有提交描述和提交时间，git会将这些commit根据提交时间来串成一个时间线。截止目前只有一个时间线，在git里叫主分支，名字为master。</p><p><code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01449c510d5d48e9bc10c9754f7fdb36~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=534&s=27587&e=png&b=ffffff" width="50%" /></p><p>每一次提交，master分支都会向前走一步，随着提交次数的增多，master分支就越来越长。</p><h2 id="🌸-创建与合并分支"><a href="#🌸-创建与合并分支" class="headerlink" title="🌸 创建与合并分支"></a>🌸 创建与合并分支</h2><p>创建一个新分支，名字为：dev。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">// 创建分支dev</span><br>git branch <span class="hljs-built_in">dev</span><br><span class="hljs-comment">// 切换分支dev</span><br>方式一：git checkout <span class="hljs-built_in">dev</span><br>方式二：git switch <span class="hljs-built_in">dev</span><br><span class="hljs-comment">// 创建并切换分支</span><br>方式一：git checkout -b <span class="hljs-built_in">dev</span><br>方式二(更语义，和前面撤销工作区的更新不产生冲突)：git switch -c <span class="hljs-built_in">dev</span><br><span class="hljs-comment">// 查看当前所有分支</span><br>git branch<br></code></pre></td></tr></table></figure><p>当创建了分支dev之后，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e01ac7674c024d04950a2243a3325493~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=698&s=32261&e=png&b=ffffff" width="50%"/></p><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次(add+commit)后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ae82b830d984b0faf27135813427461~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1468&h=670&s=40357&e=png&b=ffffff" alt="image.png" width="50%" /></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// `git merge`命令用于合并指定分支到当前分支。<br>git merge dev<br></code></pre></td></tr></table></figure><p>这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e57e9c6356bf4c0fa36d8541f4d8f344~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1468&h=658&s=40546&e=png&b=ffffff"  width="50%"/></p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 删除分支dev<br>git branch -d dev<br></code></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h2 id="🌸-解决冲突"><a href="#🌸-解决冲突" class="headerlink" title="🌸 解决冲突"></a>🌸 解决冲突</h2><h2 id="🌸-分支管理策略"><a href="#🌸-分支管理策略" class="headerlink" title="🌸 分支管理策略"></a>🌸 分支管理策略</h2><h1 id="📚-命令汇总"><a href="#📚-命令汇总" class="headerlink" title="📚 命令汇总"></a>📚 命令汇总</h1><ul><li>远程仓库<ul><li>连接本地仓库和远程仓库：<code>git remote add origin git@github.com:LuoyNothing/mygit.git</code></li><li>第一次推送到远程仓库：<code>git push -u origin master</code></li><li>后续更新推送：<code>git push origin master</code></li><li>查看远程库信息：<code>git remote -v</code></li><li>删除本地仓库和远程仓库的连接：<code>git remote rm origin</code></li><li>从远程仓库克隆：<code>git clone 地址</code></li></ul></li><li>分支<ul><li>创建与合并分支<ul><li>创建分支：<code>git branch &lt;name&gt;</code></li><li>切换分支：<code>git switch &lt;name&gt;</code></li><li>创建并切换分支：<code>git switch -c &lt;name&gt;</code></li><li>合并分支：<code>git merge &lt;name&gt;</code></li><li>删除分支：<code>git branch -d &lt;name&gt;</code></li></ul></li></ul></li></ul><p>下篇在此结束，您花了5分钟又复习了一次相关知识，如果对你还有一点帮助的话，不妨给个小赞鼓励一下吧😊，感谢观看！</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 处理hexo博客中图片不显示问题</title>
    <link href="/2023/08/31/%F0%9F%93%A3-%E5%A4%84%E7%90%86hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/31/%F0%9F%93%A3-%E5%A4%84%E7%90%86hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>在解决这个问题的过程中，我经历了三个阶段，很磨人最终还是回到了起点，发现最初的方法最好，如果赶时间，可以直接看第三个阶段。</p><h1 id="🌸第一阶段：将图片保存在本地"><a href="#🌸第一阶段：将图片保存在本地" class="headerlink" title="🌸第一阶段：将图片保存在本地"></a>🌸第一阶段：将图片保存在本地</h1><p>搭建好个人博客网站之后，写了两篇markdown文章（这时候我图片用的是网络地址），然后按照hexo三连上传了文章，最后在浏览器打开发现图像不显示：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a0dd8fb049474f93f6d088d8dc2471~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=235&s=32490&e=png&b=fbfbfb" width="60%" /></p><p>一般图片显示不出来很大的原因是路径不对。于是我去查看了图片路径，确实找不到相应的图片。然后我参考<a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">相关资料</a>了解到<code>hexo g</code>指令是将md文件生成html页面，然后每篇博文生成的html页面最后都是放在用年月日做文件夹的下面，例如：<code>E:\myblog\public\2023\08\31\test</code>。</p><p>下面是我参考<a href="https://leay.net/2019/12/25/hexo/">养恐龙</a>、<a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">ETRD</a>、<a href="https://blog.csdn.net/m0_43401436/article/details/107191688">金牛大王</a>三位的回答，最终解决了我的问题。</p><p><strong>第一步</strong>：确保你的Hexo的配置文件_config.yml里面有这个选项配置，并将其置为true</p><pre><code class="hljs">post_asset_folder: true</code></pre><p>这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用<code>hexo n &quot;文章名&quot;</code>生成一篇新文章时，会在<code>\source\_posts</code>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66e0f2f20d7f4791a68b3973bf2f2734~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=225&s=31200&e=png&b=ffffff"  width=" 60%"/></p><p>【注】你也可以自己在 _posts 文件夹下自动生成md文件和相同名字的文件夹（用于存放图片）</p><p><strong>第二步</strong>：typora中的图像保存位置设置</p><p>点开文件——&gt;偏好设置，设置如下：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993af5c7afec466eaec981af9ac662ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1613&h=657&s=64676&e=png&b=fafafa" width="60%"/></p><p>修改好后，图片引用路径就在和博文同名的文件夹（新建博文名为test）的图片，如图所示：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc88f5524f094d118bedc8456e650126~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918&h=103&s=12423&e=png&b=ffffff" width="60%"/></p><p><strong>第三步</strong>：安装插件</p><p>在根目录下打开git bash，然后运行以下命令，如果有安装淘宝镜像，第一个改为cnpm即可。</p><pre><code class="hljs">npm install https://github.com/xcodebuild/hexo-asset-image.git</code></pre><p>运行结果如下图所示，图为安装成功：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/059d60bdaded4a0fa0f1ac61286f187e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=242&s=25251&e=png&b=000000" width="70%"/></p><p>该插件的作用：将图片等静态资源的引用路径转化为绝对路径。</p><p>【注】我最开始不是用的上面命令安装的，用的是<code>npm install hexo-asset-image -- save</code>，该命令安装的是插件 hexo-asset-image 1.0 ，这个版本有点问题，安装后图片不能正常显示，查看图片路径被渲染成了 <code>/.xx/abc.png</code> 的格式（xx 是域名后缀）。最后采用上面的命令才成功。</p><p>如何卸载该插件？路径：<code>\blog\node_modules\hexo-asset-image</code>，直接删除文件夹，我试过没问题。</p><h1 id="🌸-第二阶段：将图片保存到图床"><a href="#🌸-第二阶段：将图片保存到图床" class="headerlink" title="🌸 第二阶段：将图片保存到图床"></a>🌸 第二阶段：将图片保存到图床</h1><p>网上查了一些有关md文件中图片的保存位置，发现除了在本地保存外，还可以采用图床进行保存，可以尝试一下<a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 这个图床上传工具，也方便md文件在其他站的上传。</p><p>参考资料：<a href="https://blog.csdn.net/weixin_61529967/article/details/132273065">前端小雪</a>、<a href="https://blog.csdn.net/weixin_43447266/article/details/132490718">刘昕hrf</a>、<a href="https://blog.csdn.net/weixin_45525272/article/details/125387761">杨 戬</a></p><p>我根据上面三个参考回答实现了将图片保存到gitee图床中。</p><p>我的图床：gitee平台</p><h1 id="🌸-第三阶段：图片采用网络地址"><a href="#🌸-第三阶段：图片采用网络地址" class="headerlink" title="🌸 第三阶段：图片采用网络地址"></a>🌸 第三阶段：图片采用网络地址</h1><p>参考<a href="https://blog.csdn.net/mqdxiaoxiao/article/details/96770756">野猿新一</a>的回答，图片路径还是引用网络地址，想要在hexo博客中查看到网络地址的图片，直接在文章Front-matter下加一句：<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code>即可，如下图所示：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0f3200872db4755a847a50c37e6327a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=291&s=28703&e=png&b=f9f9f9" width="70%"/></p><p>最终发现就是加了这一句就可以显示网络地址图片了，我哭死┭┮﹏┭┮。也不需要插件了，也不需要找个地方保存图片！</p><p>还有一个小问题就是，hexo博客网络图片下方可能会出现image.png，如果所示：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4cccaa212ee4ca0ac5b2cd4f85c41d7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=809&h=170&s=55087&e=png&b=f5f5f5" width="60%" /></p><p>解决办法就是把alt这一块（下图圈的地方）去掉即可：</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43fc18d732d14116a6f8fedf7de8de30~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1331&h=174&s=61361&e=png&b=fffefe" width="60%" /></p><p>本篇结束！</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 git基本操作（上），命令总结清单在最后</title>
    <link href="/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95%E5%9C%A8%E6%9C%80%E5%90%8E/"/>
    <url>/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95%E5%9C%A8%E6%9C%80%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本篇是学习(<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">廖雪峰Git学习</a>)所写的学习总结笔记</p><h1 id="📚-git简介"><a href="#📚-git简介" class="headerlink" title="📚 git简介"></a>📚 git简介</h1><p>git 是一个版本控制工具，可以用于团队协作。git可以记录之前修改过的内容版本，方便在需要的时候回退到之前的版本，还支持团队内部进行协作更新内容。</p><p>用起来大概就是下面这样子，可以记录修改的版本，谁修改的，修改了哪些内容以及日期：</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecd727d76fe64229bfd2e1d715d2fd02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1154&h=335&e=png&b=ffffff" width:"50%" /></p><p>Git是分布式版本控制系统，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。</p><p>Git还具有极其强大的分支管理</p><h1 id="📚-git安装"><a href="#📚-git安装" class="headerlink" title="📚 git安装"></a>📚 git安装</h1><p>在这里只描述windows上安装git</p><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>因为是分布式版本控制系统，所以需要知道你是谁。注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="🌸-名词解释"><a href="#🌸-名词解释" class="headerlink" title="🌸 名词解释"></a>🌸 名词解释</h2><ul><li><p><strong>工作区</strong>：本地电脑存放文件的文件夹</p></li><li><p>**暂存区(index&#x2F;stage)**：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。版本库中包含2个部分，一部分就是暂存区,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；</p></li><li><p><strong>本地仓库</strong>：.git文件夹里还包括git自动创建的第一个分支：master，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；</p></li><li><p><strong>远程仓库</strong>：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，更新后推送到远程仓库中即可；</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1e326bcd19941c1816661245c2a40e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=795&h=427&e=png&b=fdfdfd"  width="50%"/></p></li></ul><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h2 id="🌸-本地仓库"><a href="#🌸-本地仓库" class="headerlink" title="🌸 本地仓库"></a>🌸 本地仓库</h2><p><strong>1.创建版本库：</strong><br>    什么是版本库呢？英文名<strong>repository</strong>，可以简单理解为一个文件夹，该文件夹下的文件都可以被Git管理起来。</p><p>通过<code>git init</code>命令将这个文件夹变为git可以管理的仓库。建好仓库之后，会出现一个.git文件，该文件是git跟踪管理版本库的，千万不能修改！如果没有该文件，说明是默认隐藏的，输入<code>ls -ah</code>就可以看见。</p><p><strong>2.在版本库中加文件</strong></p><p>所有的版本控制系统其实只能监控文本文件的改动，比如txt文件，网页，所有的程序代码等，git也不例外。而图片、视频这些二进制文件，虽然也能用版本控制系统管理，但是不能跟踪文件的变化，word文件也是二进制文件。</p><p>接下来就是上次文件的步骤：首先新建一个readme.txt文件，并随便写入一些内容</p><ul><li><code>git add readme.txt</code></li><li><code>git commit -m &quot;write readme txt&quot;</code></li></ul><p><code>git add readme.txt</code> 表示告诉git,将文件添加到暂存区中，无输出则成功。也可以采用<code>git add .</code>表示添加变更的文件到暂存区；</p><p><code>git commit -m &quot;本次提交的说明&quot;</code> 表示告诉git，将代码提交到仓库，后面附带对本次提交的说明。该语句执行完会返回一个文件被修改，插入了n行内容（取决于你写了多少内容）。为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件。</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70ca0240e2ca4c1193b646f0e9a1df1d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=156&e=png&b=000000" width="50%" /><p>如果文件有修改，则再执行以上2个步骤即可。</p><h1 id="📚-时光穿梭机"><a href="#📚-时光穿梭机" class="headerlink" title="📚 时光穿梭机"></a>📚 时光穿梭机</h1><h2 id="🌸-版本回退"><a href="#🌸-版本回退" class="headerlink" title="🌸 版本回退"></a>🌸 版本回退</h2><p>要回到之前的版本，我们可以使用<code>git log --pretty=oneline</code>命令显示从最近到最远的提交日志。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6d23155076742b1a7dcace8365cc55f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=84&e=png&b=000000"  width="70%"/></p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本。假如我们要回到第一版本，可以使用<code>git reset --hard 版本号</code>，版本号就是黄色的那一个字符串。</p><p>1.回退到第一版本，当前在第三版本</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7111c1745a1242c29dd0e5c9f5818686~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=362&s=52170&e=png&b=000000" width="50%" /><p>2.回退到第三版本，当前在第一版本</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94fd6cce736346f5941d55d1530a7ee8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=157&e=png&b=000000" width="50%" /><p>3.如果想回到新的版本，但是找不到版本号：可以使用git reflog来查看你的每一次命令（从近到远）</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f53986ed2b84dca806390fe52c19b8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=410&e=png&b=000000" width="50%" /><p>在上图中就可以找到最新版本的版本号，版本号可以不写全，但也不能写太少，防止版本号重复。</p><h2 id="🌸-撤销修改"><a href="#🌸-撤销修改" class="headerlink" title="🌸 撤销修改"></a>🌸 撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改，意思就是，把文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li><p>文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；利用<code>cat</code>命令可以查看文件里的内容，这里要撤销最新的修改，最后一行（已成功）</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9163aac12fa247a9b317752e7513c3e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=483&h=233&e=png&b=000000"  width="50%" /></p></li><li><p>文件已经添加到暂存区(stage)。可以使用<code>git reset HEAD 文件名+后缀</code>来把暂存区的修改撤销掉（unstage），重新放回工作区。然后<code>git checkout -- file</code>即可</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d07765f66a4466b52c60ee8848975e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=459&h=386&e=png&b=000000"  width="40%"/></p></li></ul><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程，如果提交到远程仓库就G啦。</p><h2 id="🌸-删除文件"><a href="#🌸-删除文件" class="headerlink" title="🌸 删除文件"></a>🌸 删除文件</h2><p>在工作区删除文件之后，工作区和版本库就不一样了，git status可以告知你删除了什么文件。下面分为2种情况</p><ul><li>确实要删除文件，在版本库中也有删除。则直接用命令<code>git rm &lt;file&gt;</code>删掉，并且<code>git commit</code></li><li>如果是误删。在工作区删除了文件，但是版本库中还有，则恢复文件：<code>git checkout -- &lt;file&gt;</code>。<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul><blockquote><p>【注】未添加到版本库的文件被删除掉是不能被恢复的！</p></blockquote><p>常见错误的解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">//取消http代理<br>git config --global --unset http.proxy<br>//取消https代理 <br>git config --global --unset https.proxy<br><br>git config --global http.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure><h2 id="🌸-命令总结："><a href="#🌸-命令总结：" class="headerlink" title="🌸 命令总结："></a>🌸 命令总结：</h2><ul><li><p>初始化版本库</p><ul><li><code>git init</code> 创建版本库</li></ul></li><li><p>添加文件</p><ul><li><code>git add &lt;file&gt;</code> 将文件加入版本库，<code>git add .</code>添加所有的变更文件到暂存区</li><li><code>git commit -m &quot;提交说明内容&quot;</code> 将文件提交到版本库</li></ul></li><li><p>回退文件版本</p><ul><li><code>git status</code> 查看仓库当前的状态</li><li><code>git diff 文件名+后缀</code> 查看某文件的更改内容</li><li><code>git log</code> 显示从最近到最远的提交日志，<code>git log --pretty=oneline</code>显示的内容更精简。</li><li><code>git reset --hard 版本号</code> 回退到某个版本</li><li><code>git reflog</code> 如果不知道版本号，可以查看之前使用过的命令，从而找到版本号</li></ul></li><li><p>撤销修改</p><ul><li><code>git checkout -- &lt;file&gt;</code>可以丢弃工作区的修改</li><li><code>git reset HEAD 文件名+后缀</code>来把暂存区的修改撤销掉（unstage）</li></ul></li></ul><p>上篇在此结束，您花了5分钟又学到了新的知识，如果对你还有一点帮助的话，不妨给个小赞鼓励一下吧😊，感谢观看！</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 用hexo搭建个人博客（持续更新中）</title>
    <link href="/2023/08/30/%F0%9F%93%A3-%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <url>/2023/08/30/%F0%9F%93%A3-%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本文记录自己搭建个人博客的历程，欢迎收看~</p><h1 id="📚-搭建基础的个人博客"><a href="#📚-搭建基础的个人博客" class="headerlink" title="📚 搭建基础的个人博客"></a>📚 搭建基础的个人博客</h1><blockquote><p><strong>前提：需安装了git 和 nodejs</strong></p></blockquote><ol><li>安装hexo。先新建一个文件夹，在该文件夹下打开git bash，然后运行<code>npm install -g hexo-cli</code></li></ol>  <p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cf3229ac3df4442b4be56bd18e0aea4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=708&h=353&s=35036&e=png&b=f7f7f7" width="50%"/></p>  <ol start="2"><li>初始化hexo，命令为：<code>hexo init</code> ，出现下图结果就表示初始化成功！</li></ol>  <p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26b0a3e34474736ad89da964b780fce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=101&s=10725&e=png&b=000000" width="70%"/></p>  <p>  新建完成后，在路径下会产生一些文件和文件夹：</p>  <p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b966396263f42a8b814307a95898acc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=319&s=29387&e=png&b=fffefe" width="50%" /></p>    <ul><li><code>_config.yml</code>：俗称站点配置文件，很多与博客网站的格式、内容相关的设置都需要在里面改。</li><li><code>node_modules</code>:存储Hexo插件的文件，可以实现各种扩展功能。一般不需要管。</li><li><code>package.json</code>：相关描述的，比如名字、版本。</li><li><code>scaffolds</code>：模板文件夹，里面的<code>post.md</code>文件可以设置每一篇博客的模板。具体用起来就知道能干嘛了。</li><li><code>source</code>：非常重要。所有的个人文件都在里面！</li><li><code>themes</code>：主题文件夹，可以从<a href="https://link.juejin.cn/?target=https://hexo.io/themes/" title="https://hexo.io/themes/">Hexo主题官网</a>或者网上大神的Github主页下载各种各样美观的主题，让自己的网站变得逼格高端的关键！</li></ul><ol start="3"><li>启动服务器</li></ol><p>命令为：<code>hexo server</code>，或者简写：<code>hexo s</code>，然后打开浏览器，在地址栏输入：localhost:4000回车就可以得到如下结果：(ctrl+c可关闭服务)</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f108fb71f11e48a393a221ea96c47829~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1844&h=1084&s=647678&e=png&b=f4f3f3" alt="image.png" width="50%" /></p><p>至此，您的Hexo博客已经搭建在本地。</p><p>4.上传到github</p><p>在github创建仓库，仓库名为：&lt;Github账号名称&gt;.github.io（必须是这个，否则后续打不开）。安装<code>hexo-deployer-git</code>插件。在命令行（即Git Bash）运行以下命令即可（也可以走淘宝镜像，淘宝镜像就是换成cnpm）：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>添加SSH key，如果已添加可以不用管。如果未添加，可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">添加SSH key</a>，我这里已经添加，接着下一步；</p><ol start="5"><li>修改<code>_config.yml</code>（在站点目录下）。文件末尾修改为：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Deployment</span><br><span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:LuoyNothing/LuoyNothing.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure>6.生成页面并上传到github</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 生成页面：<br>hexo g<br><span class="hljs-regexp">//</span> 上传到github: <br>hexo d<br></code></pre></td></tr></table></figure><p>执行完上面两个命令，并出现下图结果即表示上传成功。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d714419ddf40fc9c44f7d6ac4a8eb8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=303&s=44296&e=png&b=000000" width="50%" /></p><p>至此，您的Hexo博客已经搭建在GitHub上，访问域名为：<a href="https://luoynothing.github.io/">https://luoynothing.github.io/</a></p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe722b935d254d849c4a5f8a24f29300~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1086&s=911964&e=png&b=f5f4f4" width="50%" /></p><p>访问博客，开始的页面是初始化页面，没有做美化和增加内容。</p><h2 id="🌸-域名绑定"><a href="#🌸-域名绑定" class="headerlink" title="🌸 域名绑定"></a>🌸 域名绑定</h2><p>还未绑定</p><h1 id="📚-文档学习"><a href="#📚-文档学习" class="headerlink" title="📚 文档学习"></a>📚 文档学习</h1><p>官网文档：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><h2 id="🌸-修改主题"><a href="#🌸-修改主题" class="headerlink" title="🌸 修改主题"></a>🌸 修改主题</h2><p>我的博客修改的主题是fluid（<a href="https://hexo.fluid-dev.com/docs/start/"> Hexo Fluid 用户手册</a>）,github(<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid Hexo 主题</a>)，以下是详细步骤：</p><ol><li>下载主题</li></ol><p><strong>方式一</strong>：推荐通过 npm 直接安装，进入博客目录执行命令：<code>npm install --save hexo-theme-fluid</code></p><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的_config.yml内容复制过去。</p><p><strong>方式二</strong>：下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a>解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p>我采用的是方式二。</p><ol start="2"><li>然后采用hexo三连，就可以在本地查看到主题修改<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 启动本地服务器，用于预览主题。<br>hexo s<br></code></pre></td></tr></table></figure>下图表示换主题成功！然后可以用<code>localhost:4000</code>来访问个人博客</li></ol><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5643b5e6987401997f520c8cad74c84~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=631&s=57034&e=png&b=000000" width="50%" /></p><ol start="3"><li>部署到github上：</li></ol><p>hexo三连：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 部署到远程仓库里<br>hexo d<br></code></pre></td></tr></table></figure><p>然后可以用<a href="https://luoynothing.github.io/">https://luoynothing.github.io/</a> 来访问个人博客了。</p><h2 id="🌸-发布文章"><a href="#🌸-发布文章" class="headerlink" title="🌸 发布文章"></a>🌸 发布文章</h2><p>1.新建md文件。在网站根目录下git bash，输入<code>hexo new &lt;title&gt;</code>，执行该命令，Hexo会在<code>/source/_posts</code>目录下创建一篇新的文章。</p><p>2.上传到github，就是hexo三连操作。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 部署到远程仓库里<br>hexo d<br></code></pre></td></tr></table></figure><h1 id="📚-博客更新说明"><a href="#📚-博客更新说明" class="headerlink" title="📚 博客更新说明"></a>📚 博客更新说明</h1><p><strong>2023-8-30</strong></p><p>1.成功搭建博客</p><p>2.博客文章：</p><p>​1.封面字段：标题、发布时间、关键字</p><p>​摘要：去掉摘要</p><p>​2.封面进去：发布时间、更新时间、字数、阅读时长​</p><p>3.标签和分类：</p><p>分类1：前端</p><p>​子类：html css等</p><p>分类2：持续更新</p><p>标签：相当于关键字吧，里面的某个知识点</p><p>4.博客中的图片不显示问题</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
