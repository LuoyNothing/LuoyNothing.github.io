<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>差分隐私需求</title>
    <link href="/2023/09/17/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E9%9C%80%E6%B1%82/"/>
    <url>/2023/09/17/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81%E9%9C%80%E6%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>同态加密需求</title>
    <link href="/2023/09/17/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E9%9C%80%E6%B1%82/"/>
    <url>/2023/09/17/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E9%9C%80%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>1.需要做的：</p><p>​1.一份联邦学习同态加密代码，能够跑通无bug</p><p>​2.我有几个问题，需要给我解答，问题写在下面。</p><p>1.通过同态加密技术加密的两个数据能够进行大小（&gt;、&lt;、&#x3D;）比较吗？</p><p>2.同态加密中，由客户端还是服务器端生成密钥对，还是第三方生成？</p><p>3.密钥对在每个参与方都是一样的吗？如果一样的话，如果有参与方是恶意的？岂不是很危险？如果是不一样的，那不一样的密钥加密的数据可以加法运算吗？</p><p>1.联邦学习训练过程中，每个参与方和服务端都有自己的密钥对。每个参与方用自己的公钥加密上传更新后，因为不同公钥加密的数据不能进行计算，上传到服务端怎么进行聚合呢？服务端的密钥对有什么作用呢？</p><p>2.上次你说同态加密的数据不能直接对比大小，需要使用安全函数评估、协议等方法，能再详细的给我说一下吗？可以举个简单的例子。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>联邦学习后门攻击需求</title>
    <link href="/2023/09/17/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB%E9%9C%80%E6%B1%82/"/>
    <url>/2023/09/17/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%90%8E%E9%97%A8%E6%94%BB%E5%87%BB%E9%9C%80%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p>联邦学习中加入后门攻击：</p><p>1.后门样本：在样本上加触发器</p><p>2.后门攻击：在训练阶段，输入后门样本对模型进行训练，给模型注入后门。在测试阶段，模型对正常样本表现正常，对后门样本分类为攻击者的目标分类</p><p><strong>1.需要做的</strong></p><p>​1.<strong>加3个后门攻击</strong>：加高斯噪声、语义后门攻击、模型替换后门</p><p>​高斯噪声：均值为0，标准差随便设置一个值，只要能够在图片上成功加入高斯噪声就行。</p><p>​模型替换后门攻击、语义后门攻击：已有代码（论文附带的），代码能够正常运行。</p><p>​论文参考：《How To Backdoor Federated Learning》</p><p>​代码（建议把高斯噪声加在这个代码里）：<a href="https://github.com/ebagdasa/backdoors101">https://github.com/ebagdasa/backdoors101</a></p><p>​2.<strong>运行代码，跑出3个后门攻击的后门精度变化图</strong>：跑100轮吧</p><p><strong>2.需要给我的</strong></p><p>​1.高斯噪声的代码和画图(后门精度)的代码</p><p>​2.语义后门、模型替换后门是如何实现的，思路是什么？可以写个小文档或者是直接给我讲（基于已有代码）</p><p>​3.3个后门攻击的后门精度变化图（其他超参数设置，随你设置都行，我主要想看后门攻击是否成功注入）</p><p>​</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>📣-防御实验</title>
    <link href="/2023/09/15/%F0%9F%93%A3-%E9%98%B2%E5%BE%A1%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/09/15/%F0%9F%93%A3-%E9%98%B2%E5%BE%A1%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[给全局模型参数加高斯噪声：$w{{_{G}^{r}}^{\prime }}=w_{G}^{r}+N(0,{{\sigma }^{2}})$，其中$\sigma =\sqrt{2\operatorname{In}\frac{1.25}{\delta }}\times \frac{\Delta f}{\epsilon }$，表示标准差，$\sigma^2$表示方差$N(0,{{\sigma }^{2}})$表示从中心为 0 且方差为${\sigma }^{2}$的高斯（正态）分布中抽样。在实现的过程中，只需要给出方差的值即可。问题1：如何设置高斯噪声的标准差？可以先设置为0.01]]></content>
    
    
    <categories>
      
      <category>论文实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续更新中</tag>
      
      <tag>防御实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣-论文理论积累</title>
    <link href="/2023/09/14/%F0%9F%93%A3-%E8%AE%BA%E6%96%87%E7%90%86%E8%AE%BA%E7%A7%AF%E7%B4%AF/"/>
    <url>/2023/09/14/%F0%9F%93%A3-%E8%AE%BA%E6%96%87%E7%90%86%E8%AE%BA%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[# 📚  同态加密# 📚 差分隐私## 🌸 这里给出cdp的推理过程​首先给出中心化差分隐私（CDP）的**严格定义**​$$\operatorname{Pr}[\mathcal{A}(D) \in S] \leqslant \operatorname{Pr}\left[\mathcal{A}\left(D^{\prime}\right) \in S\right] \times \mathrm{e}^{\epsilon}$$​定义（**松弛DP**） $$(\epsilon, \delta)$$-差分隐私  对于只有一个记录不同的两个数据集$$D$$和$$D'$$，一个随机算法$$M$$，以及对于任意的输出$$S\subset\text{Range}(M)$$，我们称随机算法$$M$$提供$$(\epsilon, \delta)$$-差分隐私保护，当且仅当其满足：​$$\operatorname{Pr}[\mathcal{M}(D) \in S] \leqslant \operatorname{Pr}\left[\mathcal{M}\left(D^{\prime}\right) \in S\right] \times \mathrm{e}^{\epsilon}+\delta$$​其中，$$\epsilon$$表示隐私预算，$$\delta$$表示失败概率。当$$\delta=0$$时，便得到了性能更好的$$\epsilon$$-差分隐私。$$\epsilon$$用于控制算法$$M$$在邻近数据集上获得相同输出的概率比值。$$\epsilon$$越小，那么算法在邻近数据集上获得相同输出的概率就越大，用户就通过输出结果无法判断数据到底是来自哪个数据集，从而达到隐私保护的目的。特别的，当$$\epsilon=0$$时，算法$$M$$在邻近数据集上得到相同的输出的概率是一样的。反之，$$\epsilon$$越大，其隐私保护的程度就越低。**加拉普拉斯噪声的推导过程如下：**$$\operatorname{Pr}[\mathcal{A}(D) = t] \leqslant \operatorname{Pr}\left[\mathcal{A}\left(D^{\prime}\right) =t\right] \times \mathrm{e}^{\epsilon}$$这里的$A$是一个算法，我们希望通过$A$这个算法使得$\frac{\operatorname{Pr}[\mathcal{A}(D) = t]}{\operatorname{Pr}[\mathcal{A}(D^{\prime}) = t]}\le {e}^{\epsilon} $ 两个概率的比值小于等于${e}^{\epsilon}$，$$A$$是一个函数，我们想设计这个函数满足上面的条件，其中$$A(x) = F(x) + x$$，其中$$F(X)$$是原函数，我们通过在原函数上加一个噪声$$x$$（加一个分布）来设计这个$A$算法，根据所加噪声的量来使其达到上述条件。那么怎么加？加多少呢？我们先来看拉普拉斯噪声$\frac{\operatorname{Pr}[\mathcal{A}(D) = t]}{\operatorname{Pr}[\mathcal{A}(D^{\prime}) = t]} = \frac{\operatorname{Pr}[\mathcal F(D) + x = t]}{\operatorname{Pr}[\mathcal F(D^{\prime}) + x= t]} = \frac{\operatorname{Pr}[\mathcal x = t - \mathcal F(D)]}{\operatorname{Pr}[\mathcal x= t - \mathcal F(D^{\prime})]} $​我们这里想用拉普拉斯加噪，也就是将$x$当做拉普拉斯分布，那么满足$\mathrm{e}^{\epsilon}$的条件下应该加多少噪声呢？，其中拉普拉斯分布的密度函数为$f(x \mid \mu, \beta )=\frac{1}{2 \beta} e^{-\frac{|x-\mu|}{\beta}}$，其中$\mu$是位置参数，$\beta$是尺度参数，这里令$\mu=0$，则$f(x \mid 0, \beta )=\frac{1}{2 \beta} e^{-\frac{|x|}{\beta}}$（也就是这里$\beta$应该怎么取值），将这个式子带进去可得：其中涉及三角不等式$\left | a \right | - \left | b \right | \le \left | a - b \right |$，即可得如下的计算过程。$\frac{\frac{1}{2 \beta} e^{-\frac{|t - \mathcal F(D)|}{\beta}}}{ \frac{1}{2 \beta} e^{-\frac{|t - \mathcal F(D^{\prime})|}{\beta}}} = e^{\frac{|t - \mathcal F(D^{\prime}))| - |t - \mathcal F(D)|}{\beta}}  \le e^{\frac{|\mathcal F(D) - \mathcal F(D^{\prime})|}{\beta}} $又因为敏感度的定义：$|\mathcal F(D) - \mathcal F(D^{\prime})| \le  \Delta f$所以上述式子继续化简为：$\le e^{\frac{\Delta f}{\beta } } $使用拉普拉斯噪声进行处理得到的概率比值$\le e^{\frac{\Delta f}{\beta } } $得满足定义条件，所以$\le e^{\frac{\Delta f}{\beta } } \le e^{\epsilon}$，即$\frac{\Delta f}{\beta } \le \epsilon$即可，最后$\beta$只要$\ge \frac{\Delta f}{\epsilon }$即可满足隐私保护条件。$\epsilon$ 我们称为隐私损失，隐私损失越小，分布相似度越高，隐私保护越高，$\beta$也就越大，图越平缓（如下图可见），所加噪声越多。<p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad919ed16ab34ca1b92d4d61cde7a2fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=372&h=264&s=14908&e=png&a=1&b=ffffff" alt="image.png"  width="40%"/></p>**下面开始推导加高斯噪声的过程：**松弛差分隐私定义：$$\operatorname{Pr}[\mathcal{A}(D) = t] \leqslant \operatorname{Pr}\left[\mathcal{A}\left(D^{\prime}\right) =t\right] \times \mathrm{e}^{\epsilon}+\delta$$上述表示违反严格差分隐私的概率为$$\delta$$，也可以这么写$\operatorname{Pr}\left[\frac{\operatorname{Pr}[\mathcal{A}(D) = t]}{\operatorname{Pr}[\mathcal{A}(D^{\prime}) = t]}\ge {e}^{\epsilon}\right] \le \delta $这里我们要加高斯分布，我们还是先来计算概率的比值：$\frac{\operatorname{Pr}[\mathcal{A}(D) = t]}{\operatorname{Pr}[\mathcal{A}(D^{\prime}) = t]} = \frac{\operatorname{Pr}[\mathcal F(D) + x = t]}{\operatorname{Pr}[\mathcal F(D^{\prime}) + x= t]} = \frac{\operatorname{Pr}[\mathcal x = t - \mathcal F(D)]}{\operatorname{Pr}[\mathcal x= t - \mathcal F(D^{\prime})]} $这里$x$就表示我们要加的高斯噪声，高斯密度函数为$f(x \mid \mu, \sigma )=\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}$，其中$\mu$称为均值，$\sigma^2$称为方差，$\sigma$表示标准差。这里均值先取0，即为$f(x \mid 0, \sigma )=\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{x^{2}}{2 \sigma^{2}}}$。这里就不能像上面一样把密度函数带进去，因为$x^2$是消不掉的，所以这里，我们让$t - \mathcal F(D) = x$，然后$t - \mathcal F(D^{\prime})) = x + \Delta f$，这里的$\Delta f$是敏感度，先暂时考虑=的情况，然后带入进去看一下：$\frac{\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{{(t - \mathcal F(D))}^{2}}{2 \sigma^{2}}}}{\frac{1}{\sqrt{2 \pi} \sigma} e^{-\frac{(t - \mathcal F(D^{\prime}))^{2}}{2 \sigma^{2}}}} = e^{\frac{(t - \mathcal F(D^{\prime}))^{2} - (t - \mathcal F(D))^{2}}{2 \sigma^{2}}} = e^{\frac{(x + \Delta f)^{2} - x^{2}}{2 \sigma^{2}}} = e^{\frac{2x \Delta f + {\Delta f}^2}{2 \sigma^{2}}}$最右边得到的式子还是一个高斯分布，也可以称为亚高斯分布。我们要想满足差分隐私的条件，就需要使得$\frac{2x \Delta f + {\Delta f}^2}{2 \sigma^{2}} \le \epsilon$，把$x$全部放到左边去，可以得到：$x \le \frac{\sigma ^2 \epsilon }{\Delta f} - \frac{\Delta f}{2} $，这个$x$本身是取任意值的，是不能让他小于某个值，所以不能满足严格差分隐私，这里呢我们让$1- \delta$的概率满足$\le \epsilon$即可，也就是让$\delta$的概率满足$\ge \epsilon$即可，即：$$\operatorname{Pr}[|x| \ge \frac{\sigma ^2 \epsilon }{\Delta f} - \frac{\Delta f}{2}] \leqslant \delta$$，也就是说这个x违反严格差分隐私的概率控制在$\delta$范围内，图像具有对称性，看一边的话则为：$$\operatorname{Pr}[x \ge \frac{\sigma ^2 \epsilon }{\Delta f} - \frac{\Delta f}{2}] \leqslant \frac {\delta}{2}$$我要给全局模型参数加高斯噪声，其中$$L\sim \operatorname{Gaussian}\left(0,\sigma^2 \right)$$为添加的随机噪声概率密度函数，即服从参数$$\mu=0,  $$$$\sigma=\sqrt{2 \operatorname{In} \frac{1.25}{\delta}} \times \frac{\Delta f}{\epsilon}$$的高斯分布。我想知道其中的$\Delta f$、$\epsilon$、$\delta$ 如何设置？敏感度如何计算得出的？]]></content>
    
    
    <categories>
      
      <category>论文实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低通滤波器需求</title>
    <link href="/2023/09/14/%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8%E9%9C%80%E6%B1%82/"/>
    <url>/2023/09/14/%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2%E5%99%A8%E9%9C%80%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<p><strong>需求：</strong></p><p><strong>1.应用背景（用于理解我的需求）：</strong>我要做的是机器学习中后门攻击的防御，</p><p>​<strong>后门样本：</strong>给图片加小白块</p><p>​<strong>后门攻击：</strong>把 <code>后门样本</code> 输入模型中训练，使得模型在测试阶段对 有小白块的图片 误分类。</p><p>​<strong>防御：</strong>和正常样本相比，后门样本在<code>频域范围</code>会表现<strong>高频信号</strong>（该高频信号是白块产生的），我的目的就是通过<code>低通滤波器</code>将后门样本中的高频信号去掉。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff0f3a3fb6354cf799a73729ac1ec067~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1002&h=674&s=68349&e=png&b=fefdfd" alt="image.png"  width="50%"/></p><p><strong>2.需要做的：</strong></p><ol><li>图片选择：cifar10中随机10张图片（要是不能用，就随意的图片也行）</li><li>给图片加白块（白块大小和位置随意）</li><li><font color=red>设计iir低通滤波器来 过滤掉 白块产生的高频信号</font></li><li>效果：不需要具体的效果，你可以告诉我<code>参数</code>，给我说怎么<code>调参</code>来呈现不同的效果。比如参数x，放大参数则过滤掉的高频信号越少，图片越清晰。缩小参数x，则过滤掉的高频信号越多，图片越模糊。</li></ol><p><strong>3.需要给我的：</strong></p><ol><li><p>iir低通滤波器代码</p></li><li><p>参数的初始值如何设置</p></li><li><p>调参的参数</p></li></ol><p>以下内容可看可不看，无论如何，十分感谢 ^_^</p><blockquote><p>其他：自己学习相关资料设计低通滤波器的过程</p></blockquote><p>​自己感觉不对劲的，哭了o(╥﹏╥)o，虽然不对劲，但是还是想写下来，表示自己学习了确实没有新头绪，所以才来找您帮我处理一下。当然如果有空，可以简单说一下哪里不对劲吗？</p>① 确定数字滤波器的性能指标​5个：采样频率$ f_{samp}、 $通带截止频率$$f_p$$、阻带截止频率$$f_s$$、通带衰减$$\alpha_p$$、阻带衰减$$\alpha_s$$② 对$f_p$、$f_s$归一化​${{\omega }_{p}}={{f}_{p}}/({{f}_{samp}}/2)$​${{\omega }_{s}}={{f}_{s}}/({{f}_{samp}}/2)$③ ${\omega }_{p}$、${\omega }_{s}$转换为模拟滤波器指标​$\Omega_{\mathrm{s}}=\frac{2}{\mathrm{~T}} \tan \frac{\omega_{\mathrm{s}}}{2}$​$\Omega_{\mathrm{p}}=\frac{2}{\mathrm{~T}} \tan \frac{\omega_{\mathrm{p}}}{2}$④ 计算出滤波器阶数$R$和3dB截止频率$\Omega_{\mathrm{c}}$$\mathrm{R}=\lg \sqrt{\frac{10^{\alpha_{\mathrm{s}} / 10}-1}{10^{\alpha_{\mathrm{p}} / 10}-1}} / \lg \left(\frac{\Omega_s}{\Omega_p}\right)$​$\Omega_c=\frac{\Omega_p}{(10^{\alpha_p / 10-1})^{1/2N}}$⑤ 计算低通滤波器的传递函数​低通滤波器的传递函数：$ \mathrm{H}_{(s)}=\frac{1}{\left(s-s_{1}\right)\left(s-s_{2}\right) \ldots\left(s-s_{R}\right)}，其中R表示滤波器阶数 $​其中$s_k=\mathrm{e}^{\frac{j \pi}{2R}(2k-1+R)}×\Omega_c，其中k=1,2,3,...,R$，将（4）中求出的阶数$R$和$\Omega_{\mathrm{c}}$带入即可求得低通滤波器。]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>📣 word使用中常见问题</title>
    <link href="/2023/09/13/%F0%9F%93%A3-word%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/13/%F0%9F%93%A3-word%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="📚-Word-解决MathType数学公式粘贴后上浮问题"><a href="#📚-Word-解决MathType数学公式粘贴后上浮问题" class="headerlink" title="📚 Word 解决MathType数学公式粘贴后上浮问题"></a>📚 Word 解决MathType数学公式粘贴后上浮问题</h1><p>步骤如下：</p><ol><li><p>双击公式，在Mathtype的菜单栏中选择大小，定义自己想要的大小样式等。调整完整尺寸即可，需要和正文的尺寸调整一致，以下作为参考：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">初号 -&gt;42pt<br>小初号-&gt;36pt<br>一号 -&gt;28pt<br>二号 -&gt;21pt<br>小二号-&gt;18pt<br>三号 -&gt;15.75pt<br>四号 -&gt;14pt<br>小四号-&gt;12pt<br>五号 -&gt;10.5pt<br>小五号-&gt;9pt<br>六号 -&gt;7.875pt<br>七号 -&gt;5.25pt<br></code></pre></td></tr></table></figure></li><li><p>然后选择预置→公式预置→保存成一个eqp文件文件。</p></li></ol><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0dfef3ad90f4e3298c610451abdf669~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1061&h=403&s=162761&e=png&b=f4f3f3" width="70%"/></p><ol start="3"><li>word菜单栏点击MathType-&gt;格式化公式，然后如下图进行操作即可</li></ol><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b9db39bfa304747824428946d967ec9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=655&h=584&s=66586&e=png&b=f2f2f2" width="50%"/></p><h1 id="📚-想要在公式里加空格"><a href="#📚-想要在公式里加空格" class="headerlink" title="📚 想要在公式里加空格"></a>📚 想要在公式里加空格</h1>]]></content>
    
    
    <categories>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>word</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣-银行备考过程</title>
    <link href="/2023/09/06/%F0%9F%93%A3-%E9%93%B6%E8%A1%8C%E5%A4%87%E8%80%83%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/09/06/%F0%9F%93%A3-%E9%93%B6%E8%A1%8C%E5%A4%87%E8%80%83%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="📚-备考建议"><a href="#📚-备考建议" class="headerlink" title="📚 备考建议"></a>📚 备考建议</h1><p>秋招银行岗位备考是一项重要的准备工作，以下是一些应该考虑的内容和备考建议：</p><ol><li><strong>理解银行招聘岗位要求</strong>： 首先，要仔细研究目标银行招聘的岗位要求和招聘公告，了解他们对于应聘者的基本要求和职位描述。这将有助于你明确自己是否符合岗位要求，以及在备考过程中重点关注哪些内容。</li><li><strong>考试内容</strong>： 大多数银行招聘岗位会涉及到笔试和面试两个环节。笔试一般包括数学、英语、综合素质等方面的内容。建议你针对不同银行的笔试要求，选择合适的备考材料，刷题并进行模拟考试，提高自己的应试能力。另外，英语水平也是银行招聘考试中的一个重要考察点，可以参加英语培训课程提高英语水平。</li><li><strong>面试准备</strong>： 银行面试一般包括综合面试和专业面试两个环节。在综合面试中，面试官可能会提问你的个人情况、职业规划、团队协作等方面的问题。在专业面试中，会涉及到金融知识和相关领域的问题。你需要充分了解银行业务和金融知识，阅读相关专业书籍和材料，积累面试经验，提高自己的表达能力和应变能力。</li><li><strong>个人简历和自我推销</strong>： 在准备面试时，要认真编写个人简历，突出自己的优势和特长。在面试中，要能够清晰、自信地表达自己的观点和经验，展示出你的团队合作、沟通协调等能力。同时，要准备好面试中可能被问到的问题，比如自我介绍、职业规划、为什么选择银行等问题，做好自我推销。</li><li><strong>模拟面试</strong>： 参加模拟面试可以帮助你磨练面试技巧，了解自己在面试中的不足之处，及时进行改进。可以找一些朋友或专业辅导老师帮助你进行模拟面试，提供反馈意见。</li><li><strong>关注银行行业动态</strong>： 了解银行行业的最新动态和发展趋势，这有助于你在面试中展现你对银行行业的了解和关注程度。可以通过阅读银行业的新闻报道、行业分析报告等方式来获取相关信息。</li><li><strong>时间规划</strong>： 合理安排备考时间，确保有足够的时间来准备笔试和面试。制定备考计划，每天保持一定的学习和练习时间，避免临时抱佛脚。</li></ol><p>总之，秋招银行岗位备考需要全面准备，包括笔试和面试两个环节。通过针对性的学习和练习，提高自己的知识水平和面试技巧，增加成功的机会。同时，也要不断提升自己的综合素质和职业素养，以在面试中展现出与银行岗位相匹配的特质和能力。</p><p>确定自己的目标银行是一项重要的决策，以下是一些帮助你确定目标银行的标准和考虑因素：</p><ol><li>个人兴趣和职业目标：首先要考虑自己的兴趣和职业目标。不同的银行可能有不同的业务领域和发展机会，你需要确定自己是否对这些领域感兴趣，并是否与你的职业目标相符。</li><li>银行的声誉和排名：了解银行的声誉和排名可以帮助你评估它的稳定性和信誉。一些知名的银行在金融界有着良好的声誉，可能更容易提供稳定的职业发展机会。</li><li>银行的业务领域：不同的银行可能有不同的业务领域，如零售银行、企业银行、投资银行等。你需要确定自己对哪个领域更感兴趣，并寻找相关的银行。</li><li>地理位置：银行的地理位置也是一个考虑因素。你需要确定自己是否愿意在特定地区或城市工作，然后选择目标银行。</li><li>薪资和福利：薪资和福利是一个重要的考虑因素。不同银行可能提供不同的薪资水平和福利待遇，你需要根据自己的经济需求和生活方式来选择。</li><li>发展机会：了解银行是否提供良好的职业发展机会，包括培训、晋升和跨部门机会。这可以帮助你确定是否能够在银行建立长期职业生涯。</li><li>文化和价值观：银行的文化和价值观也是一个重要的考虑因素。你需要确保自己与目标银行的文化和价值观相符，以确保工作环境的适应性。</li><li>网络和关系：在选择目标银行时，也可以考虑自己是否有相关的人脉和关系，这可能有助于你更容易地进入银行业。</li></ol><p>总之，确定目标银行需要考虑个人兴趣、职业目标、银行的声誉、业务领域、地理位置、薪资福利、发展机会、文化价值观和人脉关系等因素。综合考虑这些因素，选择最适合自己的目标银行，有助于实现职业发展目标和个人满意度。</p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>银行备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 求职的测评题分析</title>
    <link href="/2023/09/05/%F0%9F%93%A3-%E6%B1%82%E8%81%8C%E7%9A%84%E6%B5%8B%E8%AF%84%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/2023/09/05/%F0%9F%93%A3-%E6%B1%82%E8%81%8C%E7%9A%84%E6%B5%8B%E8%AF%84%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>题型：图像推理</p><p>数量关系、判断推理、资料分析、性格测试</p><p>图形推理：</p><p>口诀：</p><p>​曲称似整封</p><p>​点线面角素</p><p>​直接向位移</p><ul><li><p>对称</p></li><li><p>曲线</p><ul><li>定性分析：是曲是直，还是有曲有直</li><li>定量分析：曲线的数量</li></ul></li><li><p>一笔画</p></li></ul><p>总结：</p><p>​题型：外部规整、图形分开</p><p>每日一练：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19c0fb88394d424a9954cdbd4ae7c59e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=805&h=310&s=146425&e=png&b=fafafa"  width="70%"/></p><p>分析：图3是中心对称的，图4不对称，C选择有曲线，思考方向：过一下曲线相关的知识，还可以关注图像修改（有曲有直），发现每幅图都是有曲有直，剩下CD，考虑定量分析，从面开始数，因为简单。每个图像都有4个面，C有5个面，D有4个面，正确为D</p><p>曲线知识如下：</p><ul><li>定性分析：是曲是直，还是有曲有直</li><li>定量分析：曲线的数量</li></ul><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24186882393240788c3367524068baaa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=860&h=414&s=180879&e=png&b=fbfbfb"  width="70%"/></p><p>分析：图3是田的变形，图6是日的变形，田和日是一笔画的特征图，所以图1去掉封闭图像可以1笔画出来，接着往后数，图2是2笔，图3是2，图4是1，图5是2，图6是1，最终选D</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96d211353f4444d59a11cc0c17f7ff46~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=688&h=394&s=153517&e=png&b=f8f8f8" width="70%"/></p><p>【分析】外部轮廓是规整（多边形）的，两个方向：数轮廓数、内外数量的运算。</p><p>1.数外部轮廓分别为：3 4 ？ 6 7，所以答案应该有5个边，从BC里选</p><p>2.数内外数量（三个方向）：数内部的面、点、线条</p><p>根据图2感觉不会数面和线条，这里就数焦点：</p><p>外部的交点：64？5没数</p><p>内部的交点：34？67，明显内部的交点为5，最终选B</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40c173d6359444de8f58935403cccf9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=673&h=377&s=86198&e=png&b=fafafa"  width="70%"/></p><p>【分析】图形左右分开的，这里右边又是比较简单的，所以先看右边，右边的图形又是内外分开的，除了第三个图形有一个交点。然后内部有一个交点，排除BC，然后看图形的对称性，最后选D</p><p>遇到图形分离题，我们可以分开分析，然后遇到有一处有规律，就不需要关注其他的了。</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4960ac7493574231ac2df15c942b9bfe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=773&h=330&s=121436&e=png&b=fafafa"  width="70%"/></p><p>2个思考方向：</p><p>​1.只有两个元素组成，考察数量换算，结果成规律</p><p>​2.黑色实心，基本不会数点线面，不对称，往小元素中思考。</p><p>将U设为1，向下为2，最后的结果是：1 2 3 4 5 ？,问号为6就行，最终选A</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3aa36b92ff24a7dba625028469cf1fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=840&h=450&s=108862&e=png&b=fcfcfc"  width="70%"/></p><p>【分析】这里的思路从定性和定量还有封面来进行分析，不封闭不能数面，定性：对称、曲直、上下结构等、开闭，加减同异</p><p>最后数笔画数：第一行;2+4 &#x3D; 6，第二行 6 + 4 &#x3D; 10，所以第三行：4 + 8 &#x3D; 12，最终选A</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23c5627c9bf40889659695e9878c827~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=757&h=320&s=125415&e=png&b=fafafa" width="70%"/></p><p>【分析】很明显在结构</p><p>很明显的提示：除了图2其他都是内外分开的，图4提示直角，所以数一数内外的直角，</p><p>外部直角：012345，最终选B</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a89b329e07d4ed79d60b0484e50d17e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=807&h=304&s=106168&e=png&b=fbfbfb"  width="70%"/></p><p>【分析】不对称、有曲有直（×），点线面（×）</p><p>无思路的时候，从最简单或最复杂的图入手，从图8入手，不对称、可以考面和曲直，这里数面吧</p><p>九宫格每一行的面加一起&#x3D;8，所以？应该是2个面，选D</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ce39f2ae5904ed5a3124e4a4a24f333~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=849&h=257&s=164897&e=png&b=f9f9f9"  width="70%"/></p><p>【分析】数内外交点：</p><p>外：344334，选B</p><p>内：52</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc46a4052dd46d3a71ab70603620c7a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=767&h=377&s=150920&e=png&b=f9f9f9"  width="70%"/></p><p>【分析】点线面（×）</p><p>阴影：</p><p>​定性：相似图像、阴影图像特征（对称）</p><p>​定量：</p><p>​面积、周长、</p><p>​直角、</p><p>​不规则的阴影把整个图分成几块、</p><p>​叠加</p><p>①轴对称②内部的黑块数&#x3D;外部黑块数，最终选C</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c6b89016ac24ed78228b5d213e6b757~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=921&h=669&s=182754&e=png&b=fbfbfb"  width="70%"/></p><p>算直角（×）：223356</p><p>【分析】</p><p>定性：</p><p>​端点所在位置：平行、相交、垂直</p><p>​方向：相同、相反</p><p>定量：直角</p><p>垂直垂直平行平行垂直平行，所以选C</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce741d95dce24fafad646bc8e0dad3fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=592&h=283&s=123537&e=png&b=f9f9f9" width="70%"/></p><p>【分析】纯曲线，选A</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/454e51faeed94e3ba4e3c2fdf79bd3ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=857&h=285&s=137517&e=png&b=f9f9f9" alt="image.png"  width="70%"/></p><p>【分析】</p><p>有圆有直线：</p><p>定性：相切</p><p>定量：切点和交点数</p><p>圆内直线不出头，就先数圆内的交点，出头就数圆内的点线面，圆内有12345？，该是6面，所以选A</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a51cd86d1db1456f90c092d88198aa06~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1027&h=451&s=198217&e=png&b=f9f9f9" width="70%"/></p><p>【分析】</p><p>直线曲线：</p><p>定性：方向，端点位置</p><p>定量：面数、交点数</p><p>直线的方向，可以排除B。面数，都是三个面，选D</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3e1af4c20d4f309e6eb48c48f521f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=534&h=543&s=168863&e=png&b=fafafa"  width="50%"/></p><p>【分析】有曲有直</p><p>内部交点数：110001，选B</p><p>自己的考虑选B，但是正确答案选A，因为这里有圆和三角形，这里的规律必须涉及这两个，所以看直角，第一个直角里是圆，这里推理下去：圆三角圆三角圆三角，所以最终选A</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a3b5edbf1384624ad001814cec0e70f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=627&h=299&s=99464&e=png&b=fafafa" width="70%"/></p><p>【分析】有曲有直，有对称性，选A</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc394b30dfb436ea9021cd63a44c1c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1693&h=582&s=499272&e=png&b=fbfbfb"  width="70%"/></p><p>【分析】两个图重叠，不同的地方为黑色，选A</p><h1 id="📚-小黑点的图："><a href="#📚-小黑点的图：" class="headerlink" title="📚 小黑点的图："></a>📚 小黑点的图：</h1><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c3e405eb5a4149b5fd5f551165b54a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=824&h=298&s=168337&e=png&b=fafafa"  width="70%"/></p><p>10 9 10 9 10 选B</p><p>【分析】思路：</p><ol><li>对称性</li><li>数图形数量（部分数、笔画数）</li><li>链接方式：黑白块</li><li><strong>九宫格：黑白运算，加减同异</strong></li><li>移动：黑色相对比较少，数量相对比较固定；内外分开看</li></ol><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d578ad67859f4a6baa8f37e08df1b320~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=343&s=164691&e=png&b=f7f7f7"  width="70%"/></p><p>【分析】数量、<strong>移动</strong></p><p>第一个图往左移动1格得到第二个图，第二个图往下移动两格得到第三个图，所以？应该是往下移动两格的图，得到A</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbaa3d6533954c41a3323c67f930ebca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=648&h=300&s=156642&e=png&b=f9f9f9" width="70%"/></p><p>【分析】</p><p>定性：移动、对称、<strong>连接</strong>、相邻比较</p><p>定量：黑球数&#x3D;白球数，可以排除B</p><p>这里将相同颜色球进行连接，可以发现全都是垂直关系，所以选C</p><p><a href="https://www.bilibili.com/video/BV1h8411D7oV/?spm_id_from=333.788&vd_source=94d2cdd20c6d4a2ab076b4fda45b3865">图形推理21天刷题计划–第三天（你有收获吗？课后别忘了把特征图和考点进一步整理哦）_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续更新中</tag>
      
      <tag>测评题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 分析实验过程</title>
    <link href="/2023/09/04/%F0%9F%93%A3-%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/09/04/%F0%9F%93%A3-%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-联邦学习过程"><a href="#1-联邦学习过程" class="headerlink" title="1.联邦学习过程"></a>1.联邦学习过程</h1><p>从main出发——&gt; fl_run（联邦学习总的训练过程）——&gt; run_fl_round（联邦学习的一轮训练）——&gt;test（每轮进行测试–测试正常样本和后门样本）——&gt;save_model（保存模型）</p><h1 id="2-联邦学习一轮训练"><a href="#2-联邦学习一轮训练" class="headerlink" title="2.联邦学习一轮训练"></a>2.联邦学习一轮训练</h1><h2 id="1-helper里能干的事情"><a href="#1-helper里能干的事情" class="headerlink" title="1.helper里能干的事情"></a>1.helper里能干的事情</h2><ol><li><p>初始化任务</p><ul><li>给params赋值</li><li><code>make_task</code> 找到运行联邦任务的py文件</li><li><code>make_synthesizer</code>找到后门攻击对应的py文件，并初始化攻击</li><li><strong>1.初始化全局模型resnet18</strong></li></ul><p>在联邦学习中初始化 ResNet-18 模型的过程与常规深度学习中的初始化过程类似。初始化 ResNet-18 模型的方法通常是<strong>随机初始化</strong>，以确保模型在各个参与方的本地训练中具有足够的随机性，以便更好地学习各自的数据。实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化 ResNet-18 模型 </span><br>resnet18 = models.resnet18(pretrained=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 随机初始化</span><br><span class="hljs-comment"># 这些参数会根据某个分布（如均匀分布或正态分布）中的随机值进行初始化</span><br></code></pre></td></tr></table></figure></li><li><p>保存模型</p></li><li><p>保存断点</p></li></ol><h2 id="2-run-fl-round中干的事情"><a href="#2-run-fl-round中干的事情" class="headerlink" title="2.run_fl_round中干的事情"></a>2.<code>run_fl_round</code>中干的事情</h2><ol><li>加载全局模型和局部模型</li><li>随机选择参与者（可能包括恶意参与者）：fl_task文件中</li><li>创建一个新的权重累积字典</li><li>接着每个参与者在本地训练全局模型，得到上传更新</li><li>然后更新全局模型</li></ol><h2 id="3-全局模型参数和本地模型参数"><a href="#3-全局模型参数和本地模型参数" class="headerlink" title="3.全局模型参数和本地模型参数"></a>3.全局模型参数和本地模型参数</h2><p>1.初始化全局模型参数</p><p>2.全局模型参数</p><p>3.本地模型参数</p><h1 id="3-对参与者进行中毒和随机选择参与者"><a href="#3-对参与者进行中毒和随机选择参与者" class="headerlink" title="3.对参与者进行中毒和随机选择参与者"></a>3.对参与者进行中毒和随机选择参与者</h1><h2 id="1-随机选择10个客户端"><a href="#1-随机选择10个客户端" class="headerlink" title="1.随机选择10个客户端"></a>1.随机选择10个客户端</h2><p><strong>实现</strong>：<code>fl_task</code>文件中<code>sample_users_for_round</code></p><p>里面的实现思路：</p><ol><li>在100个参与者中随机选择10个参与者，是从100个id中选择10个id</li><li>新建一个参与者样本列表</li><li>对于这10个用户，来查看其是否是恶意的，并对每个用户打标记（恶意和非恶意）</li><li>将打了标记的10个参与者加入参与者样本列表</li></ol><h2 id="2-给参与者打标记"><a href="#2-给参与者打标记" class="headerlink" title="2.给参与者打标记"></a>2.给参与者打标记</h2><p><strong>实现</strong>：<code>fl_task</code>文件中<code>check_user_compromised</code></p><p>里面的实现思路：</p><ol><li>先让参与者为正常参与者</li><li>根据单轮攻击还是多轮攻击中的攻击者列表来给当前参与者打标记</li><li>返回标记</li></ol><h1 id="4-参与者本地的训练过程"><a href="#4-参与者本地的训练过程" class="headerlink" title="4.参与者本地的训练过程"></a>4.参与者本地的训练过程</h1><p><strong>实现</strong>：<code>training</code>文件里</p><p>实现思路如下：</p><ol><li>将全局模型复制到本地模型中，实现：<code>fl_task</code>文件中<code>copy_params</code></li><li>选择优化器SGD-随机梯度下降算法，用于优化损失函数，实现：<code>task</code>文件中的<code>make_optimizer</code></li><li>开始本地轮次的训练：<ol><li>如果是恶意参与者，就怎么训练</li><li>如果是正常参与者，就怎么训练</li></ol></li><li>计算本地更新，<ol><li>正常参与者，实现：<code>fl_task</code>文件中<code>get_fl_update</code>。思路：本地模型—上轮全局模型</li><li>恶意参与者，在正常参与者计算过程上还会乘上一个数（fl_weight_scale），<strong>从而增大该更新的权重</strong>。实现：<code>attack</code>文件中的<code>fl_scale_update</code>。</li></ol></li><li>可以给上传更新用同态加密技术进行加密，实现：<code>fl_task</code>文件中<code>get_fl_update</code></li><li>积累权重然后记录到权重累积字典，实现：<code>fl_task</code>文件中<code>accumulate_weights</code></li><li>更新全局模型，实现：<code>fl_task</code>文件中<code>update_global_model</code></li></ol><h1 id="5-本地模型训练的过程"><a href="#5-本地模型训练的过程" class="headerlink" title="5.本地模型训练的过程"></a>5.本地模型训练的过程</h1><p><strong>实现</strong>：training.py文件中</p><p>实现的思路如下：</p><ol><li>确定损失函数：交叉熵，实现：<code>task</code>文件中的<code>make_criterion</code></li><li>开启训练模式</li><li>开始本地轮次的批次训练：<ol><li>获得当前的batch，把数据加载到设备上</li><li>梯度为0</li><li>计算损失，实现：<code>attack.py</code>中的<code>compute_blind_loss</code></li><li>将损失loss 向输入侧进行反向传播</li><li>SGD优化器对值进行更新</li><li>打印训练时期的精度和损失等info信息，实现：<code>helper.py</code>中的<code>report_training_losses_scales</code></li></ol></li></ol><h1 id="6-本地模型计算损失的过程"><a href="#6-本地模型计算损失的过程" class="headerlink" title="6.本地模型计算损失的过程"></a>6.本地模型计算损失的过程</h1><p><strong>实现</strong>：<code>attack.py</code>中的<code>compute_blind_loss</code></p><p>实现的思路如下：</p><ol><li>记录训练的任务是什么，是后门任务和正常任务</li><li>获得后门训练批次，这里是加后门攻击的过程，实现：<code>synthesizer</code>中<code>make_backdoor_batch</code></li><li>利用多梯度下降算法来计算损失和梯度，实现：<code>losses.loss_functions</code>中的<code>compute_all_losses_and_grads</code></li></ol><h2 id="1-多梯度下降算法MGDA"><a href="#1-多梯度下降算法MGDA" class="headerlink" title="1.多梯度下降算法MGDA"></a>1.多梯度下降算法MGDA</h2><p><strong>前置知识：</strong></p><p>多梯度下降算法（Multi-Gradient Descent Algorithm，简称MGDA）是一种优化算法，旨在解决多目标优化问题，也就是在一个优化问题中存在多个目标函数需要最小化或最大化的情况。MGDA 的思路是通过协调多个目标函数的优化过程，以在不同目标之间取得平衡。</p><p>下面是 MGDA 算法的基本思路：</p><ol><li><strong>多目标问题设定：</strong> 首先，确定一个多目标优化问题，其中有多个待优化的目标函数。这里是正常任务和后门任务</li><li><strong>权衡策略：</strong> 在 MGDA 中，需要定义一个<strong>权衡策略</strong>，该策略决定了如何将多个目标函数结合起来形成一个综合目标，以便进行单一的优化。这个权衡策略通常包括权重或权衡参数，用于调整不同目标函数的相对重要性。这里的权衡策略是什么？</li><li><strong>梯度计算：</strong> 对于每个目标函数，计算其相对于优化变量的梯度。这意味着对每个目标函数进行单独的梯度计算。</li><li><strong>合并梯度：</strong> 使用权衡策略将不同目标函数的梯度合并为一个综合梯度。这通常涉及将不同目标函数的梯度按照其权重进行加权求和。</li><li><strong>参数更新：</strong> 使用合并的综合梯度来更新优化变量，通常使用标准的梯度下降或其他优化方法来实现。</li><li><strong>迭代优化：</strong> 重复步骤 3 到步骤 5，直到满足停止条件（例如达到最大迭代次数或梯度阈值）。</li><li><strong>结果分析：</strong> 最终的优化结果是一个在多个目标函数下达到权衡的解决方案。</li></ol><p>MGDA 的主要挑战在于权衡策略的选择，因为不同的权衡策略可能会导致不同的最终解决方案。因此，需要根据具体问题的性质和需求来选择适当的权衡策略。</p><p>总的来说，MGDA 旨在处理多目标优化问题，通过协调不同目标函数的优化过程，寻找一个在多个目标之间取得平衡的解决方案。它在多领域的优化问题中都有应用，包括机器学习、控制系统、工程优化等领域。</p><p>以下是一个简单的例子，说明如何使用MGDA来解决一个多目标优化问题：</p><p>假设你是一家制造公司的经理，你需要决定生产两种不同的产品A和B。你有两个关键的目标：最大化产品A的利润和最大化产品B的销售量。然而，这两个目标之间存在权衡，因为提高产品A的利润可能会导致产品B的销售量下降，反之亦然。</p><p>问题设定如下：</p><ul><li>目标1：最大化产品A的利润（表示为Profit_A）</li><li>目标2：最大化产品B的销售量（表示为Sales_B）</li></ul><p>你可以使用MGDA来解决这个问题的优化过程：</p><ol><li>定义权衡策略：你需要定义一个权衡策略来决定在优化过程中分配多少资源（生产能力、广告预算等）给产品A和产品B。例如，你可以分配权重alpha给产品A的利润，权重(1-alpha)给产品B的销售量，其中alpha是一个介于0和1之间的参数，表示你对产品A和产品B的相对重要性。</li><li>梯度计算：针对每个目标函数，计算其相对于资源分配（例如生产量、广告投入等）的梯度。这将涉及计算Profit_A和Sales_B关于资源分配的梯度。</li><li>合并梯度：使用权衡策略中的权重alpha和(1-alpha)将两个目标函数的梯度加权合并为一个综合梯度。</li><li>参数更新：使用合并的综合梯度来更新资源分配的变量。这可能涉及使用标准的梯度下降或其他优化算法来更新资源分配。</li><li>迭代优化：重复步骤3和步骤4，直到达到停止条件，例如达到最大迭代次数或梯度变化很小。</li><li>结果分析：最终的优化结果是一组资源分配，这些资源分配在产品A的利润和产品B的销售量之间取得了权衡。</li></ol><p>通过调整权衡策略中的参数alpha，你可以探索不同的权衡点，以找到最适合公司目标的资源分配策略。这个例子说明了如何使用MGDA来处理多目标优化问题，并在不同目标之间进行权衡，以找到最佳解决方案。</p><p><strong>实现</strong>：<code>losses.loss_functions</code>中的<code>compute_all_losses_and_grads</code></p><p><strong>实现思路如下：</strong></p><ol><li>新建一个损失和梯度空字典</li><li>对任务进行分类：<ol><li>正常任务，实现：<code>losses.loss_functions</code>中的<code>compute_normal_loss</code></li><li>后门任务，实现：<code>losses.loss_functions</code>中的<code>compute_backdoor_loss</code></li></ol></li></ol><p>对于正常任务计算损失和梯度，思路如下：</p><ol><li>得到模型的输出</li><li>利用交叉熵计算损失</li><li></li></ol><h1 id="7-权重积累过程"><a href="#7-权重积累过程" class="headerlink" title="7.权重积累过程"></a>7.权重积累过程</h1><h1 id="8-更新全局模型过程"><a href="#8-更新全局模型过程" class="headerlink" title="8.更新全局模型过程"></a>8.更新全局模型过程</h1><h1 id="9-超参数设置"><a href="#9-超参数设置" class="headerlink" title="9.超参数设置"></a>9.超参数设置</h1><ul><li>本地学习率：$\eta&#x3D;0.01$</li><li>联邦学习的学习率：$\eta_{fl}&#x3D;10$</li></ul><h1 id="10-自己论文的符号表示"><a href="#10-自己论文的符号表示" class="headerlink" title="10.自己论文的符号表示"></a>10.自己论文的符号表示</h1><p><strong>本地符号：</strong></p><ul><li>参与者i：$c_i$</li><li></li></ul><p>FL整个过程中的符号：</p><ul><li>参与者集合：$C&#x3D;{c_1,c_2,…,c_n}$</li></ul><h1 id="11-查看模型相关信息（√）"><a href="#11-查看模型相关信息（√）" class="headerlink" title="11.查看模型相关信息（√）"></a>11.查看模型相关信息（√）</h1><p>这里先搭建一个简单的网络：一共有3层，第一层又包括2个全连接层，第三次也包括2个全连接层。</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91f9f1a58d134209b4e38f871a4aaa02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=407&h=505&s=160726&e=png&b=1d1e23" alt="image.png"  width="30%"/></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(global_model) <span class="hljs-comment"># ①直接打印整个模型</span><br><br><span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> global_model.modules():<span class="hljs-comment"># 循环读取每一层</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(layer))<span class="hljs-comment"># ② 每一层的类型</span><br>    <span class="hljs-built_in">print</span>(layer)<span class="hljs-comment"># ③ </span><br><br><span class="hljs-keyword">for</span> name, layer <span class="hljs-keyword">in</span> global_model.named_modules():<span class="hljs-comment"># 循环读取每一层，在上一层的基础上，把名字也打印出来</span><br>    <span class="hljs-built_in">print</span>(name, <span class="hljs-built_in">type</span>(layer))<span class="hljs-comment"># ④ 每一层的名字和类型</span><br>    <span class="hljs-built_in">print</span>(name, layer)<br><br><span class="hljs-keyword">for</span> name, layer <span class="hljs-keyword">in</span> global_model.named_children()：<span class="hljs-comment"># 遍历第一层，不会递归子网络</span><br><span class="hljs-built_in">print</span>(name, layer)<span class="hljs-comment"># ⑤</span><br><br><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> global_model.named_parameters()：<span class="hljs-comment"># 打印每一层的名字和参数</span><br><span class="hljs-built_in">print</span>(name, param.shape)<span class="hljs-comment"># ⑥</span><br><br><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> global_model.state_dict().item()：<span class="hljs-comment"># 将模型中参数键值以字典的方式迭代处理</span><br><span class="hljs-built_in">print</span>(name, layer.shape)<span class="hljs-comment"># ⑦</span><br></code></pre></td></tr></table></figure><p>代码①的结果为：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0feca889cb6474ba9c2cf579b1ee953~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=537&h=293&s=89757&e=png&b=1d1e23" alt="image.png"  width="50%"/></p><p>代码②的结果为：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4a83c0757da4dcda0ebdbb7623512c6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=495&h=211&s=80530&e=png&b=1d1e23" alt="image.png"  width="50%"/></p><p>代码③的结果：先打印整个，再打印每一层。递归出了每一层</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ba6e90050ef4d3c83602ca5d19bb2f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=598&h=633&s=279245&e=png&b=1d1e23" alt="image.png" width="50%" /></p><p>代码④的结果：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d7aea08535e46cf9e0ab973aa5d9a9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=525&h=213&s=93798&e=png&b=1d1e23" alt="image.png" width="50%" /></p><p>代码⑤的结果：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1042830e9524ae3b46ee1d8bccc299d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=522&h=241&s=85377&e=png&b=1d1e23" alt="image.png" width="50%" /></p><p>代码⑥的结果：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fcd4f3cf530466286ae7bd7438aa6bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=344&h=265&s=84625&e=png&b=1d1e23" alt="image.png"  width="40%"/></p><p>代码⑦的结果：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61f7d6994acb405b857a65f50587b1f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=367&h=271&s=79401&e=png&b=1d1e23" alt="image.png" width="40%" /></p><h1 id="12-同态加密"><a href="#12-同态加密" class="headerlink" title="12.同态加密"></a>12.同态加密</h1><p>实现：<code>fl_task</code>文件中<code>get_fl_update</code></p><p>查看生成的Paillier加密的公钥的具体数值：可以访问公钥对象的属性。在phe库中，公钥对象通常具有属性<code>n</code>，它代表了公钥的模数（modulus）。通过访问<code>public_key.n</code>，您可以获取生成的公钥的模数值，这是Paillier加密中的关键参数之一。这个值通常用于加密数据。请注意，这只是公钥的一部分，其他参数通常也存储在公钥对象中，但模数通常是最重要的部分。</p><h2 id="🌸-相关问题"><a href="#🌸-相关问题" class="headerlink" title="🌸 相关问题"></a>🌸 相关问题</h2><p><strong>1.通过同态加密技术加密的两个数据能够进行大小（&gt;、&lt;、&#x3D;）比较吗？</strong></p><p>答：不能直接进行对比大小，需要使用安全函数评估、协议等方法。</p><p><strong>2.同态加密中，由客户端还是服务器端生成密钥对，还是第三方生成？</strong></p><p>答：由客户端生成，因为同态加密的本质是“可用不可见”，客户端拥有重要数据，但没有计算资源，只能委托第三方提供计算服务。数据经客户端生成的公钥加密后发送给服务器端进行计算。（在有些特定的应用中，可能会涉及到使用第三方机构来生成和管理密钥对，以提供额外的安全保障或信任。这种情况下，第三方机构可能会负责生成密钥对并向客户端和服务器分发相应的密钥材料）。但一般的，你有数据，你肯定不相信别人，所以密钥对由自己生成最放心。</p><p>总结：参与方和服务器都有自己的密钥对（公钥和私钥），一般由自己生成。</p><p><strong>3.密钥对在每个参与方都是一样的吗？如果一样的话，如果有参与方是恶意的？岂不是很危险？如果是不一样的，那不一样的密钥加密的数据可以加法运算吗？</strong></p><p>答：密钥对通常是不同的，每个参与方都会有自己的密钥对，因为每个参与方需要进行不同的操作和计算，并且保持自己对密钥对的控制。数据是用公钥进行加密，如果数据方想给服务器发传递什么重要数据的话，是拿着服务器放的公钥加密的。</p><p><strong>4.参与方用自己的公钥进行加密，收到密文后用私钥进行解密，（不同公钥加密的数据不能进行计算）这个过程中不同公钥加密的密文在服务器端怎么进行聚合呢？而且服务器端的公钥和私钥有什么作用呢？</strong></p><h1 id="13-实验中的小技巧"><a href="#13-实验中的小技巧" class="headerlink" title="13.实验中的小技巧"></a>13.实验中的小技巧</h1><p>1.让代码在某一行停止，在那一行后面加<code>sys.exit(1)</code>。</p><h1 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h1>]]></content>
    
    
    <categories>
      
      <category>论文实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>backdoors101</tag>
      
      <tag>持续更新中</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 每日复习内容</title>
    <link href="/2023/09/04/%F0%9F%93%A3-%E6%AF%8F%E6%97%A5%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <url>/2023/09/04/%F0%9F%93%A3-%E6%AF%8F%E6%97%A5%E5%A4%8D%E4%B9%A0%E5%86%85%E5%AE%B9%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="2023-09-04（一）"><a href="#2023-09-04（一）" class="headerlink" title="2023-09-04（一）"></a>2023-09-04（一）</h2><p>复习内容：水平垂直居中、css中的长度单位、css中隐藏元素、深拷贝,浅拷贝和赋值、手写深拷贝、轮播图的实现思路、localstorage和sessionstorage、session和cookie、数组常用方法</p><p>1.数组常用方法：</p><ul><li>会修改原数组的方法7<ul><li>push</li><li>pop</li><li>unshift</li><li>shift</li><li>reverse</li><li>sort</li><li>splice</li></ul></li><li>不修改原数组5<ul><li>concat</li><li>join</li><li>slice</li><li>indexOf</li><li>lastIndexOf</li></ul></li><li>es6新增的方法<ul><li>forEach</li><li>map</li><li>filter</li><li>every</li><li>some</li><li>reduce</li></ul></li></ul><h1 id="2023-09-10（日）"><a href="#2023-09-10（日）" class="headerlink" title="2023-09-10（日）"></a>2023-09-10（日）</h1><p>早上复习内容：</p><p>1.HTML：<del>h5新特性、本地存储和会话存储</del>、session和cookie</p><p>2.css：<del>长度单位、居中、隐藏元素</del></p>]]></content>
    
    
    <categories>
      
      <category>每日复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续更新中</tag>
      
      <tag>每日复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 攻击实验</title>
    <link href="/2023/09/04/%F0%9F%93%A3-%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/09/04/%F0%9F%93%A3-%E6%94%BB%E5%87%BB%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>我想做哪些攻击呢？</p><p>白块、随机矩阵、高斯噪声、椒盐噪声、语义后门、模型替换后门</p><p>引入高频信号可能会改变图像的视觉外观</p><h1 id="1-pattern后门攻击"><a href="#1-pattern后门攻击" class="headerlink" title="1.pattern后门攻击"></a>1.pattern后门攻击</h1><h2 id="1-单次攻击"><a href="#1-单次攻击" class="headerlink" title="1.单次攻击"></a>1.单次攻击</h2><h2 id="2-多次攻击"><a href="#2-多次攻击" class="headerlink" title="2.多次攻击"></a>2.多次攻击</h2><h3 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h3><p>1.联邦学习的更新范数差别太大了，以至于损失值为Nan，在fl_task的get_update_norm函数中打印的范数。</p>]]></content>
    
    
    <categories>
      
      <category>论文实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>持续更新中</tag>
      
      <tag>攻击实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/03/%F0%9F%93%A3-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <url>/2023/09/03/%F0%9F%93%A3-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="📚-html-和-h5"><a href="#📚-html-和-h5" class="headerlink" title="📚 html 和 h5"></a>📚 html 和 h5</h1><h2 id="1-h5新增了哪些新特性√"><a href="#1-h5新增了哪些新特性√" class="headerlink" title="1. h5新增了哪些新特性√"></a>1. h5新增了哪些新特性√</h2><ol><li>语义化标签，例如header，footer，section，article等。 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；还新增了一些状态标签、列表标签、文本标签。</li><li>新增媒体元素，audio、video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API</li><li>新增的表单控件：calendar、date、time、email、url、search </li><li>用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的<strong>canvas</strong>元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。</li><li>新增本地存储方式：sessionStorage、localStorage。sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。</li><li>新的技术：webworker、websocket。 webworker：用于多线程编程；websocket：客户端与服务端双向数据通信协议</li></ol><h2 id="2-localstorage、sessionstorage可以跨域吗✓"><a href="#2-localstorage、sessionstorage可以跨域吗✓" class="headerlink" title="2.localstorage、sessionstorage可以跨域吗✓"></a>2.localstorage、sessionstorage可以跨域吗✓</h2><p>本地存储和会话存储都存储键值对。</p><p><strong>本地存储和会话存储的主要区别在于</strong>，<strong>在关闭浏览器后</strong>，<strong>存储在会话存储中的键值对会丢失</strong>。下面是基本的使用（两者API一样，这里列举的是会话存储）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存键值对、获取键值对</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>, <span class="hljs-string">&#x27;uiu&#x27;</span>);<br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>);<br><br><span class="hljs-comment">// 保存数组，获取数据，如果不用JSON.parse()，则得到的是字符串</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">ProgrammingLanguage</span> = [<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;GO+&#x27;</span>]<br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;favoriteProgrammingLanguage&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title class_">ProgrammingLanguage</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;favoriteProgrammingLanguage&#x27;</span>)));<br><br><span class="hljs-comment">// 清除本地存储或会话存储</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>()<br><br><span class="hljs-comment">// 移除某个键值对</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;Name1&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-本地存储和会话存储的相同点、不同点"><a href="#1-本地存储和会话存储的相同点、不同点" class="headerlink" title="1.本地存储和会话存储的相同点、不同点"></a>1.本地存储和会话存储的相同点、不同点</h3><p><strong>相同点：</strong></p><p>1、存储大小均为5M左右<br>2、<font color=red><strong>都有同源策略限制</strong></font><br>3、仅在客户端中保存，不参与和服务器的通信</p><p><strong>不同点：</strong></p><p>1、<code>生命周期</code> —— 数据可以存储多少时间</p><ul><li>localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在。</li><li>sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。</li></ul><p>2、<code>作用域</code> —— 谁拥有数据的访问权</p><ul><li>localStorage: 在同一个浏览器内，<code>同源文档</code>之间共享 localStorage 数据，可以互相读取、覆盖。</li><li>sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。</li></ul><p>为了更好的理解<code>sessionStorage</code>,我们来看个例子：</p><p>例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的<code>iframe</code>元素的话，这两个<code>iframe</code>的 sessionStorage 是可以互通的。</p><h2 id="3-cookie有哪些属性，cookie和session的区别√"><a href="#3-cookie有哪些属性，cookie和session的区别√" class="headerlink" title="3. cookie有哪些属性，cookie和session的区别√"></a>3. cookie有哪些属性，cookie和session的区别√</h2><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h3><p>Cookie是一种在客户端（通常是Web浏览器）和服务器之间传输的小型文本文件。它存储在用户的计算机上，用于跟踪、识别和存储有关用户和其与网站的互动的信息。以下是Cookie的主要特点和作用：</p><p>1、Cookie 确实非常<strong>小</strong>，它的大小限制为4KB左右</p><p>2、<strong>有状态性</strong>：Cookie使得Web服务器能够在多个请求之间保持用户状态信息，例如登录状态、购物车内容等。</p><p>3、一般由服务器生成，可设置<strong>失效时间</strong>。可以是会话级别（当用户关闭浏览器时删除）或永久性的（在指定日期之前保持有效）。如果在浏览器端生成Cookie，默认是关闭浏览器后失效。</p><p>4、每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p><p>5、<strong>存储在客户端</strong>：cookie存储在用户的计算机上，而不是服务器上。每当用户访问与Cookie相关的网站时，浏览器会将cookie发送回服务器。</p><p><strong>用法(API)</strong></p><p>服务端向客户端发送的cookie(HTTP头,不带参数)：<br><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;</code> (name可选)</p><p>服务端向客户端发送的cookie(HTTP头，带参数)：<br><code>Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2)</code></p><p>客户端设置cookie：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">document.cookie</span> = <span class="hljs-string">&quot;&lt;cookie-name&gt;=&lt;cookie-value&gt;;(可选参数1);(可选参数2)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>可选参数：</strong></p><p>下图是Chrome浏览器中的Cookie截图，属性分别有<strong>Name</strong>、<strong>Value</strong>、<strong>Domain</strong>、<strong>Path</strong>、<strong>Expires&#x2F;Max-age</strong>、<strong>Size</strong>、<strong>HttpOnly</strong>、<strong>Secure</strong>、<strong>SameSite</strong>和<strong>Priority</strong>。</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ffd6fde7194438bf2f2c92a8480f5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1187&h=92&s=14975&e=png&b=f8f8f8"  width="80%"/></p><p><code>Domain=&lt;domain-value&gt;</code>：指定cookie可以送达的主机域名，若一级域名设置了则二级域名也能获取。也就是决定在向该域发送请求时是否携带此Cookie，Domain的设置是对子域生效的，如Domain设置为 .a.com,则b.a.com和c.a.com均可使用该Cookie，但如果设置为b.a.com,则c.a.com不可使用该Cookie。Domain参数必须以点(“.”)开始。</p><p><code>Path=&lt;path-value&gt;</code>：指定一个URL，和<strong>Domain</strong>类似，也对子路径生效，例如指定path&#x3D;&#x2F;docs，则 ”&#x2F;docs” 、 ”&#x2F;docs&#x2F;Web&#x2F;“ 、”&#x2F;docs&#x2F;Web&#x2F;Http”均满足匹配条件。如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 &#x2F;b&#x2F;,而Cookie2的Path为 &#x2F;b&#x2F;c&#x2F;,则在a.com&#x2F;b页面时只可以访问Cookie1，在a.com&#x2F;b&#x2F;c页面时，可访问Cookie1和Cookie2。Path属性需要使用符号“&#x2F;”结尾。</p><p><code>Expires/Max-age</code>：<br>    <code>Expires</code>和<code>Max-age</code>均为Cookie的有效期，<code>Expires</code>是该Cookie被删除时的时间戳，格式为GMT,若设置为以前的时间，则该Cookie立刻被删除，并且该时间戳是服务器时间，不是本地时间！若不设置则默认页面关闭时删除该Cookie。<br>    <code>Max-age</code>也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，若Max-age设置为0，则立刻失效，设置为负数，则在页面关闭时失效。Max-age默认为 -1。</p><p><code>HttpOnly</code>：<strong>HttpOnly</strong>值为 <em>true</em> 或 <em>false</em>,若设置为<em>true</em>，则不允许通过脚本document.cookie去更改这个值，同样这个值在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。</p><p><code>Secure</code>：<strong>Secure</strong>为Cookie的安全属性，若设置为<em>true</em>，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。</p><p><code>SameSite</code>SameSite用来限制第三方 Cookie，从而减少安全风险。它有3个属性，分别是：</p><p>​Strict：Scrict最为严格，完全禁止第三方Cookie，跨站点时，任何情况下都不会发送Cookie</p><p>​Lax：Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p><p>​None：网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p><p><strong>关闭SameSite的方法</strong></p><ul><li>操作方法谷歌浏览器地址栏输入：chrome:&#x2F;&#x2F;flags&#x2F;</li><li>找到：SameSite by default cookies、Cookies without SameSite must be secure设置上面这两项设置成 Disable</li></ul><p><code>Priority</code><br>优先级，chrome的提案，定义了三种优先级，Low&#x2F;Medium&#x2F;High，当cookie数量超出时，低优先级的cookie会被优先清除。在360极速浏览器和FireFox中，不存在Priority属性，不清楚在此类浏览器中设置该属性后是否生效。</p><p>示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Set-Cookie: <span class="hljs-attribute">sessionid</span>=aes7a8; HttpOnly; <span class="hljs-attribute">Path</span>=/<br><br>document.cookie = <span class="hljs-string">&quot;KMKNKK=1234;Sercure&quot;</span><br></code></pre></td></tr></table></figure><p>可选前缀：<br><code>__Secure-</code>：以<code>__Secure-</code>为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）</p><p><code>__Host-</code>：以<code>__Host-</code>为前缀的cookie，必须与secure属性一同设置，同时必须应用于安全页面（即使用HTTPS）。必须不能设置domian属性（这样可以防止二级域名获取一级域名的cookie），path属性的值必须为”&#x2F;“。</p><p>前缀使用示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">复制代码Set-Cookie: <span class="hljs-attribute">__Secure-ID</span>=123; Secure; <span class="hljs-attribute">Domain</span>=example.com<br>Set-Cookie: <span class="hljs-attribute">__Host-ID</span>=123; Secure; <span class="hljs-attribute">Path</span>=/<br><br>document.cookie = <span class="hljs-string">&quot;__Secure-KMKNKK=1234;Sercure&quot;</span><br>document.cookie = <span class="hljs-string">&quot;__Host-KMKNKK=1234;Sercure;path=/&quot;</span><br></code></pre></td></tr></table></figure><p><strong>cookie的作用：</strong></p><ol><li>会话管理：最常见的用途之一是在Web应用程序中管理用户会话。通过Cookie，服务器可以跟踪用户是否已登录，以及用户的会话状态。</li><li>个性化体验：网站可以使用Cookie来存储用户的首选项和设置，以便在用户返回时提供个性化的体验。</li><li>购物车和电子商务：Cookie可用于存储购物车中的商品信息，使用户能够在购物过程中添加和删除商品。</li><li>跨页面跟踪：Cookie可以用于跟踪用户在网站上的活动，例如分析用户行为、广告定位和用户流量分析。</li><li>认证和授权：Cookie常用于存储会话令牌，以验证用户身份并授权其访问受限资源。</li><li>跟踪用户：虽然涉及隐私问题，但Cookie也被用于跟踪用户的互联网活动，以便广告商和网站可以提供更有针对性的广告和内容。</li></ol><p>需要注意的是，由于Cookie涉及到用户隐私和安全问题，因此网站和应用程序必须谨慎处理Cookie，遵守隐私法规，并提供适当的控制选项供用户管理其Cookie设置。</p><h3 id="2-Session"><a href="#2-Session" class="headerlink" title="2.Session"></a>2.Session</h3><p><strong>基本概念</strong></p><p>Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。</p><p>在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。</p><p>大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个SessionID，以后每次请求把这个会话ID发送到服务器</p><p><strong>与Cookie的关系与区别：</strong></p><p>1、<code>Session</code>是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中，<code>Cookie</code>是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p><p>2、<code>Cookie</code>的<code>安全性</code>一般，他人可通过分析存放在本地的<code>Cookie</code>并进行<code>Cookie</code>欺骗。在安全性第一的前提下，选择<code>Session</code>更优。重要交互信息比如权限等就要放在<code>Session</code>中，一般的信息记录放<code>Cookie</code>就好了。 </p><p>3、单个<code>Cookie</code>保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个<code>Cookie</code>。 当访问增多时，<code>Session</code>会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用<code>Cookie</code>。 </p><p>4、<code>Session</code>的运行依赖<code>Session ID</code>，而<code>Session ID</code>是存在 Cookie 中的。也就是说，如果浏览器禁用了<code>Cookie</code>,<code>Session</code>也会失效（但是可以通过其它方式实现，比如在<code>url</code>中传递<code>Session ID</code>,即sid&#x3D;xxxx）。</p><h1 id="📚-css-c3"><a href="#📚-css-c3" class="headerlink" title="📚 css+c3"></a>📚 css+c3</h1><h2 id="1-长度单位有哪些？√"><a href="#1-长度单位有哪些？√" class="headerlink" title="1.长度单位有哪些？√"></a>1.长度单位有哪些？√</h2><p>A：答案如下：这里写了8个</p><ul><li><a href="https://www.w3school.com.cn/cssref/css_units.asp">CSS中的长度单位</a></li><li>CSS 有几种表示长度的不同单位。许多 CSS 属性接受“长度”值，诸如 <code>width</code>、<code>margin</code>、<code>padding</code>、<code>font-size</code> 等。长度是一个后面跟着长度单位的数字，诸如 <code>10px</code>、<code>2em</code> 等。</li><li>绝对单位有：<ul><li>px 像素：我们的电脑屏幕是由一个一个“小点”组成的，每个“小点”，就是一个像素（px）。 一个像素的大小主要取决于显示器的分辨率，相同面积不同分辨率的显示屏，其像素点大小就不相同。 像素点越小，呈现的内容就越清晰、越细腻。</li><li>cm 厘米：可以用在网页设计，但是不太精细</li><li>nm 纳米</li></ul></li><li>相对单位有：<ul><li>em：相对于<strong>font-size</strong>的大小，即为font-size的倍数。如果当前元素没有font-size，则往上一级一层一层的找，如果在根元素都没有找到，则选择浏览器默认的font-size。</li><li>rem：相对<strong>根元素</strong>的字体大小，即html的font-size</li><li>%：相对于<strong>父元素</strong>的某些属性</li><li>vm：相对于视口宽度大小的1%，1vm&#x3D;视口宽度*1%</li><li>vh：相对于视口高度大小的1%，1vm&#x3D;视口高度*1%</li><li>vmin：1vmin &#x3D; 1vw 或 1vh，以较小者为准。</li><li>vmax：1vmax &#x3D; 1vw 或 1vh，以较小者为准。</li></ul></li></ul><p>查看视口宽度的宽度：<code>console.log(document.documentElement.clientWidth)</code></p><h2 id="2-如何实现水平垂直居中？√"><a href="#2-如何实现水平垂直居中？√" class="headerlink" title="2.如何实现水平垂直居中？√"></a>2.如何实现水平垂直居中？√</h2><p>如果要在父元素中实现水平垂直居中：</p><ul><li><p>子元素为行内元素&#x2F;行内块元素：（可以将行内元素和行内块元素当做文本处理）</p><ul><li>水平：<code>text-align:center</code></li><li>垂直：父元素设置行号：<code>line-height=height</code>，每个子元素加上：<code>vertical-align:middle</code><ul><li>如果想要实现绝对的垂直居中，可以让父元素的字体大小为0，因为vertical-align本就是受字体大小的影响</li></ul></li></ul></li><li><p>子元素为块元素：</p><ul><li><p>①使用<code>margin</code>，子元素需要高度</p><ul><li>水平：子元素设置<code>margin:0 auto</code></li><li>垂直：子元素设置<code>margin-top:(父元素内容-子元素盒子总高) / 2  </code></li></ul></li><li><p>②使用绝对定位（有3种）</p><ul><li><p>绝对定位+位移</p><ul><li><p>父元素设置相对定位</p></li><li><pre><code class="JavaScript">position: absolute;left: 50%;top: 50%;            transform: translate(-50%, -50%);<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- 绝对定位+`<span class="hljs-attribute">margin</span>`：<span class="hljs-number">2</span>种<br><br>  - ```css<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>:<span class="hljs-number">0</span><br>    margin: auto;<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="css">position: absolute;left: 50%;/*负的一半width*/margin-left: -25px; <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- ③ 弹性布局：<span class="hljs-number">2</span>种<br><br>  - 方式二：父容器开启 <span class="hljs-attribute">flex</span> 布局，随后子元素 <span class="hljs-attribute">margin</span>: auto <br><br>  - 加在父元素<br><br>    - ```JavaScript<br>      display: flex; <br>      <span class="hljs-attribute">justify-content</span>: center; <br>      <span class="hljs-attribute">align-items</span>: center;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul></li></ul><h2 id="3-CSS中隐藏元素有几种实现方式？√"><a href="#3-CSS中隐藏元素有几种实现方式？√" class="headerlink" title="3.CSS中隐藏元素有几种实现方式？√"></a>3.<strong>CSS</strong>中隐藏元素有几种实现方式？√</h2><p>参考：[css隐藏元素的六种方法_css hidden_muzidigbig的博客-CSDN博客](<a href="https://blog.csdn.net/muzidigbig/article/details/80967143#:~:text=css%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%85%AD%E7%A7%8D%E6%96%B9%E6%B3%95">https://blog.csdn.net/muzidigbig/article/details/80967143#:~:text=css隐藏元素的六种方法</a> 1 display%3Anone (通过隐藏盒子属性，脱标) 2 visibility%3Ahidden (通过隐藏盒子属性，不脱标) 3,(通过裁剪盒子，不脱标) 6 position%3Aabsolute%3B与clip%3Arect (0px 0px 0px 0px)配合 (通过裁剪绝对定位的盒子，脱标))</p><p>A：方式如下：</p><ul><li><p>① visibility: hidden </p><ul><li>特点：可以隐藏元素，占位</li></ul></li><li><p>② display：none</p><ul><li>特点：不占位</li></ul></li><li><p>③ 给元素加hidden属性，这是html5中的全局属性</p><ul><li>特点：和display一样，不占位</li></ul></li><li><p>④ opacity: 0</p><ul><li>特点：占位</li></ul></li><li><p>⑤ 绝对定位：</p><ul><li>主要是将其移出屏幕，优点：既能响应，也不影响布局</li><li><pre><code class="JavaScript">position：relative;left:-99999px;top:-90999px;<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">  <br>- ⑥ <span class="hljs-attribute">z-index</span><br>  - 特点：不占据空间<br>  - ```JavaScript<br>    <span class="hljs-selector-class">.hide</span>&#123;<br>        <span class="hljs-attribute">position</span>:absolute;<br>        <span class="hljs-attribute">z-index</span>:-<span class="hljs-number">1000</span>;<span class="hljs-comment">/* 不占据空间，无法点击 */</span><br>    &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>⑦ 位移:</p><ul><li>特点：占据空间</li><li><code>transform: scale(0,0)/* 占据空间，无法点击 */</code></li></ul></li></ul> <table>    <tr>        <th>方法比较</th>        <th>visibility: hidden</th>        <th>opacity: 0</th>        <th>overflow:hidden;</th>        <th>绝对定位</th>        <th>位移</th>        <th>z-index</th>        <th>display:none</th>        <th>加hidden属性</th>    </tr>    <tr>        <td>是否占位？</td>        <td>√</td>        <td>√</td>        <td>√</td>        <td>√</td>        <td>√</td>        <td>×</td>        <td>×</td>        <td>×</td>    </tr>    <tr>        <td>性能</td>        <td>会引起重绘，不会引起回流</td>        <td>只造成本元素重绘，性能消耗较少</td>        <td>用来隐藏元素溢出部分，无法响应点击事件</td>        <td></td>        <td></td>        <td></td>        <td>无法响应事件，引起页面回流与重绘，性能消耗大</td>        <td></td>    </tr></table><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6a89c749c884a578e3552abc83d033f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1368&h=436&s=204522&e=png&a=1&b=d8dbda" alt="image.png"  width="80%"/></p><h2 id="4-css的常见布局方式"><a href="#4-css的常见布局方式" class="headerlink" title="4.css的常见布局方式"></a>4.css的常见布局方式</h2><p>在这里总结一下CSS中的布局技巧，说明每个布局的应用场景并给出小案例。在CSS中的布局技巧有：浮动、定位、弹性盒子布局、grid布局、表格布局等。这里我们根据单列布局、两列布局和三列布局的标准来进行展开：</p><h3 id="🏵-单列布局"><a href="#🏵-单列布局" class="headerlink" title="🏵 单列布局"></a>🏵 单列布局</h3><p>在常见的单列布局中，常见的有两种：</p><ul><li>上中下等宽</li><li>上下等宽、中间内容区偏窄</li></ul><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0efc5ede358048069eadf936e7793458~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1234&h=834&e=jpg&b=ffffff" width="50%" /></p><p>下面是单列布局的实现过程</p><p><strong>实现第一种方式</strong>：可以将 <code>header</code> , <code>content</code>, <code>footer</code> 统一设置相等宽度，然后设置 <code>margin:0 auto</code> 即可实现居中：</p><p><strong>实现第二种方式</strong>：可以将 <code>header</code> 和 <code>footer</code> 的宽度设置为100%，然后设置内容宽度稍窄一些，然后对内容区进行居中即可：</p><p>以下是实现单列布局第一种方式的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- html结构代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- css代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">header</span>&#123; </span><br><span class="language-css">     <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto; </span><br><span class="language-css">     <span class="hljs-attribute">max-width</span>: <span class="hljs-number">960px</span>; </span><br><span class="language-css">     <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>; </span><br><span class="language-css"></span><br><span class="language-css">    &#125; </span><br><span class="language-css">    <span class="hljs-selector-class">.content</span>&#123; </span><br><span class="language-css">     <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; </span><br><span class="language-css">     <span class="hljs-attribute">max-width</span>: <span class="hljs-number">960px</span>; </span><br><span class="language-css">     <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>; </span><br><span class="language-css"></span><br><span class="language-css">    &#125; </span><br><span class="language-css">    <span class="hljs-selector-class">.footer</span>&#123; </span><br><span class="language-css">     <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; </span><br><span class="language-css">     <span class="hljs-attribute">max-width</span>: <span class="hljs-number">960px</span>; </span><br><span class="language-css">     <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>; </span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以下是实现单列布局第二种方式的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- html结构代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- css代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">header</span>&#123; </span><br><span class="language-css">     <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>; </span><br><span class="language-css">     <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>; </span><br><span class="language-css"></span><br><span class="language-css">    &#125; </span><br><span class="language-css">    <span class="hljs-selector-class">.content</span>&#123; </span><br><span class="language-css">     <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; </span><br><span class="language-css">     <span class="hljs-attribute">max-width</span>: <span class="hljs-number">960px</span>; </span><br><span class="language-css">     <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>; </span><br><span class="language-css"></span><br><span class="language-css">    &#125; </span><br><span class="language-css">    <span class="hljs-selector-class">.footer</span>&#123; </span><br><span class="language-css">     <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;</span><br><span class="language-css">     <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>; </span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>应用场景：</p><p>目前淘宝、知乎等的首页就是采用单列布局。</p><h3 id="🏵-两列布局"><a href="#🏵-两列布局" class="headerlink" title="🏵 两列布局"></a>🏵 两列布局</h3><p>两列布局是一列固定宽度，另一列自适应宽度。<br>实现方式有：</p><ul><li>浮动</li><li>定位</li><li>弹性布局</li><li>grid布局</li></ul><p>🌸 浮动</p><p>效果图如下：</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ae9a1cccf445ee8e06eb8f6ab01989~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1640&h=627&e=png&b=e6a0e6" width="50%" /><p>该图是左列固定宽度，右边是自适应宽度，具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- html结构代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- css代码 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: skyblue;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.right</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">230</span>, <span class="hljs-number">160</span>, <span class="hljs-number">230</span>);</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在采用浮动布局时需要注意，浮动会带来一些副作用：比如浮动元素的父元素高度会塌陷，会影响后面兄弟元素的位置。正是因为有这些副作用，因此还需要清除浮动，方法有很多，下面列举的都可以用来清除浮动影响：</p><p>方案一： 给父元素指定高度。</p><p>方案二： 给父元素也设置浮动，带来其他影响。</p><p>方案三：给父元素设置 overflow:hidden 。</p><p>方案四：在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both 。</p><p>方案五：给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;&#x3D;&#x3D;&gt; 推荐使用</p><p>上面代码是给父元素设置高度来解决。</p><p>🌸定位</p><p>通过相对定位和绝对定位实现，需要<strong>三个div</strong>，其中一个div是父容器，包含两个子元素。<br>给父容器设置相对定位是因为可以让其设置绝对定位的子元素相对它进行移动；</p><p>两个子元素设置绝对定位，给上边的子元素设置宽度，下边的子元素设置left,值为上边子元素的宽度，再设置right:0。  给上边的子元素设置绝对定位可以让下边的子元素跟它在同一行。</p><h3 id="🏵-三列布局"><a href="#🏵-三列布局" class="headerlink" title="🏵 三列布局"></a>🏵 三列布局</h3><p>1.圣杯布局</p><p>2.双飞翼布局</p><h1 id="📚-js和js进阶"><a href="#📚-js和js进阶" class="headerlink" title="📚 js和js进阶"></a>📚 js和js进阶</h1><h2 id="1-js取整的方法，parseInt第二个参数是什么-（√）"><a href="#1-js取整的方法，parseInt第二个参数是什么-（√）" class="headerlink" title="1.js取整的方法，parseInt第二个参数是什么?（√）"></a>1.js取整的方法，parseInt第二个参数是什么?（√）</h2><p>1、丢弃小数部分，保留整数部分：</p><pre><code class="hljs">parseInt(d);Math.trunc(d); </code></pre><p>两者的区别：parseInt 常常接收一个字符串作为参数，而 Math.trunc 则可以接收一个数字参数，所以如果要对数字取整，还是建议使用 Math.trunc。使用 parseInt 的时候，如果你传入的不是字符串，比如传入一个数字，parseInt 会先调用数字的 toString() 方法。</p><blockquote><p>【知识点】parseInt()方法：字符串转数字</p><p>parseInt接收两个参数：</p><ul><li>第一个参数<code>string</code>：要被解析的字符串，如果不是字符串会被转换，忽视空格符</li><li>第二个参数<code>radix</code>：要解析的数字的基数。该值介于2~36之间。默认值为10，表示十进制。<strong>这个参数表示将前面的字符从radix进制转化为十进制</strong><ul><li>1.在没有指定基数，或者基数为0的情况下，parseInt()会根据<code>string</code>参数来判断数字的基数。<ul><li>如果字符串<code>string</code>以”0x”或者”0X”开头, 则基数是16 (16进制).</li><li>如果字符串<code>string</code>以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。</li><li>如果字符串<code>string</code>以其它任何值开头，则基数是10 (十进制)。</li></ul></li><li>2.如果<code>radix</code>在<code>2 ~ 36之外</code>会返回NaN。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 例1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>));  <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 例2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>));  <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 例3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>));  <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 例4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 例5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">123</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 结果为38</span><br></code></pre></td></tr></table></figure><p><strong>解析如下</strong>：</p><ul><li><strong>例1</strong>： <code>parseInt</code>里面有两个参数，第二个参数是8，表示要将<code>八进制</code>的3转换为十进制的结果，八进制中有3，转化为十进制还是3，所以返回结果为3</li><li><strong>例2</strong>： <code>parseInt</code>里面有两个参数，第二个参数是2，表示要将<code>二进制</code>的3转化为十进制，额…，不好意思，二进制中并没有3，所以返回<code>NaN</code></li><li><strong>例3</strong>： <code>parseInt</code>里面有两个参数，第二个参数是0，根据规则1，默认就是十进制，直接返回3</li><li><strong>例4</strong>： <code>parseInt</code>里面有两个参数，第二个参数是1，根据规则2，1在<code>2 ~ 36之外</code>，直接返回<code>NaN</code>。</li><li><strong>例5</strong>： <code>parseInt</code>里面有两个参数，第二个参数是5，表示要将<code>五进制</code>的123转化为十进制，结果为38 &#x3D;&gt; (<code>1*5^2 + 2*5^1 + 3*5^0 = 38</code>)</li></ul></blockquote><p>2、向上取整，有小数就整数部分加1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 11.1取整后得到12；</span><br><span class="hljs-comment">// -11.1取整后得到-11。</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(d);<br></code></pre></td></tr></table></figure><p>3、向下取整，正数舍弃小数位，负数整数位减一：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">11.1取整后得到11；<br><br><span class="hljs-string">-11</span>.1取整后得到<span class="hljs-string">-12</span>。<br><br>Math.floor(d);<br></code></pre></td></tr></table></figure><p>4、四舍五入：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Math.round(d)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="2-数组转字符串、字符串转数组（√）"><a href="#2-数组转字符串、字符串转数组（√）" class="headerlink" title="2.数组转字符串、字符串转数组（√）"></a>2.数组转字符串、字符串转数组（√）</h2><h3 id="一、数组转字符串（3种方法）"><a href="#一、数组转字符串（3种方法）" class="headerlink" title="一、数组转字符串（3种方法）"></a>一、数组转字符串（3种方法）</h3><p>同样是数组转字符串，toString()，toLocaleString()，join()，join(’,’)的区别是什么？</p><p>JavaScript 允许数组与字符串之间相互转换。其中 Array 方法对象定义了 3 个方法，可以把数组转换为字符串，如表所示。</p><table><thead><tr><th>数组方法</th><th>说明</th></tr></thead><tbody><tr><td>toString()</td><td>将数组转换成一个字符串</td></tr><tr><td>toLocaleString()</td><td>把数组转换成本地约定的字符串</td></tr><tr><td>join()</td><td>将数组元素连接起来以构建一个字符串</td></tr></tbody></table><p><strong>1. join()方法用于把数组中的所有元素放入一个字符串</strong></p><p>元素是通过指定的分隔符进行分隔的</p><table><thead><tr><th>join()指定的分隔符</th><th>说明</th></tr></thead><tbody><tr><td>join()</td><td>可理解为直接变成字符串，默认逗号分隔</td></tr><tr><td>join(‘’）</td><td>空连接</td></tr><tr><td>join(’ ，’)或者 join(’ - ‘)或者 join(’ 。’)</td><td>中间这个逗号是手动添加的，也可以改成别的比如、。! -等等都可以</td></tr></tbody></table><p><strong>2. toString()方法可把一个逻辑值转换为字符串，并返回结果</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> str = arr.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//把数组转换为字符串</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> str); <span class="hljs-comment">//返回字符串string，说明是字符串类型</span><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 10,true,30,40</span><br><span class="hljs-comment">// string</span><br></code></pre></td></tr></table></figure><p>toString()方法不可以指定分隔符，但是我们可以通过replace()方法指定替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = arr.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/,/gi</span>, <span class="hljs-string">&quot;-&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str); <span class="hljs-comment">// 10-true-30-40</span><br></code></pre></td></tr></table></figure><p>**3. toLocaleString()**：把数组转换成本地约定的字符串</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>];<br><span class="hljs-keyword">var</span> str = arr.toLocaleString(); <span class="hljs-comment">//把数组转换为字符串</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(str); <span class="hljs-comment">// 10,true,30,40</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> str); <span class="hljs-comment">//返回字符串string，说明是字符串类型</span><br><br></code></pre></td></tr></table></figure><h3 id="二、字符串转数组（2种方法）"><a href="#二、字符串转数组（2种方法）" class="headerlink" title="二、字符串转数组（2种方法）"></a>二、字符串转数组（2种方法）</h3><table><thead><tr><th>字符串方法</th><th>说明</th></tr></thead><tbody><tr><td>split() 方法</td><td>将字符串转换成一个数组</td></tr><tr><td>扩展运算符（…）</td><td>es6里面的扩展运算符</td></tr></tbody></table><p><strong>1.split() 方法用于把一个字符串分割成字符串数组</strong></p><p>同样是用于把一个字符串分割成字符串数组，split(’,’)，split()，split(‘’）的区别是什么？</p><table><thead><tr><th>split()方法</th><th>说明</th></tr></thead><tbody><tr><td>split(“,”)</td><td>以逗号分隔的转换为数组</td></tr><tr><td>split(‘’）空字符串</td><td>每个字符之间都会被分割</td></tr><tr><td>split()</td><td>可理解为直接变成数组</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;aa, bb, cc, dd&quot;</span>;<br><span class="hljs-keyword">var</span> str1 = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);<br><span class="hljs-keyword">var</span> str2 = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">var</span> str3 = str.<span class="hljs-title function_">split</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1); <span class="hljs-comment">// [ &#x27;aa&#x27;, &#x27; bb&#x27;, &#x27; cc&#x27;, &#x27; dd&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str2); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;b&#x27;, &#x27;b&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;c&#x27;, &#x27;c&#x27;, &#x27;,&#x27;, &#x27; &#x27;,&#x27;d&#x27;, &#x27;d&#x27;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str3); <span class="hljs-comment">// [ &#x27;aa, bb, cc, dd&#x27; ]</span><br></code></pre></td></tr></table></figure><p><strong>2.扩展运算符</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;aa,bb,cc,dd&quot;</span>;<br><span class="hljs-keyword">var</span> str1 = [...str];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str1); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;a&#x27;, &#x27;,&#x27;, &#x27;b&#x27;,&#x27;b&#x27;, &#x27;,&#x27;, &#x27;c&#x27;, &#x27;c&#x27;,&#x27;,&#x27;, &#x27;d&#x27;, &#x27;d&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="3-数组常用方法（√）"><a href="#3-数组常用方法（√）" class="headerlink" title="3.数组常用方法（√）"></a>3.数组常用方法（√）</h2><h3 id="一、改变原数组的方法7个"><a href="#一、改变原数组的方法7个" class="headerlink" title="一、改变原数组的方法7个"></a>一、改变原数组的方法7个</h3><p>总结：</p><p>push、pop、unshift、shift、sort、reverse、splice</p><p>join、concat、slice、indexOf、lastIndexOf</p><p>新增：forEach、map、filter、every、some、reduce、find、Array.from、includes</p><p><strong>1.push()末尾添加数据</strong></p><p><strong>语法:</strong> <strong>数组名.push(</strong> <strong>数据)</strong></p><p><strong>作用:</strong> 就是往数组末尾添加数据</p><p><strong>返回值:</strong> 就是这个数组的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br>res = arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[10,20,30,40,20]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p><strong>2.pop() 末尾处删除数据</strong></p><p><strong>语法:</strong> <strong>数组名.pop()</strong></p><p><strong>作用:</strong> 就是从数组的末尾删除一个数据</p><p><strong>返回值:</strong> 就是你删除的那个数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>] <br>res =arr.<span class="hljs-title function_">pop</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[10,20,30]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//40</span><br></code></pre></td></tr></table></figure><p><strong>3.unshift() 头部添加数据</strong></p><p><strong>语法:</strong> <strong>数组名.unshift(</strong> <strong>数据)</strong></p><p><strong>作用:</strong>  就是在数组的头部添加数据</p><p><strong>返回值:</strong> 就是数组的长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br> res=arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">99</span>)<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[99,10,20,30,40]</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><p><strong>4.shift()头部删除数据</strong></p><p><strong>语法:</strong> <strong>数组名.shift()</strong></p><p><strong>作用:</strong>  头部删除一个数据</p><p><strong>返回值:</strong>  就是删除掉的那个数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //shift">//shift复制代码 var arr = [10, 20, 30, 40]<br> res=arr.shift()<br> console.log(arr);[20,30,40]<br> console.log(res);10<br></code></pre></td></tr></table></figure><p><strong>5.reverse() 翻转数组</strong></p><p><strong>语法:</strong> <strong>数组名.reverse()</strong></p><p><strong>作用:</strong> 就是用来翻转数组的</p><p><strong>返回值:</strong> 就是翻转好的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //reverse">//reverse复制代码var arr = [10, 20, 30, 40]<br>res=arr.reverse()<br>console.log(arr);//[40,30,20,10]<br>console.log(res);//[40,30,20,10]<br></code></pre></td></tr></table></figure><p><strong>6.sort() 排序</strong></p><p><strong>语法一</strong>: 数组名.sort()   会排序，会按照位排序</p><p><strong>语法二</strong>: 数组名.sort(function (a,b) {return a-b})  会正序排列</p><p><strong>语法三</strong>: 数组名.sort(function (a,b) {return b-a})  会倒序排列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">63</span>, <span class="hljs-number">48</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">75</span>, <span class="hljs-number">69</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>]<br>arr.<span class="hljs-title function_">sort</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 11, 2, 23, 4, 48, 5, 63, 69, 75]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span>(a-b)&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [2,  4,  5, 11, 23, 48, 63, 69, 75     ]</span><br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span>(b-a)&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [75, 69, 63, 48, 23, 11,  5,  4,  2]</span><br></code></pre></td></tr></table></figure><p><strong>7.splice()  截取数组</strong></p><p><strong>语法一</strong>: 数组名.splice(开始索引,多少个)</p><p>​作用: 就是用来截取数组的</p><p>​返回值: 是一个新数组 里面就是你截取出来的数据</p><p><strong>语法二</strong>: 数组名.splice(开始索引,多少个,你要插入的数据)</p><p>​作用: 删除并插入数据</p><p>​注意: 从你的开始索引起</p><p>​返回值: 是一个新数组 里面就是你截取出来的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //splice()">var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,2)<br>console.log(arr); // [ 2, 5, 4, 75 ]<br>console.log(res); // [ 63, 48 ]<br>//******************************<br>//splice() 语法二<br>var arr = [2, 63, 48, 5, 4, 75]<br>res = arr.splice(1,1,99999,88888)<br>console.log(arr); // [2, 99999, 88888, 48, 5, 4, 75]<br>console.log(res); // [ 63 ]<br></code></pre></td></tr></table></figure><h3 id="二、不改变原数组的方法5个"><a href="#二、不改变原数组的方法5个" class="headerlink" title="二、不改变原数组的方法5个"></a>二、不改变原数组的方法5个</h3><p><strong>1.concat() 合并数组</strong></p><p><strong>语法:</strong> <strong>数组名.concat(</strong> <strong>数据)</strong></p><p><strong>作用:</strong>  合并数组的</p><p><strong>返回值:</strong>  一个新的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>res = arr.<span class="hljs-title function_">concat</span>(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;小敏&quot;</span>,<span class="hljs-number">50</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [10, 20, 10, 30, 40, 50, 60]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// [10, 20, 10, 30, 40, 50, 60, 20,&quot;小敏&quot;,50]</span><br></code></pre></td></tr></table></figure><p><strong>2.join()  数组转字符串</strong></p><p><strong>语法:</strong> **数组名.join(‘**<strong>连接符’)</strong></p><p><strong>作用:</strong> 就是把一个数组转成字符串</p><p><strong>返回值:</strong>  就是转好的一个字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>res = arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;+&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// var arr = [10, 20, 10, 30, 40, 50, 60]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 10+20+10+30+40+50+60</span><br></code></pre></td></tr></table></figure><p><strong>3.slice() 截取数组的一部分数据</strong></p><p><strong>语法:</strong> <strong>数组名.slice(</strong> <strong>开始索引,</strong> <strong>结束索引)</strong></p><p><strong>作用:</strong> 就是截取数组中的一部分数据</p><p><strong>返回值:</strong> 就是截取出来的数据 放到一个新的数组中</p><p><strong>注意:</strong> 包前不好后 包含开始索引不包含结束索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs //slice">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.slice(1,4)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // [20, 10, 30]<br></code></pre></td></tr></table></figure><p><strong>4.indexOf() 从左检查数组中有没有这个数值</strong></p><p><strong>语法一:</strong> <strong>数组名.indexOf(要查询的数据)</strong></p><p><strong>作用:</strong> 就是检查这个数组中有没有该数据，如果有就返回该数据<strong>第一次</strong>出现的索引，如果没有返回 -1</p><p><strong>语法二:</strong> <strong>数组名.indexOf(要查询的数据, 开始索引)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //indexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // 0<br>//*************************************<br>//indexOf  语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.indexOf(10,1)<br>console.log(arr); // [10, 20, 10, 30, 40, 50, 60]<br>console.log(res); // 2<br></code></pre></td></tr></table></figure><p><strong>5.lastIndexOf() 从右检查数组中有没有这个数值</strong></p><p><strong>语法一:</strong> <strong>数组名.indexOf(</strong> <strong>要查询的数据)</strong></p><p><strong>作用:</strong> 就是检查这个数组中有没有该数据</p><p>如果有就返回该数据<strong>第一次</strong>出现的索引</p><p>如果没有返回 -1</p><p><strong>语法二:</strong> <strong>数组名.lastIndexOf(</strong> <strong>要查询的数据,</strong> <strong>开始索引)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //lastIndexOf">var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50)<br>console.log(arr) <br>console.log(res);<br>//*************************************<br>//lastIndexOf 语法二<br>var arr = [10, 20, 10, 30, 40, 50, 60]<br>res = arr.lastIndexOf(50,4)<br>console.log(arr)<br>console.log(res);<br></code></pre></td></tr></table></figure><h3 id="三、ES6新增的数组方法7个（都不改变原数组）"><a href="#三、ES6新增的数组方法7个（都不改变原数组）" class="headerlink" title="三、ES6新增的数组方法7个（都不改变原数组）"></a>三、ES6新增的数组方法7个（都不改变原数组）</h3><p><strong>1. forEach()  用来循环遍历数组</strong></p><p><strong>语法</strong>: 数组名.forEach(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来循环遍历数组的 代替了我们的for</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs //forEach">var arr = [1, 2, 3, 4, 5]<br>var res = arr.forEach(function (item, index, arr) &#123;<br>    console.log(item, &quot;------&quot;, index, &quot;-------&quot;, arr);<br>&#125;)<br>// 输出：<br>// 1 ------ 0 ------- [ 1, 2, 3, 4, 5 ]<br>// 2 ------ 1 ------- [ 1, 2, 3, 4, 5 ]<br>// 3 ------ 2 ------- [ 1, 2, 3, 4, 5 ]<br>// 4 ------ 3 ------- [ 1, 2, 3, 4, 5 ]<br>// 5 ------ 4 ------- [ 1, 2, 3, 4, 5 ]<br></code></pre></td></tr></table></figure><p><strong>2.map()  映射数组</strong></p><p><strong>语法:</strong> 数组名.map(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来数组映射</p><p><strong>返回值:</strong> 必然是一个映射完毕的数组；这个数组和原数组长度一样，不改变原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">return</span> item*<span class="hljs-number">1000</span><br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><span class="hljs-comment">// 返回值：</span><br><span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-comment">// [ 1000, 2000, 3000, 4000, 5000 ]</span><br></code></pre></td></tr></table></figure><p><strong>3.filter()  过滤数组</strong></p><p><strong>语法</strong>: 数组名.filter(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 用来过滤数组的</p><p><strong>返回值</strong>: 如果有就是过滤(筛选)出来的数据 保存在一个数组中；如果没有返回一个空数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs //filter">var arr = [1, 2, 3, 4, 5]<br>var res = arr.filter(function (item) &#123;<br>    return item &gt; 2<br>&#125;)<br>console.log(arr);<br>console.log(res);<br>// 返回值：<br>// [ 1, 2, 3, 4, 5 ]<br>// [ 3, 4, 5 ]<br></code></pre></td></tr></table></figure><p><strong>4.every()  判断数组是不是满足所有条件</strong></p><p><strong>语法</strong>: 数组名.every(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 主要是用来判断数组中是不是 每一个 都满足条件。只有所有的都满足条件返回的是true，只要有一个不满足返回的就是false</p><p><strong>返回值</strong>: 是一个布尔值 </p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //every">//every复制代码var arr = [1, 2, 3, 4, 5]<br>var res = arr.every(function (item) &#123;<br>    return item &gt; 0<br>&#125;)<br>console.log(res);//打印结果  true<br></code></pre></td></tr></table></figure><p><strong>5.some() 数组中有没有满足条件的</strong></p><p><strong>语法</strong>: 数组名.some(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 主要是用来判断数组中是不是 每一个 都满足条件。只有有一个满足条件返回的是true，只要都不满足返回的就是false</p><p><strong>返回值</strong>: 是一个布尔值</p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //some">var arr = [1, 2, 3, 4, 5]<br>var res = arr.some(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res); //true<br></code></pre></td></tr></table></figure><p><strong>6.find() 用来获取数组中满足条件的第一个数据</strong></p><p><strong>语法</strong>: 数组名.find(function (item,index,arr) {})</p><ul><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 用来获取数组中满足条件的数据</p><p><strong>返回值</strong>: 如果有 就是满足条件的第一个数据；如果没有就是undefined</p><p><strong>注意</strong>: 要以return的形式执行返回条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs //find">var arr = [1, 2, 3, 4, 5]<br>var res = arr.find(function (item) &#123;<br>    return item &gt; 3<br>&#125;)<br>console.log(res) //4<br></code></pre></td></tr></table></figure><p><strong>7.reduce() 累加后的效果</strong></p><p><strong>语法</strong>: 数组名.reduce(function (prev,item,index,arr) {},初始值)</p><ul><li>prev :一开始就是初始值 当第一次有了结果以后；这个值就是第一次的结果</li><li>item : 这个表示的是数组中的每一项</li><li>index : 这个表示的是每一项对应的索引</li><li>arr : 这个表示的是原数组</li></ul><p><strong>作用</strong>: 就是用来累加的</p><p><strong>返回值</strong>: 就是累加后的结果</p><p><strong>注意</strong>: 以return的形式书写返回条件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> res = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prev, item</span>) &#123;<br>    <span class="hljs-keyword">return</span> prev *= item<br>&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">//120</span><br></code></pre></td></tr></table></figure><p><strong>8.<code>Array.from()</code></strong></p><p><code>Array.from()</code>方法可以将可迭代对象转换为新的数组。</p><ul><li>函数可接受3个参数（后两个参数可以没有）：<ul><li>第一个表示将被转换的可迭代对象(如果只有一个参数就是把形参转变成数组)</li><li>第二个是回调函数，将对每个数组元素应用该回调函数，然后返回新的值到新数组，</li><li>第三个是回调函数内this的指向。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-title function_">double</span>(<span class="hljs-params">n</span>) &#123;<br>        <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arr, <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">double</span>(n);<br>&#125;, obj)); <span class="hljs-comment">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure><p>9.<code>includes()</code> </p><p>参数：数值 ——– 返回值：<code>true/false</code></p><p><code>includes()</code>方法——是查看数组中是否存在这个元素，存在就返回true,不存在就返回false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">22</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>]<br><span class="hljs-keyword">let</span> ary = arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">22</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ary)<br></code></pre></td></tr></table></figure><h2 id="4-深拷贝和浅拷贝、赋值（√）"><a href="#4-深拷贝和浅拷贝、赋值（√）" class="headerlink" title="4.深拷贝和浅拷贝、赋值（√）"></a>4.深拷贝和浅拷贝、赋值（√）</h2><p><strong>其他问法</strong>：数组深拷贝方法</p><p>参考：<a href="https://juejin.cn/post/7134970746580762637?searchId=20230903212139B6B7DB5B5E108D8F55BD">前端面试 第三篇 js之路 深拷贝与浅拷贝 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/6994453856063062053#heading-6">JavaScript深拷贝和浅拷贝看这篇就够了 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/7020348927643746312">前端数组、对象的浅拷贝和深拷贝 - 掘金 (juejin.cn)</a>、<a href="https://juejin.cn/post/6844904197595332622">浅拷贝与深拷贝 - 掘金 (juejin.cn)</a></p><p><strong>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。</strong></p><p><strong>浅拷贝</strong>: ① 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。② 如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以<strong>如果其中一个对象改变了这个地址里的内容，就会影响到另一个对象</strong>。（只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃）；</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715c839f767d41dc98669788c9705772~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=277&s=82226&e=png&b=fdf9f8" alt="image.png"  width="50%"/></p><p><strong>深拷贝</strong>: ① 创建一个新对象，将原始对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，新旧对象不共享同一块内存，且修改新对象不会影响原对象（深拷贝采用了在堆内存中申请新的空间来存储数据，这样可以避免指针悬挂）</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5058d13e4a548a3b40e0ae074ffbb92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=373&s=84518&e=png&b=fefdfd" alt="image.png"  width="50%"/></p><p>【默认情况下基本数据类型（number，string，null，undefined，boolean）都是深拷贝。】</p><p><font color=red><strong>赋值和深&#x2F;浅拷贝的区别</strong></font>，比较的前提都是<strong>针对引用类型</strong>：</p><ul><li>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li><li>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。</li></ul><table>    <tr>        <th  colspan=4 align="center">对原始数据的影响</th>    </tr>    <tr>        <th width=100px bgcolor=skyblue></th>        <th bgcolor=skyblue>和原数据是否指向同一对象</th>        <th bgcolor=skyblue>第一层数据为基本数据类型</th>        <th bgcolor=skyblue>原数据包含子对象（引用数据类型）</th>    </tr>    <tr>        <td>赋值</td>        <td>是</td>        <td>赋值后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>        <td>赋值后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>    </tr>    <tr>        <td>浅拷贝</td>        <td>否</td>        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>        <td>浅拷贝后的数据改变，<strong><mark>会</mark></strong>使原数据一同改变</td>    </tr>    <tr>        <td>深拷贝</td>        <td>否</td>        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>        <td>浅拷贝后的数据改变，<strong><mark>不会</mark></strong>使原数据一同改变</td>    </tr></table><p>举例：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 对象赋值</span><br>let obj1 = &#123;<br> <span class="hljs-keyword">name</span>: <span class="hljs-string">&quot;Chen&quot;</span>,<br> age: <span class="hljs-number">18</span>,<br> hobby: [<span class="hljs-string">&quot;see a film&quot;</span>, <span class="hljs-string">&quot;write the code&quot;</span>, <span class="hljs-string">&quot;play basketball&quot;</span>, <span class="hljs-string">&quot;tourism&quot;</span>],<br>&#125;;<br>let obj2 = obj1;<br>obj2.<span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;Forever&quot;</span>;<br>obj2.hobby[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;swim&quot;</span>;<br>obj2.hobby[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;alpinism&quot;</span>;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;obj1===&gt;&quot;</span>, obj1);<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;obj2===&gt;&quot;</span>, obj2);<br><span class="hljs-comment">// 输出为：</span><br>obj1===&gt; &#123;<br>  <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  hobby: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br>obj2===&gt; &#123;<br>  <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  age: <span class="hljs-number">18</span>,<br>  hobby: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br><span class="hljs-comment">// 结论：对象中基本属性和引用属性都发生改变</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 浅拷贝</span><br><span class="hljs-keyword">let</span> obj1 = &#123;<br> <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Chen&quot;</span>,<br> <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br> <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&quot;see a film&quot;</span>, <span class="hljs-string">&quot;write the code&quot;</span>, <span class="hljs-string">&quot;play basketball&quot;</span>, <span class="hljs-string">&quot;tourism&quot;</span>],<br>&#125;;<br><span class="hljs-keyword">let</span> obj3 = &#123; ...obj1 &#125;;<br>obj3.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Forever&quot;</span>;<br>obj3.<span class="hljs-property">hobby</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;swim&quot;</span>;<br>obj3.<span class="hljs-property">hobby</span>[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;alpinism&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj1===&gt;&quot;</span>, obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj3===&gt;&quot;</span>, obj3);<br><span class="hljs-comment">// 输出为：</span><br>obj1===&gt; &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Chen&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">hobby</span>: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br>obj3===&gt; &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Forever&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>  <span class="hljs-attr">hobby</span>: [ <span class="hljs-string">&#x27;see a film&#x27;</span>, <span class="hljs-string">&#x27;swim&#x27;</span>, <span class="hljs-string">&#x27;alpinism&#x27;</span>, <span class="hljs-string">&#x27;tourism&#x27;</span> ]<br>&#125;<br><span class="hljs-comment">// 结论：浅拷贝时，对象中基本属性不变，引用属性发生变化</span><br></code></pre></td></tr></table></figure><p><strong>注意：当拷贝对象只有一层的时候，是深拷贝</strong></p><h3 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h3><ol><li><strong>Object.assign()</strong></li></ol><p>参考资料：<a href="https://juejin.cn/post/6844903984675684366">Object.assign()基本用法、注意点、用法</a></p><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象<code>source</code>复制到目标对象。</p><p><strong>参数：</strong>第一个参数是目标对象，后面的参数都是源对象。</p><p><strong>返回：</strong>目标对象<code>target</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<br><span class="hljs-keyword">const</span> source = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span> &#125;<br><span class="hljs-keyword">const</span> returnedTarget = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source)<br>target <span class="hljs-comment">// &#123; a: 1, b: 4, c: 5 &#125;</span><br>returnedTarget  <span class="hljs-comment">// &#123; a: 1, b: 4, c: 5 &#125;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><p>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p></li><li><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p></li><li><p>如果该参数不是对象，则会先转成对象，然后返回。由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为第一个参数，就会报错。如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，<u>除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</u></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit">let obj = &#123;a: <span class="hljs-number">1</span>&#125;<br>Object.<span class="hljs-built_in">assign</span>(obj, undefined) === obj // <span class="hljs-literal">true</span><br>Object.<span class="hljs-built_in">assign</span>(obj, <span class="hljs-literal">null</span>) === obj   // <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">const</span> v1 = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">const</span> v2 = <span class="hljs-literal">true</span><br><span class="hljs-keyword">const</span> v3 = <span class="hljs-number">10</span><br><span class="hljs-keyword">const</span> obj = Object.<span class="hljs-built_in">assign</span>(&#123;&#125;, v1, v2, v3)<br>obj // &#123; <span class="hljs-string">&quot;0&quot;</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>: <span class="hljs-string">&quot;c&quot;</span> &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p></li></ul><p>数组的处理 <code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<span class="hljs-comment">// [4, 5, 3]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.assign</code>把数组视为属性名为 <code>0、1、2</code> 的对象，因此源数组的 <code>0</code> 号属性<code>4</code>覆盖了目标数组的 <code>0</code> 号属性<code>1</code>。</p><ol start="2"><li><strong>函数库lodash的_.clone方法</strong></li></ol><p>该函数库也有提供_.clone用来做浅拷贝，后面我们会再介绍利用这个库实现深拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">clone</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>扩展运算符…</strong></li></ol><p>提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Kobe&#x27;</span>, <span class="hljs-attr">address</span>:&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">100</span>&#125;&#125;<br><span class="hljs-keyword">let</span> obj2= &#123;... obj1&#125;<br>obj1.<span class="hljs-property">address</span>.<span class="hljs-property">x</span> = <span class="hljs-number">200</span>;<br>obj1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj2&#x27;</span>,obj2) <span class="hljs-comment">// obj2 &#123; name: &#x27;Kobe&#x27;, address: &#123; x: 200, y: 100 &#125; &#125;</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>Array.prototype.concat()</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;kobe&#x27;</span><br>    &#125;];<br><span class="hljs-keyword">let</span> arr2 = arr.<span class="hljs-title function_">concat</span>();    <br>arr2[<span class="hljs-number">2</span>].<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;wade&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">//[ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>Array.prototype.slice()</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27; kobe&#x27;</span><br>    &#125;];<br><span class="hljs-keyword">let</span> arr3 = arr.<span class="hljs-title function_">slice</span>();<br>arr3[<span class="hljs-number">2</span>].<span class="hljs-property">username</span> = <span class="hljs-string">&#x27;wade&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span><br></code></pre></td></tr></table></figure><h3 id="深拷贝的实现："><a href="#深拷贝的实现：" class="headerlink" title="深拷贝的实现："></a>深拷贝的实现：</h3><ol><li><strong>JSON.parse(JSON.stringify())</strong></li></ol><p>利用<code>JSON.stringify</code>将对象转成JSON字符串，再用<code>JSON.parse</code>把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p><ol start="2"><li><strong>函数库lodash的_.cloneDeep方法</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>jQuery.extend()方法</strong></li></ol><p>jquery 有提供一個<code>$.extend</code>可以用来做 Deep Copy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">$.<span class="hljs-title function_">extend</span>(deepCopy, target, object1, [objectN])  <span class="hljs-comment">//第一个参数为true,就是深拷贝</span><br><br><span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = $.<span class="hljs-title function_">extend</span>(<span class="hljs-literal">true</span>, &#123;&#125;, obj1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">b</span>.<span class="hljs-property">f</span> === obj2.<span class="hljs-property">b</span>.<span class="hljs-property">f</span>); <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>手写递归方法</strong></li></ol><p>递归方法实现深度拷贝原理：<strong>遍历 对象或数组 直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong>。</p><p>有种特殊情况需注意就是对象存在<strong>循环引用</strong>的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。关于这块如有疑惑，请仔细阅读<code>ConardLi大佬</code><a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000020255831">如何写出一个惊艳面试官的深拷贝?</a>这篇文章。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 如果是null或者undefined我就不进行拷贝操作</span><br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj);<br>  <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj);<br>  <span class="hljs-comment">// 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> obj;<br>  <span class="hljs-comment">// 是对象的话就要进行深拷贝</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">get</span>(obj)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj);<br>  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br>  <span class="hljs-comment">// 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span><br>  hash.<span class="hljs-title function_">set</span>(obj, cloneObj);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-comment">// 实现一个递归拷贝</span><br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj;<br>&#125;<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">address</span>: &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">100</span> &#125; &#125;;<br>obj.<span class="hljs-property">o</span> = obj; <span class="hljs-comment">// 对象存在循环引用的情况</span><br><span class="hljs-keyword">let</span> d = <span class="hljs-title function_">deepClone</span>(obj);<br>obj.<span class="hljs-property">address</span>.<span class="hljs-property">x</span> = <span class="hljs-number">200</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d);<br></code></pre></td></tr></table></figure><p>数组实现深拷贝可以使用以下方法</p><ul><li>使用<code>slice()</code></li><li>使用<code>concat()</code></li><li>ES6扩展运算符[…str]</li><li>Array.from()</li></ul><h2 id="5-手写深拷贝函数-（√）"><a href="#5-手写深拷贝函数-（√）" class="headerlink" title="5.手写深拷贝函数 （√）"></a>5.手写深拷贝函数 （√）</h2><p>这里写了三种，参考资料：<a href="https://juejin.cn/post/7264208575974834231?searchId=20230904153935A317FD4976A2592BDE92#heading-8">手写深浅拷贝</a></p><ol><li>简单版（JSON）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">jobs</span>: &#123;<br>        <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;FE&#x27;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(a))<br>a.<span class="hljs-property">jobs</span>.<span class="hljs-property">first</span> = <span class="hljs-string">&#x27;native&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">jobs</span>.<span class="hljs-property">first</span>) <span class="hljs-comment">// FE</span><br></code></pre></td></tr></table></figure><ol start="2"><li>基础版（手写递归）</li></ol><p>下面是一个实现 <code>deepClone</code> 函数封装的例子，通过 <code>for in</code> 遍历传入参数的属性值，如果值是引用类型则再次递归调用该函数，如果是基础数据类型就直接复制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;<br>  <span class="hljs-attr">a</span>:&#123;<br>    <span class="hljs-attr">b</span>:<span class="hljs-number">1</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123; <br>  <span class="hljs-keyword">let</span> cloneObj = &#123;&#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;                 <span class="hljs-comment">//遍历</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[key] ===<span class="hljs-string">&#x27;object&#x27;</span>) &#123; <br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key])  <span class="hljs-comment">//是对象就再次调用该函数递归</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      cloneObj[key] = obj[key]  <span class="hljs-comment">//基本类型的话直接复制值</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-title function_">deepClone</span>(obj1);<br>obj1.<span class="hljs-property">a</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2);   <span class="hljs-comment">//  &#123;a:&#123;b:1&#125;&#125;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>进阶版（递归实现）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断一个对象是否为复杂数据类型，即对象或函数类型，且不为 null</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">isComplexDataType</span> = obj =&gt; (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;function&#x27;</span>) &amp;&amp; (obj !== <span class="hljs-literal">null</span>)<br><br><span class="hljs-comment">// 定义深拷贝函数 deepClone，接受两个参数：obj 为要进行深拷贝的目标对象，hash 为已经拷贝过的对象的哈希表（用于解决循环引用问题）</span><br><span class="hljs-keyword">const</span> deepClone = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-comment">// 1.如果目标对象是日期对象，则直接返回一个新的日期对象，避免修改原日期对象</span><br>  <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Date</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(obj)<br>  &#125;<br>  <span class="hljs-comment">// 2.如果目标对象是正则对象，则直接返回一个新的正则对象，避免修改原正则对象</span><br>  <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">RegExp</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(obj)<br>  &#125;<br>  <span class="hljs-comment">// 3.如果目标对象已经被拷贝过，则从 hash 中获取已经拷贝过的对象并返回，避免出现循环引用问题</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">has</span>(obj)) &#123;<br>    <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj)<br>  &#125;<br>  <span class="hljs-comment">// 获取目标对象的所有属性描述符</span><br>  <span class="hljs-keyword">let</span> allDesc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(obj)<br>  <span class="hljs-comment">// 创建一个新对象 cloneObj，并将其原型链指向 obj 的原型对象</span><br>  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(obj), allDesc)<br>  <span class="hljs-comment">// 将目标对象和克隆对象的映射关系存入 hash 中，用于解决循环引用问题</span><br>  hash.<span class="hljs-title function_">set</span>(obj, cloneObj)<br>  <span class="hljs-comment">// 遍历目标对象的所有属性（包括字符串类型和 Symbol 类型的属性名）</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj)) &#123; <br>    <span class="hljs-comment">// 如果目标对象的属性值是复杂数据类型（即对象或数组），则递归调用 deepClone 函数进行深拷贝，并将拷贝结果赋值给克隆对象的对应属性</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isComplexDataType</span>(obj[key]) &amp;&amp; <span class="hljs-keyword">typeof</span> obj[key] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果目标对象的属性值不是复杂数据类型，则直接将其赋值给克隆对象的对应属性</span><br>      cloneObj[key] = obj[key]<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 返回深拷贝后的新对象</span><br>  <span class="hljs-keyword">return</span> cloneObj<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-call、apply、bind的作用和区别？（√）"><a href="#6-call、apply、bind的作用和区别？（√）" class="headerlink" title="6.call、apply、bind的作用和区别？（√）"></a>6.call、apply、bind的作用和区别？（√）</h2><p>其他问法：改变this的方法，apply和call最初设计的时候为什么要设计这两个，为什么apply参数是数组call不是</p><p><font color=red>🍀 <strong>call 和 apply</strong></font></p><p><strong>作用：</strong>用来改变函数内部 <code>this</code> 的指向。</p><p><strong>特点：</strong></p><ul><li>任何函数都可以调用这两个方法，说明它们是添加在函数原型上的方法（<code>Function.prototype</code>）。</li><li>调用 <code>call</code> 和 <code>apply</code> 的函数会立即执行。<code>call</code> 和 <code>apply</code> 的返回值就是函数的返回值。</li><li>调用 <code>call</code> 和 <code>apply</code> 指向 <code>undefined</code> 或者 <code>null</code> ，会将 <code>this</code> 指向 <code>window</code>。</li><li>调用 <code>call</code> 和 <code>apply</code> 指向一个值类型， 会将 <code>this</code> 指向由它们的构造函数创建的实例。</li><li>调用 <code>call</code> 和 <code>apply</code> 指向一个引用类型， 会将 <code>this</code> 指向这个对象。</li></ul><p><strong>call 和 apply的区别</strong></p><p>除了传参的形式不同没什么区别，传给<code>fn</code>的参数写法不同：</p><ul><li><code>call</code> 接收多个参数，第一个为函数上下文也就是 <code>this</code> ，后边参数为函数本身的参数。</li><li><code>apply</code> 接收两个参数，第一个参数为函数上下文 <code>this</code>，第二个参数为函数参数只不过是通过一个 <strong>数组</strong> 的形式传入的。</li></ul><p><font color=red>🍀 <strong>bind</strong></font></p><p><strong>作用</strong>：也是用来改变函数内部 <code>this</code> 的指向。</p><p><strong>bind 和 call&#x2F;apply 的区别</strong>：</p><p><strong>1. 是否立刻执行</strong>：</p><ul><li><code>call/apply</code> 改变了函数的 <code>this</code> 上下文后 <strong>马上</strong> 执行该函数。</li><li><code>bind</code> 则是返回改变了上下文后的函数，<strong>不执行该函数</strong> 。</li></ul><p><strong>2. 返回值的区别</strong>:</p><ul><li><code>call/apply</code> 返回函数。</li><li><code>bind</code> 返回函数的拷贝，指定了 函数 的 <code>this</code> 指向，保存了函数的参数。</li></ul><h2 id="7-轮播图实现思路-（√）"><a href="#7-轮播图实现思路-（√）" class="headerlink" title="7.轮播图实现思路 （√）"></a>7.轮播图实现思路 （√）</h2><p>实现前端轮播图（也称为轮播幻灯片或轮播广告）通常涉及以下主要步骤和思路：</p><ol><li><strong>HTML结构：</strong> 首先，在HTML中创建轮播图的基本结构。通常会使用一个包含图像或内容的容器，并为每个轮播项创建一个子元素。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;carousel&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;carousel-item&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 内容或图像1 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;carousel-item&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 内容或图像2 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 更多轮播项 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>CSS样式：</strong> 使用CSS样式来定义轮播图容器的外观，包括宽度、高度、位置等。还可以设置轮播项的布局和过渡效果。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.carousel</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.carousel-item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">display</span>: none; <span class="hljs-comment">/* 隐藏所有项，除了当前活动的项 */</span><br>  <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">1s</span>; <span class="hljs-comment">/* 过渡效果 */</span><br>&#125;<br><span class="hljs-selector-class">.carousel-item</span><span class="hljs-selector-class">.active</span> &#123;<br>  <span class="hljs-attribute">display</span>: block; <span class="hljs-comment">/* 显示当前活动的项 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>JavaScript交互：</strong> 使用JavaScript来实现轮播图的交互逻辑。以下是一些常见的实现思路：<ul><li><strong>自动播放：</strong> 设置定时器，以一定的时间间隔自动切换到下一张轮播项。</li><li><strong>手动控制：</strong> 添加前进和后退按钮，以允许用户手动浏览轮播项。</li><li><strong>指示器：</strong> 创建轮播指示器，以显示当前轮播项的位置，并允许用户通过点击指示器来切换轮播项。</li><li><strong>循环播放：</strong> 当到达最后一张轮播项时，循环回到第一张。</li><li><strong>响应式设计：</strong> 确保轮播图在不同屏幕尺寸下适应，并且图像大小和数量能够自动调整。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> currentSlide = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> slides = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.carousel-item&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showSlide</span>(<span class="hljs-params">index</span>) &#123;<br>  slides[currentSlide].<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>  slides[index].<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;active&#x27;</span>);<br>  currentSlide = index;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextSlide</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> next = (currentSlide + <span class="hljs-number">1</span>) % slides.<span class="hljs-property">length</span>;<br>  <span class="hljs-title function_">showSlide</span>(next);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">prevSlide</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> prev = (currentSlide - <span class="hljs-number">1</span> + slides.<span class="hljs-property">length</span>) % slides.<span class="hljs-property">length</span>;<br>  <span class="hljs-title function_">showSlide</span>(prev);<br>&#125;<br><br><span class="hljs-comment">// 自动播放</span><br><span class="hljs-built_in">setInterval</span>(nextSlide, <span class="hljs-number">5000</span>);<br><br><span class="hljs-comment">// 手动控制按钮</span><br><span class="hljs-keyword">const</span> nextButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;next-button&#x27;</span>);<br><span class="hljs-keyword">const</span> prevButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;prev-button&#x27;</span>);<br><br>nextButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, nextSlide);<br>prevButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, prevSlide);<br></code></pre></td></tr></table></figure><p><strong>优化和性能：</strong> 对于包含大量图像的轮播图，应考虑性能优化，如懒加载图像，压缩图像大小等。</p><h2 id="8-闭包的原理，有哪些应用？（√）"><a href="#8-闭包的原理，有哪些应用？（√）" class="headerlink" title="8.闭包的原理，有哪些应用？（√）"></a>8.闭包的原理，有哪些应用？（√）</h2><p>要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。</p><ul><li>① 闭包是指函数和它所引用的外部变量之间的关联关系。② 当一个函数嵌套在另一个函数内部时，内部函数可以访问外部函数的变量。③ 如果内部函数在外部函数执行完后仍然存在，并引用了外部函数的变量，那么就形成了一个闭包。这样，外部函数的变量不会被销毁，而是继续存在于内部函数的作用域中。</li></ul><p><strong>闭包的应用</strong>：</p><ol><li><p><strong>封装和模块化</strong>：闭包可以用于创建私有变量和函数，使其不被外部访问，将相关的功能封装在一个函数内部，只暴露必要的接口给外部，从而实现封装和模块化的代码结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++count;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>2,保存状态</strong>：闭包可以用于保存函数执行时的状态，例如计数器、事件处理等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++count;<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> counterA = <span class="hljs-title function_">createCounter</span>();<br><span class="hljs-keyword">const</span> counterB = <span class="hljs-title function_">createCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counterA</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counterB</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counterA</span>()); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p><strong>3.函数柯里化</strong>：闭包可以用于函数柯里化，将一个多参数函数转化为一系列单参数函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> addFive = <span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addFive</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p><strong>4.回调函数</strong>：在异步编程中，常常会使用闭包来处理回调函数，以保持上下文和访问相关的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">url, callback</span>) &#123;<br>  <span class="hljs-comment">// 异步操作获取数据</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-string">&quot;Some data from &quot;</span> + url;<br>    <span class="hljs-title function_">callback</span>(data);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-title function_">fetchData</span>(<span class="hljs-string">&quot;https://example.com&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>5.事件处理</strong>：DOM 事件处理函数常常使用闭包来访问事件发生时的上下文信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addClickHandler</span>(<span class="hljs-params">element</span>) &#123;<br>  element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked element: &quot;</span> + element.<span class="hljs-property">id</span>);<br>  &#125;);<br>&#125;<br><span class="hljs-keyword">const</span> button1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;button1&quot;</span>);<br><span class="hljs-keyword">const</span> button2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;button2&quot;</span>);<br><span class="hljs-title function_">addClickHandler</span>(button1);<br><span class="hljs-title function_">addClickHandler</span>(button2);<br></code></pre></td></tr></table></figure><p><strong>定时器</strong>：在定时器中使用闭包可以保持定时器回调函数对特定数据的访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startTimer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    count++;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Count: &quot;</span> + count);<br>    <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">5</span>) &#123;<br>      <span class="hljs-built_in">clearInterval</span>(intervalId);<br>    &#125;<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-title function_">startTimer</span>();<br></code></pre></td></tr></table></figure><p>总之，闭包是JavaScript中强大而灵活的概念，它在许多方面都有应用，包括封装数据、模块化开发、事件处理、回调函数和定时器等。理解闭包的原理可以帮助你更好地利用它来解决各种编程问题。</p><p>但要注意，过度使用闭包可能会导致<strong>内存泄漏</strong>，因此在使用闭包时需要小心管理内存。</p><h2 id="9-手写promise"><a href="#9-手写promise" class="headerlink" title="9.手写promise"></a>9.手写promise</h2><h2 id="10-原型链的理解"><a href="#10-原型链的理解" class="headerlink" title="10.原型链的理解"></a>10.原型链的理解</h2><h2 id="11-对继承有什么了解吗？有几种方式？优劣？"><a href="#11-对继承有什么了解吗？有几种方式？优劣？" class="headerlink" title="11.对继承有什么了解吗？有几种方式？优劣？"></a>11.对继承有什么了解吗？有几种方式？优劣？</h2><h2 id="12-对异步编程有什么了解？就回调函数、Promise，async-await，具体的是指什么？"><a href="#12-对异步编程有什么了解？就回调函数、Promise，async-await，具体的是指什么？" class="headerlink" title="12.对异步编程有什么了解？就回调函数、Promise，async&#x2F;await，具体的是指什么？"></a>12.对异步编程有什么了解？就回调函数、Promise，async&#x2F;await，具体的是指什么？</h2><h2 id="13-作用域和作用域链、块级作用域（√）"><a href="#13-作用域和作用域链、块级作用域（√）" class="headerlink" title="13.作用域和作用域链、块级作用域（√）"></a>13.作用域和作用域链、块级作用域（√）</h2><blockquote><p>作用域：**全局作用域、函数作用域、块级作用域（ES6出的）</p></blockquote><p><strong>全局作用域：</strong></p><ul><li><p>全局作用域是整个 JavaScript 程序的最外层作用域。在全局作用域中声明的变量和函数可以在代码的任何地方访问，它们通常被称为全局变量和全局函数。全局作用域在整个应用程序的生命周期中存在，直到应用程序关闭或页面刷新为止。</p></li><li><p>全局作用域有一个全局对象windom，它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用</p></li><li><p>在全局作用域中：创建的变量都会作为window对象的属性，创建的方法都会作为windom的方法</p></li></ul><p><strong>函数作用域：</strong></p><ul><li><p>函数作用域是在函数内部声明的变量和函数所拥有的作用域。这意味着在函数内声明的变量只能在该函数内部访问，外部的代码无法直接访问这些变量。这有助于封装变量，防止命名冲突，并提高代码的可维护性。</p></li><li><p>调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁。每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的。在函数作用域中可以访问到全局作用域的变量。</p></li><li><p>在全局作用域中无法访问到函数作用域的变量。当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用如果没有则向上一级作用域中寻找，直到找到全局作用域。如果全局作用域中依然没有找到，则会报错ReferenceError。</p></li><li><p>在函数中要访问全局变量可以使用window对象。</p></li></ul><p><strong>块级作用域（Block Scope）</strong>：</p><ul><li>块级作用域是在 JavaScript ES6（ECMAScript 2015）引入的新概念。它使得变量在 <code>&#123; &#125;</code> 块内部声明时具有局部作用域，而不再仅限于函数作用域。块级作用域通常与 <code>let</code> 和 <code>const</code> 关键字一起使用。这有助于更细粒度地控制变量的作用域</li><li><code>if</code> 语句和 <code>for</code> 语句里面的 <code>&#123; &#125;</code> 也属于块作用域。</li></ul><p><strong>1. 作用</strong>：</p><ol><li><strong>变量封装和隔离：</strong> 作用域允许你将变量和函数封装在一个特定的区域内，以防止命名冲突和不必要的全局污染。这意味着你可以在不同的作用域中定义具有相同名称的变量或函数而不会相互干扰。</li><li><strong>变量可见性：</strong> 作用域定义了变量在代码中的可见范围。在一个作用域内声明的变量只能在该作用域内访问，而不能在外部作用域访问。这有助于控制变量的访问权限，防止不必要的外部访问和修改。</li><li><strong>生命周期管理：</strong> 作用域还控制了变量的生命周期，即它们存在的时间段。在离开作用域时，作用域内的变量通常会被销毁，从而释放内存资源。这有助于减少内存泄漏和提高代码的性能。</li><li><strong>作用域链：</strong> 作用域链是一种嵌套的结构，允许内部作用域访问外部作用域中的变量。这种机制使得函数能够访问其定义范围之外的变量，如闭包（closure）中的概念。</li><li><strong>代码组织和模块化：</strong> 作用域有助于将代码模块化，使得代码更易于组织、维护和重用。你可以将相关的变量和函数放在同一个作用域中，以创建更清晰和可维护的代码结构。</li></ol><p>总之，作用域是一种关键的编程概念，它提供了变量和函数的可见性和隔离，有助于管理变量的生命周期，同时也支持了一些高级的编程模式，如闭包。通过正确使用作用域，你可以编写更健壮、可维护和可扩展的代码。</p><p><strong>2. （不算块级作用域）有多少个作用域</strong>：n+1原则，n表示定义了几个函数，1表示全局作用域</p><p><strong>3. 作用域和执行上下文的区别：</strong></p><ul><li>区别1：<ul><li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时。</li><li>全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建的</li><li>函数执行上下文环境是在调用函数时，函数体代码执行之前创建</li></ul></li><li>区别2：<ul><li>作用域是静态的，只要函数定义好了就一直存在，且不会再变化</li><li>上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放</li></ul></li><li>联系<ul><li>上下文环境（对象）是从属于所在的作用域的</li><li>全局上下文环境&#x3D;&#x3D;》全局作用域</li><li>函数上下文环境&#x3D;&#x3D;》对应的函数作用域</li></ul></li></ul><blockquote><p>作用域链</p></blockquote><p><strong>1.理解：</strong>多个上下级关系的作用域形成的链，它的方向是从内到外的。查找变量时就是沿着作用域链来查找的。</p><p><strong>2.查找一个变量的查找规则：</strong></p><ul><li>在当前作用域下的执行上下文中查找对应的属性，如果有则返回，否则进入2；</li><li>在上一级作用域的执行上下文中查找对应的属性，如果有则返回，否则进行3；</li><li>再次执行2的相同操作，直到全局作用域，如果还是找不到就抛出找不到的异常。</li></ul><blockquote><p>块级作用域</p></blockquote><p>引入块级作用域的主要原因是提高 JavaScript 代码的可维护性、可读性和安全性。以下是引入块级作用域的一些重要原因：</p><ol><li><strong>避免变量污染（Variable Pollution）：</strong> 在传统的函数作用域中，变量通常是函数级别的，这意味着在函数内部声明的变量在整个函数内都可见，容易导致变量污染问题，特别是在嵌套函数中。块级作用域允许我们在更小的范围内声明变量，避免了不必要的变量冲突。</li><li><strong>更安全的代码：</strong> 块级作用域使得变量的作用范围更加明确和受限。这有助于减少意外的变量重写和不必要的副作用。在块级作用域内声明的变量仅在块内部可见，而不会泄漏到外部作用域。</li><li><strong>更好的内存管理：</strong> 在块级作用域中声明的变量拥有更短的生命周期。一旦块执行结束，这些变量就会被销毁，从而帮助更有效地管理内存。这对于避免内存泄漏问题非常有帮助。</li><li><strong>可读性和可维护性：</strong> 使用块级作用域可以更清晰地表达变量的作用范围，使代码更容易理解和维护。这对于大型项目和团队协作特别有价值。</li><li><strong>解决闭包问题：</strong> 在传统函数作用域中，闭包可能会导致一些意外的问题，因为函数作用域的变量在整个函数范围内可见。块级作用域可以减少闭包问题的出现。</li></ol><p>引入块级作用域的方式是使用 <code>let</code> 和 <code>const</code> 关键字来声明变量，它们具有块级作用域，而不是像 <code>var</code> 一样具有函数作用域。这样的改进使得 JavaScript 代码更加可控和可预测，有助于提高代码质量和安全性。</p><h2 id="14-事件循环（√）"><a href="#14-事件循环（√）" class="headerlink" title="14.事件循环（√）"></a>14.事件循环（√）</h2><p><strong>其他问法：</strong>给一段代码，事件循环结果输出是什么</p><p>事件循环的动画演示：<a href="https://www.bilibili.com/video/BV1RW4y147Xv/?spm_id_from=333.337.search-card.all.click&vd_source=94d2cdd20c6d4a2ab076b4fda45b3865">浏览器EventLoop事件循环机制动画演示_哔哩哔哩_bilibili</a></p><p>JS是一个单线程的动态解释性语言，需要通过JS的<a href="https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E">引擎(JS Engine)</a>进行解释(翻译)成对应的字节码、机器码然后才会运行。随着网页复杂性和性能要求的提高，JS引擎也经历了从<a href="https://zh.wikipedia.org/wiki/SpiderMonkey">SpiderMonkey</a>到<a href="https://v8.dev/">V8(由google开发)</a>的变革，而由谷歌开发的V8引擎最为出色，目前已被大多数现代浏览器等(Chrome、Edge、Safari)采用。同时JS也从以前浏览器单一的运行时(Runtime)演变到可以在服务端运行的NodeJS(基于V8)运行时，为它提供不同平台的运行时环境。</p><ul><li><strong>Runtime</strong>：由JavaScript的宿主环境提供额外的属性和方法，如浏览器提供了用户交互和一些异步任务的功能。</li><li><strong>Engine</strong>：为JavaScript解析和执行提供环境条件(类似Java虚拟机)，并完成内存分配和垃圾回收等等。</li></ul><p>JS的是通过异步回调的方式解决单线程的执行阻塞问题，虽然JS引擎是单线程的，但它的宿主环境一般都是多线程的，如通过浏览器的定时任务线程、网络线程协调执行异步回调。所以常说的EventLoop是面向宿主环境的也就是Runtime，如浏览器和NodeJS。EventLoop主要是宿主环境实现的</p><p>这里我们需要先了解下浏览器的架构，本文以Chrome浏览器作为介绍：</p><p>它是多进程和多线程的架构，其内部包括：</p><ul><li>Brower进程：提供浏览器URL、后退&#x2F;前进、调度等全局作用</li><li>网络进程：进行网络资源请求、安全策略等等</li><li>GPU进程：3D渲染、动画绘制等等</li><li>渲染进程：负责每个Tab页面加载解析，JS、CSS、DOM等相关页面和用户操作</li><li>插件进程：浏览器插件</li></ul><p>除了以上列出的进程外，还有一些其它的进程。</p><p>这里主要来说下<strong>渲染进程</strong>，它是前端开发者最必要的关注点。Chrome为每个tab页面提供一个渲染进程。渲染进程会包括很多线程：</p><ol><li>主线程：调度页面的加载解析，执行dom、css、js操作处理等等</li><li>GUI线程：负责页面的渲染</li><li>JS引擎线程：进行解析执行JS</li><li>定时器线程：处理异步定时任务</li><li>异步请求线程：进行网络请求</li><li>事件触发线程：监听执行事件callback</li><li>WebWorker线程：独立的脚本，不影响页面渲染，通常用来执行密集复杂的计算</li></ol><p>等等…</p><p>当加载页面时会从上到下解析文档，当遇到JS脚本(通常情况下)时会阻塞DOM的解析，也就是JS引擎的执行会阻塞GUI线程渲染的执行，这也符合JS是个单线程语言的特征。不过渲染进程也提供了不同的线程去处理异步任务，可以并行处理多个任务，如：定时器线程、网络请求线程等等，而不会影响页面的渲染推翻JS单线程的理念。</p><p>其实浏览器多线程执行异步任务的原理背后是基于事件驱动机制的。不同类型的事件触发不同的任务，如：点击事件、滚动事件等等。而事件循环机制(EventLoop)就是基于事件驱动机制的。当JS执行代码时，如果遇到异步代码如Ajax请求时，会交给别的线程去执行异步任务，然后主线程挂起当前任务，不会阻塞后面代码的执行。这些异步任务会由浏览器不同的线程进行负责，不会影响到主线程和JS引擎线程，当这些异步任务执行完毕后，会被存放到指定的任务队列中，等JS的执行栈中当前同步任务执行完毕后，会从这些任务队列中取出待执行的任务，而具体优先取哪一个这就是要取决于事件循环机制了。</p><p><strong>通过上面的介绍你应该会了解到浏览器的多线程其实就是让JS拥有多线程并发处理异步任务的能力，主要负责点击等事件、定时任务、网络请求、脚本执行、用户交互和页面渲染之间的的调度。</strong></p><p>JS的运行机制就是事件循环！事件循环（Event Loop）是一种处理异步操作的编程模型，通常在单线程的环境中使用，如浏览器的JavaScript引擎或Node.js。事件循环允许程序执行异步任务，而不会阻塞主线程，以确保应用程序的响应性和性能。</p><ol><li><strong>事件循环的基本原理</strong>：<ul><li>事件循环是一个持续运行的循环，它不断检查任务队列（Task Queue）中是否有待处理的任务。</li><li>任务可以是回调函数，例如定时器回调、事件处理器或Promise的<code>then</code>回调。</li><li>当任务队列中有任务时，事件循环将逐个执行这些任务，并将它们从队列中移除。</li></ul></li><li><strong>事件循环的组成部分</strong>：<ul><li><strong>调用栈（Call Stack）</strong>：用于执行同步代码，每个函数调用都会在栈上创建一个帧，帧中包含了 函数 的参数和局部变量。</li><li><strong>任务队列（Task Queue）</strong>：用于存储待处理的异步任务，包括宏任务（如setTimeout）和微任务（如Promise）。所以任务队列里有宏任务队列和微任务队列。</li><li><strong>事件触发线程</strong>：用于监听外部事件，例如鼠标点击或HTTP请求，将相关任务推送到任务队列中。（也可以理解为web APIs）</li></ul></li><li><strong>事件循环的执行流程</strong>：<ul><li>从调用栈开始，执行同步代码。</li><li>遇到异步任务（宏任务或微任务），会委托给宿主环境执行。已完成的异步任务对应的回调函数，会被加入到任务队列中等待执行。</li><li>继续执行同步代码，直到调用栈为空。</li><li>从任务队列中取任务，如果有微任务则先执行微任务，然后在执行宏任务，直到任务队列为空。</li><li>重复上述步骤。</li></ul></li></ol><p><strong>当主线程中的执行栈被清空后，JS主线程会从任务队列中读取异步任务的回调函数，放在执行栈中依次执行。这个过程是循环不断的，所以整个的这种运行机制又被称为EventLoop(事件循环)。</strong></p><p>易错点：</p><ol><li>如果是定时器任务，则会在宿主环境执行了定时器的时间之后再加入宏任务队列。比如设置1s，则会在1s后加入到宏任务队列；</li><li>promise本身是一个同步的代码(只是容器)，只有它后面调用的then()方法里面的回调才是微任务</li><li>await右边的表达式还是会立即执行,表达式之后的代码才是微任务, await微任务可以转换成等价的promise微任务分析</li><li>script标签本身是一个<code>宏任务</code>， 当页面出现多个script标签的时候，浏览器会把script标签作为宏任务来解析</li></ol><p>参考：<a href="https://blog.usword.cn/frontend/js/eventloop.html">EventLoop事件循环机制(浏览器和Node EventLoop) </a>、<a href="https://juejin.cn/post/6962806212660297758">事件循环机制（Event Loop）的基本认知 - 掘金 (juejin.cn)</a></p><h2 id="15-宏任务和微任务（√）"><a href="#15-宏任务和微任务（√）" class="headerlink" title="15.宏任务和微任务（√）"></a>15.宏任务和微任务（√）</h2><p><strong>先来了解一下三个重要的概念</strong>：<strong>主线程</strong>、<strong>微任务(micro task)<strong>、</strong>宏任务(macro task)</strong></p><p><strong>主线程</strong></p><p>所有的同步任务都是在主线程里执行的，异步任务可能会在<code>macrotask</code>或者<code>microtask</code>里面</p><ul><li><strong>同步任务：</strong> 指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</li><li><strong>异步任务：</strong> 指的是不进入主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><p><strong>微任务(micro task)</strong></p><ul><li>promise：promise本身是一个同步的代码(只是容器)，只有它后面调用的then()方法里面的回调才是微任务</li><li>async&#x2F;await：await右边的表达式还是会立即执行,表达式之后的代码才是微任务</li><li>process.nextTick(node)</li><li>mutationObserver(html5新特性)</li></ul><p><strong>宏任务(macro task)</strong></p><ul><li>script(整体代码)：script标签本身是一个<code>宏任务</code>， 当页面出现多个script标签的时候，浏览器会把script标签作为宏任务来解析</li><li>setTimeout、setInterval</li><li>setImmediate</li><li>I&#x2F;O（输入输出）</li><li>UI render</li><li>ajax</li><li>(DOM操作)： 如没有阻塞的插入元素</li><li>读取文件</li><li>navigation和history：导航和history操作</li><li>常见的键盘、鼠标、Ajax、setTimeout、setInterval、操作数据库等都属于MacroTask Source</li></ul><p>【注意】</p><ul><li><p>微任务是由ES6语法规定的</p></li><li><p>宏任务是由浏览器规定的</p></li><li><p>微任务在DOM渲染前触发，宏任务在DOM渲染后触发</p></li></ul><p>在EventLoop中的每一次循环成一个<code>tick</code>，每一次tick都会先执行同步任务，然后查看是否有微任务，将所有的微任务在这个阶段执行完，如果执行微任务阶段再次产生微任务也会把他执行完（每次tick只会有一个微任务队列），接下来会可能会进行视图的渲染，然后再从MacroTask队列中选择一个合适的任务放入执行栈执行，然后重复前面的步骤不断循环</p><p>参考资料：<a href="https://juejin.cn/post/6962806212660297758">事件循环机制（Event Loop）的基本认知 - 掘金 (juejin.cn)</a></p><h2 id="16-对象的遍历（√）"><a href="#16-对象的遍历（√）" class="headerlink" title="16.对象的遍历（√）"></a>16.对象的遍历（√）</h2><p>要遍历对象中的键值对，你可以使用不同的方法，具体取决于你的需求和 JavaScript 的版本。以下是两种常见的遍历对象键值对的方法：</p><ol><li><p><strong>使用 for…in 循环</strong>（适用于普通对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> myObject) &#123;<br>  <span class="hljs-keyword">if</span> (myObject.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>    <span class="hljs-keyword">const</span> value = myObject[key];<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;: &quot;</span> + value);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，使用 <code>hasOwnProperty</code> 来检查属性是否属于对象是为了确保不会遍历到原型链上的属性。</p></li><li><p>**使用 Object.keys() 和 forEach()**（适用于普通对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myObject = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(myObject).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> value = myObject[key];<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;: &quot;</span> + value);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这种方法使用 <code>Object.keys()</code> 获取对象的所有键，然后使用 <code>forEach()</code> 方法遍历键，以访问相应的值。</p></li><li><p><strong>使用 for…of 循环</strong>（适用于 ES6 中的 Map 和 Set，以及可迭代对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>myMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>);<br>myMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>);<br>myMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key + <span class="hljs-string">&quot;: &quot;</span> + value);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法适用于 Map、Set 和其他可迭代对象，它允许直接在循环中获取键和值。</p></li></ol><p>1 实习内容介绍，你们的分页怎么实现，假如不给你total值，你可以实现分页吗，你觉得一个分页组件的核心要素是什么（有没有佬解答一下）<br>7渲染10w条数据怎么优化，虚拟列表技术上怎么实现，闪烁怎么解决<br>8常见性能优化手段<br>9假如用户打开了你的网站，但是是白屏你怎么解决<br>10说一下hashmap，常见数据结构<br>12nodejs有没有接触<br>13你对前端的看法，你更想做前端的哪个方向</p><h1 id="📚-ES6"><a href="#📚-ES6" class="headerlink" title="📚 ES6"></a>📚 ES6</h1><h2 id="1-ES6模块化"><a href="#1-ES6模块化" class="headerlink" title="1.ES6模块化"></a>1.ES6模块化</h2><h2 id="2-Promise（√）"><a href="#2-Promise（√）" class="headerlink" title="2.Promise（√）"></a>2.Promise（√）</h2><p>Promise 是 JavaScript 中用于处理异步操作的对象。它提供了一种更结构化和可管理的方式来处理异步代码，以避免回调地狱（Callback Hell）和提高代码的可读性。</p><p><strong>异步操作有哪些？</strong>异步操作是指在程序执行过程中不会等待某个任务完成而是继续执行其他任务的一种编程模式。在计算机编程中，有许多情况下需要进行异步操作，以下是一些常见的异步操作的示例：</p><ol><li><strong>网络请求</strong>：从服务器获取数据通常需要一段时间，因此在发起网络请求后，通常会继续执行其他任务，而不会等待数据返回。</li><li><strong>文件读写</strong>：读取大文件或者写入文件都可能需要花费一定时间，因此通常以异步方式执行。</li><li><strong>定时任务</strong>：设置定时器执行某个任务，例如在一段时间后触发回调函数。</li><li><strong>事件处理</strong>：监听事件，例如点击事件、键盘事件、鼠标事件等，当事件发生时执行相关的回调函数。</li><li><strong>数据库操作</strong>：连接数据库、查询数据、写入数据等数据库操作通常是异步的。</li><li><strong>动画和多媒体处理</strong>：在网页开发中，动画和多媒体处理通常需要异步执行，以确保界面流畅性。</li><li><strong>Promise 和异步函数</strong>：使用 JavaScript 中的 Promise 和异步函数（<code>async/await</code>）来管理和处理异步操作。</li><li><strong>并发任务</strong>：同时执行多个任务，例如并发下载多个文件。</li><li><strong>外部设备交互</strong>：与外部硬件设备（例如传感器、摄像头、打印机等）通信通常是异步的。</li><li><strong>用户输入</strong>：等待用户输入数据，例如等待用户填写表单或选择选项。</li></ol><p>异步操作是现代计算机编程中不可或缺的部分，因为它们允许程序在等待某些任务完成时继续执行其他任务，从而提高了程序的响应性和性能。在异步编程中，通常使用回调函数、Promise、异步函数（<code>async/await</code>）等机制来处理异步操作，以确保正确的执行顺序和错误处理。</p><p>以下是 Promise 的详细介绍：</p><p><strong>1.Promise 的状态</strong>：</p><ul><li>Promise 有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。</li><li>当一个异步操作开始时，Promise 处于 <code>pending</code> 状态。</li><li>当操作成功完成时，Promise 会从 <code>pending</code> 转变为 <code>fulfilled</code>，并传递一个结果值。</li><li>当操作发生错误时，Promise 会从 <code>pending</code> 转变为 <code>rejected</code>，并传递一个拒绝原因。</li></ul><p><strong>2.Promise 的基本结构</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 异步操作，根据结果调用 resolve 或 reject</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 操作成功 */</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>(result); <span class="hljs-comment">// 成功时调用 resolve 并传递结果</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error); <span class="hljs-comment">// 失败时调用 reject 并传递错误信息</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>3.Promise 的方法</strong>：</p><ul><li><code>.then(onFulfilled, onRejected)</code>: 用于注册回调函数，当 Promise 进入 <code>fulfilled</code> 状态时，调用 <code>onFulfilled</code>，当进入 <code>rejected</code> 状态时，调用 <code>onRejected</code>。</li><li><code>.catch(onRejected)</code>: 用于捕获 Promise 的错误，相当于 <code>.then(null, onRejected)</code>。</li><li><code>.finally(onFinally)</code>: 无论 Promise 的状态如何，都会执行 <code>onFinally</code> 回调，通常用于清理工作。</li><li><code>.all(iterable)</code>: 接受一个可迭代对象（通常是数组），并在所有 Promise 都成功时返回一个新的 Promise，如果其中任何一个失败，则返回的 Promise 失败。</li><li><code>.race(iterable)</code>: 接受一个可迭代对象，并返回一个新的 Promise，当其中任何一个 Promise 成功或失败时，返回的 Promise 也相应地成功或失败。</li></ul><p><strong>4.实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> randomNum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();<br>      <span class="hljs-keyword">if</span> (randomNum &gt; <span class="hljs-number">0.5</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(randomNum); <span class="hljs-comment">// 模拟成功</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;Error&quot;</span>); <span class="hljs-comment">// 模拟失败</span><br>      &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;;<br><br><span class="hljs-title function_">fetchData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Success:&quot;</span>, result);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>  &#125;)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cleanup&quot;</span>);<br>  &#125;);<br><br></code></pre></td></tr></table></figure><p>Promise 是处理异步代码的一种强大工具，它使得异步操作更具可读性和可维护性。但要注意，Promise 本身不处理多个异步操作之间的依赖关系，这时可以结合使用 <code>Promise.all</code> 或其他异步控制工具来处理。</p><p><strong>5.promise的优点</strong></p><p>Promise 在处理异步操作时具有许多优点，其中一些主要优点包括：</p><ol><li><strong>可读性和可维护性</strong>：Promise 提供了一种结构化的方式来处理异步代码，通过链式调用 <code>.then()</code> 和 <code>.catch()</code> 方法，可以更清晰地表达代码的逻辑，减少了回调地狱（Callback Hell）的问题，使代码更易于理解和维护。</li><li><strong>错误处理</strong>：Promise 具备良好的错误处理机制。你可以使用 <code>.catch()</code> 方法捕获 Promise 中的错误，这使得错误处理更加一致和可控。</li><li><strong>顺序控制</strong>：Promise 允许你按照特定的顺序执行异步操作，而不需要深度嵌套回调函数。这使得代码的执行流程更容易理解，特别是在复杂的异步场景中。</li><li><strong>并行执行</strong>：使用 <code>Promise.all()</code>，你可以并行执行多个异步操作，并在它们都完成后获得结果。这提高了性能，特别是在需要同时发起多个请求的情况下。</li><li><strong>可组合性</strong>：Promise 非常容易组合，你可以将多个 Promise 链接在一起以执行复杂的异步任务，这种可组合性有助于构建模块化和可重用的异步代码。</li><li><strong>更好的错误跟踪</strong>：由于 Promise 具有状态和错误处理机制，因此当出现问题时，可以更轻松地跟踪错误的来源和上下文，有助于快速诊断和修复问题。</li><li><strong>标准化</strong>：Promise 是一种标准的异步处理方法，已被广泛采纳并集成到 JavaScript 和许多库和框架中。这意味着开发者可以在不同的环境中共享和理解 Promise 代码。</li><li><strong>异步代码的统一接口</strong>：Promise 提供了一种统一的接口，不论是处理异步的浏览器 API、Node.js 回调风格的函数，还是其他异步操作，都可以很容易地包装成 Promise，使得异步操作的处理方式更加一致。</li></ol><p>总之，Promise 是一种强大的工具，它提供了更好的异步编程体验，使得异步代码更易于编写、理解和维护，并提供了一种标准化的方式来处理异步操作。这些优点有助于改善代码质量和开发效率。</p><p><strong>6.promise实现按照特定的顺序执行异步操作</strong></p><p>要按照特定顺序执行异步操作，你可以使用 Promise 的链式调用方法 <code>.then()</code> 来实现。每个 <code>.then()</code> 方法返回一个新的 Promise，可以用来处理前一个操作的结果，并在其中触发下一个异步操作。以下是一个示例，演示了如何按照特定顺序执行异步操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">javascriptCopy code<span class="hljs-comment">// 模拟异步操作，返回一个 Promise</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-params">order, delay</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Operation <span class="hljs-subst">$&#123;order&#125;</span> completed`</span>);<br>      <span class="hljs-title function_">resolve</span>(order); <span class="hljs-comment">// 模拟操作成功，传递订单号</span><br>    &#125;, delay);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 按照特定顺序执行异步操作</span><br><span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2000</span>); <span class="hljs-comment">// 等第一个操作完成后执行第二个操作</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">3</span>, <span class="hljs-number">500</span>); <span class="hljs-comment">// 等第二个操作完成后执行第三个操作</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;All operations completed&quot;</span>);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error); <span class="hljs-comment">// 捕获任何操作中的错误</span><br>  &#125;);<br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>asyncOperation</code> 函数模拟了异步操作，每个操作都有一个延迟时间。通过使用 <code>.then()</code> 方法，我们确保每个操作在前一个操作完成后才执行，从而按照特定顺序执行这些异步操作。</p><p>这种方法允许你构建异步操作的串行流程，确保它们按照你的期望顺序执行。如果任何一个操作失败，你也可以使用 <code>.catch()</code> 方法捕获错误。</p><p><strong>7.promise的应用场景</strong></p><p>Promise 在 JavaScript 中有广泛的使用场景，特别是在处理异步操作时，它们非常有用。以下是一些常见的 Promise 使用场景：</p><p><strong>1. 网络请求</strong>：当你需要从服务器获取数据时，通常会使用 Promise。这可以包括使用 <code>fetch</code> API 或其他库（如 Axios）来执行 HTTP 请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure><p><strong>2. 定时任务</strong>：使用 <code>setTimeout</code> 或 <code>setInterval</code> 进行定时任务，通常结合 Promise 使用，以便在一定时间后执行某个操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params">ms</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));<br>&#125;<br><br><span class="hljs-title function_">delay</span>(<span class="hljs-number">2000</span>) <span class="hljs-comment">// 等待 2 秒</span><br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2 秒后执行的任务&#x27;</span>));<br></code></pre></td></tr></table></figure><p><strong>3. 文件操作</strong>：读取和写入文件通常是异步操作，Promises 也用于处理这些操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">javascriptCopy codeconst fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readFileAsync</span>(<span class="hljs-params">path</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.<span class="hljs-title function_">readFile</span>(path, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-title function_">reject</span>(err);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">resolve</span>(data);<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">readFileAsync</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure><p><strong>4.并行执行多个任务</strong>：<code>Promise.all</code> 可用于并行执行多个异步任务，并等待它们全部完成。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">javascriptCopy codeconst promises = [fetchData1(), fetchData2(), fetchData3()];<br><br>Promise.<span class="hljs-built_in">all</span>(promises)<br>  .then(<span class="hljs-function"><span class="hljs-params">results</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(results))<br>  .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(error));<br></code></pre></td></tr></table></figure><p><strong>5.处理事件</strong>：Promises 可以用于封装事件处理，以便在事件发生时执行异步操作。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">javascriptCopy codeconst button = document.getElementById(<span class="hljs-string">&#x27;myButton&#x27;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">onClick</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, resolve, &#123; <span class="hljs-attr">once</span>: <span class="hljs-literal">true</span> &#125;);<br>  &#125;);<br>&#125;<br><br>onClick()<br>  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;按钮被点击了&#x27;</span>));<br></code></pre></td></tr></table></figure><p>这些是一些常见的 Promise 使用场景，但实际上 Promises 可以用于几乎任何需要处理异步操作的情况。它们提供了一种更结构化和可管理的方式来处理异步代码，有助于提高代码的可读性和可维护性。</p><h2 id="3-ES6、ES7、ES8、ES9、ES10新特性一览（√）"><a href="#3-ES6、ES7、ES8、ES9、ES10新特性一览（√）" class="headerlink" title="3.ES6、ES7、ES8、ES9、ES10新特性一览（√）"></a>3.ES6、ES7、ES8、ES9、ES10新特性一览（√）</h2><p>以下是一些 JavaScript 的主要 ECMAScript（ES）版本（ES6 到 ES10）中引入的新特性和改进：</p><ol><li>ES6（ECMAScript 2015）：<ul><li>函数：箭头函数、参数默认值。</li><li><code>let</code> 和 <code>const</code>：块级作用域变量声明。</li><li>symbol</li><li>类：引入了类和面向对象编程的支持。</li><li>模板字面量：字符串模板。</li><li>解构赋值：数组解构、对象解构。</li><li>剩余和扩展操作符：<code>...</code> 运算符用于处理可变数量的参数。</li><li>Promise：更好的异步编程支持。</li><li>模块化：引入了 <code>import</code> 和 <code>export</code> 以支持模块化编程。</li><li>对象：map和set、属性名简写、对象和数组新方法</li></ul></li><li>ES7（ECMAScript 2016）：<ul><li>Array.prototype.includes()：用于检查数组是否包含某个元素的方法。</li></ul></li><li>ES8（ECMAScript 2017）：<ul><li><code>async</code> 和 <code>await</code>：用于更简单的异步代码编写。</li><li>Object.values() 和 Object.entries()：用于遍历对象的值和键值对。</li><li>字符串填充：<code>padStart()</code> 和 <code>padEnd()</code> 用于填充字符串。</li></ul></li><li>ES9（ECMAScript 2018）：<ul><li>异步迭代器和 <code>for-await-of</code> 循环：更好的异步迭代支持。</li><li>Rest&#x2F;Spread 属性：在对象上使用 <code>...</code> 运算符。</li><li>正则表达式增强：引入 <code>s</code> 修饰符以匹配换行符，并且支持命名捕获组。</li></ul></li><li>ES10（ECMAScript 2019）：<ul><li>Array.prototype.flat() 和 Array.prototype.flatMap()：用于处理多维数组的新方法。</li><li>Object.fromEntries()：将键值对数组转换为对象。</li><li><code>String.prototype.trimStart()</code> 和 <code>String.prototype.trimEnd()</code>：去除字符串开头和结尾的空白字符。</li><li>动态 <code>import()</code>：异步加载模块。</li><li>可选链式调用（Optional Chaining）：安全地访问深层嵌套对象的属性。</li><li>空值合并运算符（Nullish Coalescing）：处理 <code>null</code> 和 <code>undefined</code> 值的默认值问题。</li></ul></li></ol><p>每个新版本都引入了一些语言特性和语法改进，以提高 JavaScript 的功能和可读性，并简化开发人员的工作。</p><h2 id="4-变量和函数的声明提前（√）"><a href="#4-变量和函数的声明提前（√）" class="headerlink" title="4.变量和函数的声明提前（√）"></a>4.变量和函数的声明提前（√）</h2><p><strong>1.变量：</strong>使用<code>var</code>关键字定义的变量会在所有代码执行之前被声明，但是不会赋值。</p><p><strong>2.函数：</strong>使用函数声明形式创建的函数function 函数名{} 会在所有代码执行之前被创建，所以我们可以在函数声明前来调用函数，使用函数表达式创建的函数不会声明提升。</p><p><strong>3.函数作用域也有声明提升的特性：</strong></p><ul><li>使用var关键字声明的变量，会在函数中所有的代码执行之前被声明。</li><li>函数声明也会在函数中所有代码执行之前执行。</li></ul><blockquote><p><strong>注意：</strong></p><p>①在函数中不使用var声明的变量都会变成全局变量</p><p>②定义形参相当于在函数作用域中声明了变量</p></blockquote><h2 id="5-let、const、var三者的区别（√）"><a href="#5-let、const、var三者的区别（√）" class="headerlink" title="5.let、const、var三者的区别（√）"></a>5.let、const、var三者的区别（√）</h2><p>我们在全局作用域中或局部作用域中，使用<code>var</code>关键字声明的变量，<strong>都会被提升到该作用域的最顶部</strong>，这就是我们常说的变量提升</p><p><code>let</code>, <code>const</code>, 和 <code>var</code> 是 JavaScript 中用于声明变量的关键字，它们之间有一些重要的区别：</p><ol><li><strong>作用域：</strong><ul><li><code>let</code> 和 <code>const</code> 声明的变量具有块级作用域（在 <code>&#123;&#125;</code> 内有效），是es6语法新提出的，不会变量提升。</li><li><code>var</code> 声明的变量是<strong>函数级作用域</strong>的（在函数内有效），并且会变量提升至函数的顶部。（即使写在if代码块里也是看函数作用域的）</li></ul></li><li><strong>变量提升：</strong><ul><li><code>var</code> 声明的变量会被提升到函数或全局作用域的顶部，即使在声明之前访问它，也不会报错，但值为 <code>undefined</code>。</li><li><code>let</code> 和 <code>const</code> 声明的变量没有变量提升，在访问之前会存在暂时性死区（Temporal Dead Zone，TDZ），访问时会报错，表示该变量存在但不可访问的状态。</li></ul></li><li><strong>重复声明：</strong><ul><li>使用 <code>var</code> 可以多次声明同名变量，而不会抛出错误。</li><li>使用 <code>let</code> 或 <code>const</code> 在同一作用域内重复声明同名变量会引发语法错误。</li></ul></li><li><strong>可变性：</strong><ul><li><code>var</code> 声明的变量可以重新赋值，也可以不赋值。</li><li><code>let</code> 声明的变量可以重新赋值，但不可以不赋值。</li><li><code>const</code> 声明的变量必须在声明时初始化，并且不能重新赋值。</li></ul></li><li><strong>全局对象属性：</strong><ul><li>使用 <code>var</code> 声明的全局变量会成为全局对象（例如，<code>window</code> 在浏览器中）的属性。</li><li>使用 <code>let</code> 或 <code>const</code> 声明的全局变量不会成为全局对象的属性。</li></ul></li><li><strong>适用场景：</strong><ul><li>推荐使用 <code>let</code> 或 <code>const</code>，因为它们更安全，避免了许多常见的问题，特别是 <code>const</code> 对于不需要重新赋值的情况。</li><li>在需要支持旧版浏览器或在一些特定情况下，仍然可以使用 <code>var</code>。</li></ul></li></ol><p>总结来说，<code>let</code> 和 <code>const</code> 是现代 JavaScript 推荐的变量声明方式，它们提供了更严格的作用域和变量行为，有助于减少错误。在编写新的代码时，应优先使用 <code>let</code> 和 <code>const</code>，只有在特殊情况下才使用 <code>var</code>。</p><h2 id="6-async-await（√）"><a href="#6-async-await（√）" class="headerlink" title="6.async&#x2F;await（√）"></a>6.async&#x2F;await（√）</h2><p><code>async/await</code> 是 JavaScript 中用于处理异步操作的语法糖，它们使得异步代码的编写和阅读更加清晰和直观。<code>async</code> 用于定义一个异步函数，而 <code>await</code> 用于等待一个异步操作完成。以下是关于 <code>async/await</code> 的详细解释以及如何使用它们：</p><p><strong>async 函数</strong>：</p><ul><li><code>async</code> 是一个关键字，用于定义一个异步函数，它在函数前面添加 <code>async</code> 关键字来表示这个函数将返回一个 Promise。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>await 表达式</strong>：</p><ul><li><code>await</code> 也是一个关键字，用于等待一个 Promise 完成并返回其结果。它只能在 <code>async</code> 函数内部使用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>(); <span class="hljs-comment">// 等待 fetchData() 异步操作完成</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>async&#x2F;await 的作用</strong>：</p><ol><li><strong>改善异步代码的可读性</strong>：<code>async/await</code> 可以将异步操作的嵌套回调转化为更线性的代码，使得代码更容易理解。</li><li><strong>更好的错误处理</strong>：<code>try/catch</code> 结合 <code>await</code> 可以更容易地捕获和处理异步操作中的错误，提高了代码的可维护性。</li><li><strong>等待异步操作完成</strong>：<code>await</code> 让你可以等待异步操作的结果，而不需要回调函数或 Promise 的 <code>.then()</code> 方法来处理结果。</li></ol><p><strong>如何使用 async&#x2F;await</strong>：</p><p><strong>1. 定义异步函数</strong>：首先，使用 <code>async</code> 关键字定义一个异步函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 异步操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 在函数内使用 await</strong>：在函数内部，使用 <code>await</code> 关键字等待一个异步操作的完成。这个异步操作通常是返回一个 Promise 的函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/userdata&#x27;</span>);<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 调用异步函数</strong>：在其他地方调用异步函数时，可以使用 <code>.then()</code> 来处理 Promise 的结果，或者将其包装在另一个异步函数中并使用 <code>await</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">fetchUserData</span>()<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">userData</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userData);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br><br><span class="hljs-comment">// 或者使用 async/await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> userData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUserData</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userData);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p><code>async/await</code> 是一种强大的工具，可以显著提高异步代码的可读性和可维护性，使得异步编程更加愉快和容易。但请注意，<code>async/await</code> 只能在支持 ECMAScript 2017（ES8）及更高版本的 JavaScript 环境中使用。</p><h2 id="7-map-和-set-（√）"><a href="#7-map-和-set-（√）" class="headerlink" title="7.map 和 set （√）"></a>7.map 和 set （√）</h2><p>Map对象用于保存键值对，任何值JavaScript支持的值都可以作为一个键（key）或者一个值（value）。 与对象不同的是</p><ol><li>object的键只能是<strong>字符串</strong>或ES6的<strong>symbol</strong>值，而Map可以是任何值。</li><li>Map对象有一个<strong>size属性</strong>，存储了键值对的个数，而object对象没有类似属性。</li></ol><blockquote><p><font color=red><strong>Map介绍如下</strong></font></p></blockquote><p><code>Map</code> 是一种键值对的集合，其中每个值都有一个相关联的键。以下是关于 <code>Map</code> 的详细介绍和使用方法：</p><p><strong>特性和用途</strong>：</p><ul><li>键可以是任意数据类型，包括对象、函数和原始数据类型。</li><li>保持键值对的插入顺序，因此可以迭代它们的顺序。</li><li>可以使用 <code>size</code> 属性来获取 <code>Map</code> 中键值对的数量。</li><li><code>Map</code> 是一种灵活的数据结构，适用于许多不同的场景，例如缓存、数据存储等。</li></ul><p><strong>创建和基本操作</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个空的 Map</span><br><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-comment">// 设置键值对</span><br>myMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br>myMap.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">30</span>);<br><span class="hljs-comment">// 获取值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;name&#x27;</span>)); <span class="hljs-comment">// 输出: &quot;John&quot;</span><br><span class="hljs-comment">// 检查是否包含某个键</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myMap.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;age&#x27;</span>)); <span class="hljs-comment">// 输出: true</span><br><span class="hljs-comment">// 删除键值对</span><br>myMap.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;age&#x27;</span>);<br><span class="hljs-comment">// 迭代 Map</span><br>myMap.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value);<br>&#125;);<br><span class="hljs-comment">// 清除所有的键值对</span><br>myMap.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><blockquote><p><font color=red><strong>Set</strong></font></p></blockquote><p><code>Set</code> 是一种 值的无序集合，其中每个值都是唯一的，不能重复。以下是关于 <code>Set</code> 的详细介绍和使用方法：</p><p><strong>特性和用途</strong>：</p><ul><li>存储唯一的值，去重效果非常高效。</li><li>不允许重复的元素，因此不能有相同值的项。</li><li>可以使用 <code>size</code> 属性来获取 <code>Set</code> 中值的数量。</li><li><code>Set</code> 通常用于存储一组不重复的值，例如集合操作、去重数组等。</li></ul><p><strong>创建和基本操作</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个空的 Set</span><br><span class="hljs-keyword">const</span> mySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-comment">// 添加值</span><br>mySet.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>mySet.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>mySet.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 不会重复添加</span><br><span class="hljs-comment">// 检查是否包含某个值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySet.<span class="hljs-title function_">has</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出: true</span><br><span class="hljs-comment">// 删除值</span><br>mySet.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 迭代 Set</span><br>mySet.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;);<br><span class="hljs-comment">// 清除所有的键值对</span><br>mySet.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>总之，<code>Map</code> 适用于需要存储键值对的情况，而 <code>Set</code> 适用于需要存储一组唯一值的情况。这两种数据结构在 JavaScript 中提供了更多的灵活性和高效性，可以用于解决各种问题。</p><table>    <tr>        <th>两者的比较</th>        <th>map</th>        <th>set</th>    </tr>    <tr>        <td>创建一个空的</td>        <td>const myMap = new Map();</td>        <td>const mySet = new Set();</td>    </tr>    <tr>        <td>添加</td>        <td>myMap.set('name', 'John');</td>        <td>mySet.add(1);</td>    </tr>    <tr>        <td>获取</td>        <td>myMap.get('name')</td>        <td>--</td>    </tr>    <tr>        <td>判断是否有某值</td>        <td>myMap.has('age')，返回布尔值</td>        <td>mySet.has(2)，返回布尔值</td>    </tr>    <tr>        <td>删除单个键值对</td>        <td>myMap.delete('age');</td>        <td>mySet.delete(1);</td>    </tr>    <tr>        <td>清除所有</td>        <td>myMap.clear();</td>        <td>mySet.clear();</td>    </tr></table><h2 id="8-对象的新方法（√）"><a href="#8-对象的新方法（√）" class="headerlink" title="8.对象的新方法（√）"></a><strong>8.对象的新方法</strong>（√）</h2><p>在 ES6 中，添加了<code>Object.is()</code>、<code>Object.assign()</code>、<code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code>等方法。</p><p><strong>1. Object.is()</strong></p><ul><li><code>Object.is()</code>方法用来判断两个值是否为同一个值，返回一个布尔类型的值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123;&#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123;&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(obj1, obj2)); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> obj3 = &#123;&#125;;<br><span class="hljs-keyword">const</span> value1 = obj3;<br><span class="hljs-keyword">const</span> value2 = obj4;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(value1, value2)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>2. Object.assign()</strong></p><ul><li><code>Object.assign()</code>方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj3 = &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">5</span> , <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-comment">//对象合并，把后面对像合并到第一个对象，对象里相同的属性会覆盖</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj1, obj2, obj3);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">// &#123; a: 5, b: 2 , c:3&#125;</span><br></code></pre></td></tr></table></figure><p><strong>3.Object.keys()、Object.values()、Object.entries()</strong></p><ul><li>Object.keys()  返回对象所有属性</li><li>Object.values() 返回对象所有属性值</li><li>Object.entries() 返回多个数组，每个数组是 key–value 不解释直接看例子</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-attr">language</span>: [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;js&quot;</span>, <span class="hljs-string">&quot;css&quot;</span>],<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(person)); <span class="hljs-comment">//[ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;language&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(person)); <span class="hljs-comment">//[ &#x27;admin&#x27;, 12, [ &#x27;java&#x27;, &#x27;js&#x27;, &#x27;css&#x27; ] ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(person));    <span class="hljs-comment">/* [</span><br><span class="hljs-comment">                                                     [&quot;name&quot;, &quot;admin&quot;],</span><br><span class="hljs-comment">                                                     [&quot;age&quot;, 12],</span><br><span class="hljs-comment">                                                     [&quot;language&quot;, [&quot;java&quot;, &quot;js&quot;, &quot;css&quot;]],</span><br><span class="hljs-comment">                                           ]; */</span><br></code></pre></td></tr></table></figure><h1 id="📚-浏览器"><a href="#📚-浏览器" class="headerlink" title="📚 浏览器"></a>📚 浏览器</h1><h2 id="1-浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别"><a href="#1-浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别" class="headerlink" title="1.浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别"></a>1.浏览器缓存（强缓存，协商缓存）具体字段头是哪些，有何区别</h2><h2 id="2-前端缓存方法"><a href="#2-前端缓存方法" class="headerlink" title="2.前端缓存方法"></a>2.前端缓存方法</h2><h2 id="3-输入URL到页面渲染的过程"><a href="#3-输入URL到页面渲染的过程" class="headerlink" title="3.输入URL到页面渲染的过程"></a>3.输入URL到页面渲染的过程</h2><h2 id="4-同源策略和跨域"><a href="#4-同源策略和跨域" class="headerlink" title="4.同源策略和跨域"></a>4.同源策略和跨域</h2><h1 id="📚-计算机网络"><a href="#📚-计算机网络" class="headerlink" title="📚 计算机网络"></a>📚 计算机网络</h1><h2 id="1-介绍一下Http各个版本"><a href="#1-介绍一下Http各个版本" class="headerlink" title="1.介绍一下Http各个版本"></a>1.介绍一下Http各个版本</h2><h2 id="2-有哪些请求？"><a href="#2-有哪些请求？" class="headerlink" title="2.有哪些请求？"></a>2.有哪些请求？</h2><h2 id="2-get和post有什么区别？"><a href="#2-get和post有什么区别？" class="headerlink" title="2.get和post有什么区别？"></a>2.get和post有什么区别？</h2><h1 id="📚-性能优化"><a href="#📚-性能优化" class="headerlink" title="📚 性能优化"></a>📚 性能优化</h1><h2 id="1-防抖和节流的实现方式"><a href="#1-防抖和节流的实现方式" class="headerlink" title="1.防抖和节流的实现方式"></a>1.防抖和节流的实现方式</h2><h2 id="2-图片懒加载"><a href="#2-图片懒加载" class="headerlink" title="2.图片懒加载"></a>2.图片懒加载</h2><h1 id="📚-vue2-vue3"><a href="#📚-vue2-vue3" class="headerlink" title="📚 vue2+vue3"></a>📚 vue2+vue3</h1><h2 id="1-Vue-diff算法（√）"><a href="#1-Vue-diff算法（√）" class="headerlink" title="1.Vue diff算法（√）"></a>1.Vue diff算法（√）</h2><p>Vue.js 使用了一种称为Virtual DOM（虚拟DOM）的机制来提高页面渲染的性能。Vue的Virtual DOM通过Diff算法来比较前后两个虚拟DOM树的差异，然后仅更新需要变化的部分，从而减少了页面重绘和重新渲染的开销。以下是Vue的Diff算法的简要工作原理：</p><ol><li><strong>生成虚拟DOM树：</strong> 当数据发生变化时，Vue首先会生成一个新的虚拟DOM树。这个虚拟DOM树是一个JavaScript对象树，它的结构与实际的DOM树相似，但只包含了需要渲染的元素和组件。</li><li><strong>比较新旧虚拟DOM树：</strong> Vue会逐层比较新旧虚拟DOM树的节点，找出差异。这个比较过程是深度优先的，从根节点开始，递归地比较子节点。</li><li><strong>标记差异：</strong> 在比较的过程中，Vue会标记出两个虚拟DOM树之间的差异。差异可以分为四种类型：添加、删除、属性修改和文本内容修改。</li><li><strong>批量更新：</strong> 一旦标记出差异，Vue会将所有差异记录下来，然后一次性地应用这些差异，而不是立即更新实际的DOM。这个批量更新可以提高性能，因为实际的DOM操作是昂贵的。</li><li><strong>更新视图：</strong> 最后，Vue会使用新的虚拟DOM树来更新实际的DOM，只更新那些发生变化的部分。这个过程通常是非常高效的，因为它只涉及到实际变化的部分，而不是整个页面。</li></ol><p>Vue的Diff算法的性能优化是通过减少实际DOM操作的次数来实现的，这是因为实际DOM操作是相对较慢的，尤其是在复杂的页面上。通过比较虚拟DOM树并只更新需要变化的部分，Vue能够显著提高页面的性能和响应速度。</p><p>需要注意的是，Vue的Diff算法并不是唯一的实现方式，不同的前端框架可能使用不同的Diff算法来提高性能。但Diff算法的核心思想是相似的：通过比较前后两个状态来确定需要更新的部分，从而减少不必要的DOM操作。</p><h2 id="2-Vue组件通信"><a href="#2-Vue组件通信" class="headerlink" title="2.Vue组件通信"></a>2.Vue组件通信</h2><p>包括父子组件通信：父传子，子传父，兄弟组件通信</p><h2 id="3-闭包在vue中有哪些应用？（√）"><a href="#3-闭包在vue中有哪些应用？（√）" class="headerlink" title="3.闭包在vue中有哪些应用？（√）"></a>3.闭包在vue中有哪些应用？（√）</h2><p>以下是一些常见的 Vue.js 中闭包的应用场景：</p><p><strong>1.事件处理函数</strong>：当你在 Vue 组件中绑定事件处理函数时，这些函数通常会捕获组件的作用域（即组件的数据和方法）。这是因为事件处理函数被绑定在组件实例上，形成了一个闭包，使得它们可以访问组件的数据和方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;button @click=&quot;handleClick&quot;&gt;点击我&lt;/button&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      count: 0,<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    handleClick() &#123;<br>      // 这里的 this 指向组件实例，可以访问组件的数据<br>      this.count++;<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>2.模块化开发</strong>：Vue 组件通常使用单文件组件（.vue 文件）来组织代码，这些文件中的数据、计算属性、方法等都被封装在组件的闭包中，以避免全局污染和命名冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      message: &#x27;Hello, Vue!&#x27;,<br>    &#125;;<br>  &#125;,<br>  computed: &#123;<br>    reversedMessage() &#123;<br>      return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);<br>    &#125;,<br>  &#125;,<br>  methods: &#123;<br>    showMessage() &#123;<br>      alert(this.message);<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>3.路由守卫</strong>：在 Vue Router 中，路由守卫使用闭包来访问当前路由的信息、组件实例等，以执行导航守卫逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>;<br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 访问当前路由的信息</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to.<span class="hljs-property">path</span>);<br>  <span class="hljs-comment">// 访问组件实例</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(to.<span class="hljs-property">matched</span>[<span class="hljs-number">0</span>].<span class="hljs-property">instances</span>.<span class="hljs-property">default</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>4.自定义指令</strong>：如果你编写自定义 Vue 指令，闭包可以用于存储和访问指令的局部状态和逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;custom-directive&#x27;</span>, &#123;<br>  <span class="hljs-title function_">bind</span>(<span class="hljs-params">el, binding</span>) &#123;<br>    <span class="hljs-comment">// 使用闭包访问局部状态</span><br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><br>    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 在事件处理程序中使用局部状态</span><br>      count++;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>);<br>    &#125;);<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>5.计时器和异步操作</strong>：Vue 中常用的计时器（如 <code>setInterval</code>、<code>setTimeout</code>）和异步操作（如 AJAX 请求）也会涉及到闭包。你可以在回调函数内部访问组件的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      timer: null,<br>      message: &quot;Hello, Vue!&quot;,<br>    &#125;;<br>  &#125;,<br>  created() &#123;<br>    // 使用闭包保存组件内部数据<br>    this.timer = setInterval(() =&gt; &#123;<br>      console.log(this.message);<br>    &#125;, 1000);<br>  &#125;,<br>  destroyed() &#123;<br>    // 清除计时器以防止内存泄漏<br>    clearInterval(this.timer);<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><strong>6.作用域</strong>：在一些特殊情况下，你可能需要在 Vue 模板中使用闭包来访问外部作用域的数据。这通常涉及到在计算属性或指令中使用函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;p&gt;&#123;&#123; calculate() &#125;&#125;&lt;/p&gt;<br>    &lt;button @click=&quot;updateMessage&quot;&gt;更新消息&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      message: &quot;Hello, Vue!&quot;,<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    updateMessage() &#123;<br>      this.message = &quot;New Message&quot;;<br>    &#125;,<br>  &#125;,<br>  computed: &#123;<br>    calculate() &#123;<br>      // 使用闭包访问外部作用域的数据<br>      const originalMessage = this.message;<br>      return function () &#123;<br>        return `Length: $&#123;originalMessage.length&#125;`;<br>      &#125;;<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>总之，闭包在 Vue.js 中被广泛用于访问组件的局部作用域、数据和方法，以及实现模块化开发、路由守卫、自定义指令等功能。Vue.js 利用闭包机制使得组件化开发更加强大和灵活。</p><h2 id="4-vue中双向数据绑定（√）"><a href="#4-vue中双向数据绑定（√）" class="headerlink" title="4.vue中双向数据绑定（√）"></a>4.vue中双向数据绑定（√）</h2><p>Vue.js中的双向数据绑定是其核心特性之一，它使视图和模型之间的数据保持同步。Vue的双向绑定原理可以概括为以下几个步骤：</p><ol><li><strong>数据劫持（Data Observation）</strong>：<ul><li>当你在Vue实例中声明数据时，Vue会通过对象的<code>Object.defineProperty</code>方法来将这些属性转化为”响应式属性”。</li><li>Vue会遍历数据对象的每个属性，并在每个属性上定义<code>getter</code>和<code>setter</code>方法。</li><li><code>getter</code>负责追踪属性的依赖关系，当属性被读取时，会将观察者添加到依赖项列表中。</li><li><code>setter</code>监听属性的变化，当属性被修改时，会通知所有依赖于该属性的观察者，并触发视图更新。</li></ul></li><li><strong>模板编译（Template Compilation）</strong>：<ul><li>Vue使用带有特殊语法的模板来定义视图。</li><li>模板中的表达式会被解析并建立对数据属性的引用。</li><li>Vue会将模板编译成虚拟DOM（Virtual DOM）。</li></ul></li><li><strong>虚拟DOM与真实DOM的比较（Virtual DOM Diffing）</strong>：<ul><li>每当数据发生变化时，Vue会生成一个新的虚拟DOM树。</li><li>Vue会将新的虚拟DOM与旧的虚拟DOM进行比较，找出两者之间的差异。</li><li>这个过程叫做”虚拟DOM的Diff算法”，它可以高效地找出需要更新的部分，以最小化DOM操作。</li></ul></li><li><strong>更新视图（Reactivity）</strong>：<ul><li>Vue知道哪些属性在模板中被引用，以及它们之间的依赖关系。</li><li>当数据改变时，Vue会触发相应属性的<code>setter</code>方法，通知相关的观察者进行更新。</li><li>观察者接收到通知后，会通知虚拟DOM重新渲染视图，但只更新变化的部分，而不是整个视图。</li></ul></li><li><strong>用户交互与数据变更的同步（User Interaction and Data Mutation）</strong>：<ul><li>当用户与页面交互，例如在表单输入框中输入内容时，输入框的值会被绑定到Vue实例的数据属性。</li><li>数据属性的变化将触发更新，更新会反映在视图中，保持视图和数据的同步。</li></ul></li></ol><p>总的来说，Vue的双向绑定原理通过数据劫持、模板编译、虚拟DOM的比较和更新视图等机制，使数据与视图保持同步，从而实现了双向数据绑定。这个机制使得开发者可以更轻松地管理数据和用户界面的交互，提高了开发效率和应用的可维护性。</p><h2 id="5-Vue-中的虚拟DOM和真实DOM（√）"><a href="#5-Vue-中的虚拟DOM和真实DOM（√）" class="headerlink" title="5.Vue 中的虚拟DOM和真实DOM（√）"></a>5.Vue 中的虚拟DOM和真实DOM（√）</h2><p>vue.js 是一个流行的前端 JavaScript 框架，它使用虚拟 DOM（Virtual DOM）来提高性能和效率。理解虚拟 DOM 和真实 DOM 的概念对于理解 Vue.js 和其他一些前端框架的工作原理非常重要。</p><ol><li><strong>真实 DOM（Real DOM）</strong>：<ul><li>真实 DOM 是浏览器中实际存在的文档对象模型。</li><li>当页面中的数据发生变化时，浏览器会重新渲染整个页面，包括对应数据发生变化的部分。</li><li>操作真实 DOM 需要消耗大量的计算资源，因此频繁的 DOM 操作可能导致性能下降。</li></ul></li><li><strong>虚拟 DOM（Virtual DOM）</strong>：<ul><li>虚拟 DOM 是一个轻量级的 JavaScript 对象树，它是对真实 DOM 的抽象。</li><li>当数据变化时，Vue.js 首先会生成一个新的虚拟 DOM 树，然后将新旧虚拟 DOM 树进行比较，找出差异。</li><li>找到差异后，Vue.js 只更新必要的部分，而不是整个页面，以提高性能。</li><li>这种方式可以减少对真实 DOM 的操作次数，从而提高应用的性能和响应速度。</li></ul></li></ol><p>虚拟 DOM 的工作流程如下：</p><ol><li>初始渲染：Vue.js 使用模板和数据生成虚拟 DOM。</li><li>数据变化：当应用状态（数据）发生变化时，Vue.js 生成一个新的虚拟 DOM。</li><li>虚拟 DOM 比较：Vue.js 将新旧虚拟 DOM 树进行比较，找出差异。</li><li>更新真实 DOM：Vue.js 只更新必要的部分，以使真实 DOM 反映新的应用状态。</li></ol><p>虚拟 DOM 的好处在于它可以最小化对真实 DOM 的直接访问和操作，从而提高了前端应用的性能和效率。这是因为真实 DOM 操作通常是昂贵的，而虚拟 DOM 可以将多个操作批量处理并最小化页面的重新渲染。</p><p>在使用 Vue.js 时，你通常不需要直接操作虚拟 DOM，框架会负责处理它。你只需关注数据的变化和视图的声明性描述，Vue.js 将自动处理虚拟 DOM 的创建和更新。这使得开发过程更简单，同时又能保持良好的性能。</p><h2 id="6-vue3和vue2的区别（√）"><a href="#6-vue3和vue2的区别（√）" class="headerlink" title="6.vue3和vue2的区别（√）"></a>6.vue3和vue2的区别（√）</h2><p>Vue.js是一个流行的JavaScript框架，用于构建用户界面。Vue 3和Vue 2之间存在一些重要的区别，Vue 3引入了一些新功能和性能优化，以提高开发者的体验。以下是Vue 3和Vue 2之间的主要区别：</p><ol><li><strong>性能优化：</strong> Vue 3在性能方面进行了显著改进。其中一个关键的优化是虚拟DOM的升级，使其更高效。Vue 3还引入了懒编译，允许更小的包大小，因此加载时间更快。</li><li><strong>Composition API：</strong> Vue 3引入了Composition API，这是一种新的组织组件逻辑的方式。它允许开发者根据功能而不是选项对代码进行组织，使组件更容易理解和维护。</li><li><strong>Teleport：</strong> Vue 3引入了Teleport，这是一种新的方式来在DOM中移动元素，而无需改变其组件层次结构。这对于创建模态框、弹出菜单等非常有用。</li><li><strong>Fragments：</strong> Vue 3支持Fragments，允许你在组件中返回多个根元素，而不需要包装它们在一个额外的父元素中。</li><li><strong>全局API的更改：</strong> Vue 3对一些全局API进行了更改。例如，<code>Vue.observable()</code>现在变成了<code>Vue.reactive()</code>，<code>Vue.nextTick()</code>现在是<code>Vue.nextTick()</code>。</li><li><strong>自定义渲染器：</strong> Vue 3引入了自定义渲染器的能力，这意味着你可以在不同的目标（例如Web、原生移动应用、桌面应用）上渲染Vue组件。</li><li><strong>TypeScript支持：</strong> Vue 3更好地支持TypeScript，包括通过<code>.d.ts</code>文件提供类型定义。</li><li><strong>模块化编译：</strong> Vue 3的编译器是模块化的，这意味着你可以只编译你实际用到的特性，而不是整个编译器。</li></ol><p>需要注意的是，虽然Vue 3引入了许多改进和新功能，但它与Vue 2的核心思想仍然保持一致，因此如果你已经熟悉Vue 2，学习Vue 3应该相对容易。然而，对于新项目，特别是需要性能优化和更好的组织代码的项目，Vue 3通常是更好的选择。</p><h2 id="7-你有没有自己封装过组件？"><a href="#7-你有没有自己封装过组件？" class="headerlink" title="7.你有没有自己封装过组件？"></a>7.你有没有自己封装过组件？</h2><p>有，分页器、日历</p><p>项目用的vue2 问会不会vue3</p><p>vue3取消了mixin，用什么代替<br>适配是怎么实现的 为啥要适配<br>采用px-vw不会造成拉伸吗<br>axios发送的请求如何取消<br>404要怎么实现<br>如何在登录前防止用户访问<br>前后端分离相较前后端不分离的区别<br>用的什么打包工具<br>使用webpack做了什么<br>webpack如何打包import<br>封装过什么组件<br>对项目提出过什么改进</p><h1 id="📚-面试题带坑"><a href="#📚-面试题带坑" class="headerlink" title="📚 面试题带坑"></a>📚 面试题带坑</h1><h2 id="1-console-log-“1”-“2”-“3”-map-parseInt-的输出值是多少？"><a href="#1-console-log-“1”-“2”-“3”-map-parseInt-的输出值是多少？" class="headerlink" title="1.console.log([“1”, “2”, “3”].map(parseInt));的输出值是多少？"></a>1.console.log([“1”, “2”, “3”].map(parseInt));的输出值是多少？</h2><p>来源：<a href="https://juejin.cn/post/7049161354703273998">parseInt()函数绝不是你想的那么简单~~ - 掘金 (juejin.cn)</a></p><p>【知识点】：map()和parseInt()</p><p>【分析】<code>map</code>方法可以将一个数组映射为一个新数组。它接收一个<code>callback</code>回调函数作为参数，这个回调函数体现了将原数组映射成新数组的映射关系。原数组在循环遍历数组每一项时，都会调用一次<code>callback</code>回调函数，并传入三个参数：</p><ul><li>当前正在遍历的元素</li><li>元素索引</li><li>原数组本身 (这个参数基本不使用)</li></ul><p><code>callback</code>函数对当前遍历的元素进行包装执行，得到的返回值就是新数组中对应的结果</p><p><code>parseInt</code>接收两个参数：</p><ul><li>第一个参数<code>string</code>：要被解析的字符串，如果不是字符串会被转换，忽视空格符</li><li>第二个参数<code>radix</code>：要解析的数字的基数。该值介于<code>2 ~ 36</code>之间。默认值为10，表示十进制。这个参数表示<strong>将前面的字符从radix进制转化为十进制</strong></li></ul><p>把上面的代码的完整写法为：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<br>  [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>].<span class="hljs-built_in">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, arr</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(item + <span class="hljs-string">&quot;-----&quot;</span> + index);<br>    <span class="hljs-keyword">return</span> parseInt(item, index);<br>  &#125;)<br>);<br></code></pre></td></tr></table></figure><p>每次每一项给parseInt传入的值为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span><span class="hljs-comment">-----0</span><br><span class="hljs-number">2</span><span class="hljs-comment">-----1</span><br><span class="hljs-number">3</span><span class="hljs-comment">-----2</span><br></code></pre></td></tr></table></figure><p>所以最终结果为：[ 1, NaN, NaN ]</p><p>其他：</p><p>PC端和移动端项目CSS的适配区别<br>\3. rem是怎么设置的，手动算的还是用了库<br>\4. rem和em的区别<br>\5. 屏幕大小变化的时候是如何适配的<br>\6. 直接写rem计算屏幕的宽高是怎么获取的<br>\7. 其他移动端适配的方法？<br>\8. 上一题提示：vw，vh<br>\9. 逻辑像素和物理像素的区别<br>\10. 浏览器渲染是如何解析渲染html文档的<br>\11. css下载的过程会阻塞js的下载吗<br>\12. 为什么阻塞？<br>\13. 项目性能优化的方式<br>\14. tree shaking的限制条件？比如模块化方式commonJS或ES6module的方法能实现吗<br>\15. 原生JS 类的实现方法，比如new一个函数的过程<br>\16. ES6的class编译完成后产物是什么样的，比如是函数or对象or数组<br>\17. 可以用var a &#x3D; new<br>\18. ES6中继承的原理？<br>\19. 原型链<br>\20. function的prototype是什么<br>\21. 闭包原理<br>\22. ES5有哪些作用域，ES6呢<br>\23. 项目中用过的异步方法怎么实现的<br>\24. promise传的参数(resolve，reject)执行时机是异步还是同步的<br>\25. 函数里有error会怎么样<br>\26. 必须catch吗，用then呢<br>\27. then后面再有then，是会进入resolve还是reject的回调<br>\28. async await原理<br>\29. await后面跟一个1或者字符串可以吗<br>\30. Generator函数接触过吗<br>\31. 浏览器的Eventloop和node的Eventloop区别<br>\32. 提示：事件循环<br>\33. 异步任务挂起之后还可以给下一个用户提供服务吗，(挂起期间有新用户访问)<br>\34. git用到哪些命令多一些<br>\35. merge用过吗<br>\36. 跨域问题如何解决<br>\37. 跨域请求的时候带cookie怎么带<br>\38. react 了解过吗，如果让你上手做可以做吗<br>\39. hook听过吗</p><p>做题<br>\1. 最长连续递增数组，复杂度多少，能优化到多少<br>\2. 二叉树层数</p><p>304状态码是什么，说一下这个请求的过程</p><p>详细说下协商缓存</p><p>HTTP2.0的多路复用是什么</p><p>CSRF是什么</p><p>如果是第三方的链接，直接拒绝访问是不是也可以，就是CSRF怎么达到一种攻击的状态，攻击了用户的什么东西</p><p>CSRF如何防御</p><p>CORS跨域的请求响应过程</p><p>origin的请求跨域网站头，能放很多域名吗</p><p>以上的流程和细节多学习</p><p>Vue的源码</p><p>如何监听一个对象属性的改变</p><p>浏览器如何解析Vue的模板，最终在浏览器中如何使用</p><p>Vue模板会解析成什么样子的东西，又没有了解</p><p>Vue的diff算法是什么</p><p>写一个div，第一个子元素用v-if控制，如何第一个元素v-if&#x3D;false，其中的子div会不会塌陷和挤压，结合diff算法来说</p><p>技术栈是react和Angluar，写游戏页面里的H5</p><p>面完十分钟秒挂，我说要是技术栈和业务方向 学历不匹配可以别面，别浪费彼此时间</p><p>webpack 原理？</p><p>Tree shaking 的原理？<br>- 想用 Tree Shaking 可以有哪些方式？<br>- 所有 ES6 写的都可以用 Tree Shaking 吗？<br>- Tree Shaking 有哪些限制？<br>- 如果我一个导入依赖另一个依赖 另一个依赖被 tree-shaking 掉了怎么办， CSS 引用复杂，CSS 没打进去怎么办？<br>- 微前端了解吗？<br>- 为什么需要微前端？<br>- 各种微前端的原理是什么？<br>- JS 全局隔离怎么做？<br>- 这种方法老版本兼容性不太好，有没有解决方案？<br>- webpack 的联邦模块要先加载 container，在去取 remotes，有性能浪费，能不能直接将主应用和子应用（remotes）同时加载，应该怎么做？<br>- B 端开发的时候有没有碰到什么问题、痛点？<br>- 实习问题、怎么解决的？<br>- 项目问，一个功能解决什么问题？<br>- 鉴权为什么要存 token？<br>- webworker 解决什么问题？<br>- Token 和 cookie ssession 方案？<br>- 这样会有什么安全问题？</p><p>js做数据循环用了哪些方法，如何实现的，这些方法哪种性能最好，哪种最不好<br>（我答的for最好，for…of最不好，也不知道对不对）<br>2、http2和http1.1的区别<br>3、axios库的原理<br>4、设计一个sdk实现前端发送的请求前加一个header，无论谁引用sdk，都会加header（偏场景题）<br>面试官给了一个aop埋点的思路<br>5、防抖和节流<br>6、vue双向绑定源码<br>7、promise常用的几种静态方法<br>8、react的jsx怎么转换成dom结构</p><p>美团（成都 到家事业群）前端面试记录</p><p>一面：<br>1 ts Partial<br>2 正则表达式匹配替换<br>3 Get是完全幂等的吗？<br>4 不适用js实现一个点击显示悬浮窗 active<br>5 webview上h5的屏幕适配<br>6 节流和防抖，应用场景<br>7 git代码出错标准处理<br>8 webpack打包优化和配置<br>9 babel和polyfill<br>10 盒模型 box-sizing<br>11 BFC<br>12 跨域和解决方案<br>13 dom操作 querySelectorAll（编程）<br>14 在Array原型链上添加flat()方法（编程）<br>15 驼峰命名转短横线命名（编程）</p><p>二面：<br>1 项目进度管理和质量保证<br>2 着重讲一下某个项目，遇到的具体难点是什么？<br>3 文件里面有一万个数，范围[0, 1000]，缓存大小只有2k，怎么实现排序及其优化？<br>4 节流函数（编程）<br>5 数组的左移右移实现（编程）<br>6 state变化到页面变化的整个过程</p><p>OPPO前端面试记录</p><p>1 为什么学习前端？<br>2 你对前端行业的认识？<br>3 Vue和React区别<br>4 Vue3和React16的新功能<br>5 前端性能优化策略<br>6 前端错误定位？<br>7 浏览器性能调试api？<br>8 事件循环<br>9 手机端h5适配方法？<br>10 尾递归</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>📣 git基本操作（下），欢迎食用~</title>
    <link href="/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%8C%E6%AC%A2%E8%BF%8E%E9%A3%9F%E7%94%A8/"/>
    <url>/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%8C%E6%AC%A2%E8%BF%8E%E9%A3%9F%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本篇是学习(<a href="https://link.juejin.cn/?target=https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440" title="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">廖雪峰Git学习</a>)所写的学习总结笔记，方便自己后续回顾复习。</p><h1 id="📚-远程仓库"><a href="#📚-远程仓库" class="headerlink" title="📚 远程仓库"></a>📚 远程仓库</h1><p>在上篇中学到的git功能，其实在集中式版本管理系统中也能实现。Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。下面介绍一下git杀手级功能之一：远程仓库。</p><p>首先需要先注册github账号，github是提供Git仓库托管服务的，所以只要注册一个GitHub账号，就可以免费获得Git远程仓库。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><p><strong>第1步：创建SSH Key。</strong></p><p>在用户主目录下（我的电脑C:\Users\Administrator），看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制代码">ssh-keygen -t rsa -C &quot;填写你的邮箱&quot;<br></code></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a216ec3ad4594c3fba913f6996d8c3fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=79&s=11141&e=png&b=000000" width="70%" /></p><p>可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>第2步：登陆GitHub，增加SSH Keys</strong></p><p>步骤为：①setting–&gt; ②SSH and GPG keys –&gt; ③new SSH key</p><p>填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件（公钥）的内容即可</p><blockquote><p>为什么GitHub需要SSH Key呢？</p><p>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p></blockquote><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><h2 id="🌸-添加远程仓库"><a href="#🌸-添加远程仓库" class="headerlink" title="🌸 添加远程仓库"></a>🌸 添加远程仓库</h2><p><strong>本地仓库–&gt;远程仓库</strong></p><p>现在你在本地有一个git仓库，然后你想在github新建一个git远程仓库并让两个仓库进行同步，这样github上的仓库既可以用于备份，也可以让其他人通过该仓库进行协作。</p><p><strong>1.在github上新建仓库，名字可以和本地仓库不同。</strong></p><p>新建仓库后可以根据GitHub给的提示来进行操作，提示如下：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b313b7b908a848fc8a0910284548378c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=162&s=24628&e=png&b=f5f8fa"  width="70%"/></p><p>在本地仓库git bash中运行下列代码（根据自己的远程仓库提示来操作）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 复制代码">git remote add origin git@github.com:LuoyNothing/mygit.git<br></code></pre></td></tr></table></figure><p>添加后，远程库的名字就是<code>origin</code>，这里的<strong>origin为本地客户端认为的远程仓库的名字</strong>，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><blockquote><p>在多人协作的时候，每个人都有自己的git本地客户端和本地仓库，每个人都可以给同一个远程仓库在本地指定不同的名字。</p><p>只不过，origin是git客户端默认的远程仓库的名字，如果我们在关联时将远程仓库的名字指定为origin，在push的时候可以不指定远程仓库的名字，默认push到origin关联的远程仓库。如果修改了名字，在push的时候必须写上指定的远程仓库的名字。</p></blockquote><p><strong>2.把本地库的所有内容推送到远程库上</strong></p><p>在本地仓库git bash中接着运行：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u &lt;远程分支&gt; &lt;本地分支&gt;<br>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送步骤完成。<br>以后在本地仓库进行修改后要推送到远程仓库，直接执行<code>git push origin master</code></p><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h2 id="🌸-删除远程仓库"><a href="#🌸-删除远程仓库" class="headerlink" title="🌸 删除远程仓库"></a>🌸 删除远程仓库</h2><p><strong>1.解绑远程仓库和本地仓库连接</strong></p><p>可以先查看一下远程库信息：<code>git remote -v</code>。然后根据名字删除，比如删除origin：<code>git remote rm origin</code></p><p><strong>2.在github上真正删除远程仓库</strong></p><h2 id="🌸-从远程仓库克隆"><a href="#🌸-从远程仓库克隆" class="headerlink" title="🌸 从远程仓库克隆"></a>🌸 从远程仓库克隆</h2><p>使用<code>git clone 地址</code>就可以克隆完成。地址中Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><h1 id="📚-分支管理"><a href="#📚-分支管理" class="headerlink" title="📚 分支管理"></a>📚 分支管理</h1><h2 id="🌸-分支的理解"><a href="#🌸-分支的理解" class="headerlink" title="🌸 分支的理解"></a>🌸 分支的理解</h2><p>在开发一个项目的时候，团队负责人会给每个团队成员划分不同的任务。如果每个人都在主分支上进行项目开发，这样会影响其他人的工作。因此为了不影响其他人的工作，可以每个人新开一个分支来完成自己的任务，最后测试没问题再合并到主分支上，最后所有人的任务分支都合并到主分支上则可完成项目协作开发。当然实际开发中，可能有些许不同，比如按照任务来新建分支，然后安排某人来开发这个分支，或者几个人负责一个分支，然后根据提交的情况来查看每个人的工作量。</p><p>每个人都有本地仓库和远程仓库，一般在项目开发中，自己本地开发完之后提交到远程仓库中属于自己的分支，避免数据遗失。</p><p>每一次commit都会有提交描述和提交时间，git会将这些commit根据提交时间来串成一个时间线。截止目前只有一个时间线，在git里叫主分支，名字为master。</p><p><code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01449c510d5d48e9bc10c9754f7fdb36~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=534&s=27587&e=png&b=ffffff" width="50%" /></p><p>每一次提交，master分支都会向前走一步，随着提交次数的增多，master分支就越来越长。</p><h2 id="🌸-创建与合并分支"><a href="#🌸-创建与合并分支" class="headerlink" title="🌸 创建与合并分支"></a>🌸 创建与合并分支</h2><p>创建一个新分支，名字为：dev。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-comment">// 创建分支dev</span><br>git branch <span class="hljs-built_in">dev</span><br><span class="hljs-comment">// 切换分支dev</span><br>方式一：git checkout <span class="hljs-built_in">dev</span><br>方式二：git switch <span class="hljs-built_in">dev</span><br><span class="hljs-comment">// 创建并切换分支</span><br>方式一：git checkout -b <span class="hljs-built_in">dev</span><br>方式二(更语义，和前面撤销工作区的更新不产生冲突)：git switch -c <span class="hljs-built_in">dev</span><br><span class="hljs-comment">// 查看当前所有分支</span><br>git branch<br></code></pre></td></tr></table></figure><p>当创建了分支dev之后，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e01ac7674c024d04950a2243a3325493~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=698&s=32261&e=png&b=ffffff" width="50%"/></p><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次(add+commit)后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ae82b830d984b0faf27135813427461~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1468&h=670&s=40357&e=png&b=ffffff" alt="image.png" width="50%" /></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// `git merge`命令用于合并指定分支到当前分支。<br>git merge dev<br></code></pre></td></tr></table></figure><p>这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e57e9c6356bf4c0fa36d8541f4d8f344~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1468&h=658&s=40546&e=png&b=ffffff"  width="50%"/></p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 删除分支dev<br>git branch -d dev<br></code></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h2 id="🌸-解决冲突"><a href="#🌸-解决冲突" class="headerlink" title="🌸 解决冲突"></a>🌸 解决冲突</h2><h2 id="🌸-分支管理策略"><a href="#🌸-分支管理策略" class="headerlink" title="🌸 分支管理策略"></a>🌸 分支管理策略</h2><h1 id="📚-常见问题解决方案"><a href="#📚-常见问题解决方案" class="headerlink" title="📚 常见问题解决方案"></a>📚 常见问题解决方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">//取消http代理<br>git config --global --unset http.proxy<br>//取消https代理 <br>git config --global --unset https.proxy<br><br>git config --global http.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure><h1 id="📚-命令汇总"><a href="#📚-命令汇总" class="headerlink" title="📚 命令汇总"></a>📚 命令汇总</h1><ul><li>远程仓库<ul><li>连接本地仓库和远程仓库：<code>git remote add origin git@github.com:LuoyNothing/mygit.git</code></li><li>第一次推送到远程仓库：<code>git push -u origin master</code></li><li>后续更新推送：<code>git push origin master</code></li><li>查看远程库信息：<code>git remote -v</code></li><li>删除本地仓库和远程仓库的连接：<code>git remote rm origin</code></li><li>从远程仓库克隆：<code>git clone 地址</code></li></ul></li><li>分支<ul><li>创建与合并分支<ul><li>创建分支：<code>git branch &lt;name&gt;</code></li><li>切换分支：<code>git switch &lt;name&gt;</code></li><li>创建并切换分支：<code>git switch -c &lt;name&gt;</code></li><li>合并分支：<code>git merge &lt;name&gt;</code></li><li>删除分支：<code>git branch -d &lt;name&gt;</code></li></ul></li></ul></li></ul><p>下篇在此结束，您花了5分钟又复习了一次相关知识，如果对你还有一点帮助的话，不妨给个小赞鼓励一下吧😊，感谢观看！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 处理hexo博客中图片不显示问题</title>
    <link href="/2023/08/31/%F0%9F%93%A3-%E5%A4%84%E7%90%86hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/31/%F0%9F%93%A3-%E5%A4%84%E7%90%86hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>在解决这个问题的过程中，我经历了三个阶段，很磨人最终还是回到了起点，发现最初的方法最好，如果赶时间，可以直接看第三个阶段。</p><h1 id="🌸第一阶段：将图片保存在本地"><a href="#🌸第一阶段：将图片保存在本地" class="headerlink" title="🌸第一阶段：将图片保存在本地"></a>🌸第一阶段：将图片保存在本地</h1><p>搭建好个人博客网站之后，写了两篇markdown文章（这时候我图片用的是网络地址），然后按照hexo三连上传了文章，最后在浏览器打开发现图像不显示：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a0dd8fb049474f93f6d088d8dc2471~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=235&s=32490&e=png&b=fbfbfb" width="60%" /></p><p>一般图片显示不出来很大的原因是路径不对。于是我去查看了图片路径，确实找不到相应的图片。然后我参考<a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">相关资料</a>了解到<code>hexo g</code>指令是将md文件生成html页面，然后每篇博文生成的html页面最后都是放在用年月日做文件夹的下面，例如：<code>E:\myblog\public\2023\08\31\test</code>。</p><p>下面是我参考<a href="https://leay.net/2019/12/25/hexo/">养恐龙</a>、<a href="http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">ETRD</a>、<a href="https://blog.csdn.net/m0_43401436/article/details/107191688">金牛大王</a>三位的回答，最终解决了我的问题。</p><p><strong>第一步</strong>：确保你的Hexo的配置文件_config.yml里面有这个选项配置，并将其置为true</p><pre><code class="hljs">post_asset_folder: true</code></pre><p>这个功能实际上是Hexo官方文档中提到的资源文件夹功能，它的作用在于当你使用<code>hexo n &quot;文章名&quot;</code>生成一篇新文章时，会在<code>\source\_posts</code>目录下生成一个 文章名.md 文件外，附带生成一个与 文章名 同名的文件夹，可以用它来存放这篇文章的所有资源，比如图片，附件等。</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66e0f2f20d7f4791a68b3973bf2f2734~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=225&s=31200&e=png&b=ffffff"  width=" 60%"/></p><p>【注】你也可以自己在 _posts 文件夹下自动生成md文件和相同名字的文件夹（用于存放图片）</p><p><strong>第二步</strong>：typora中的图像保存位置设置</p><p>点开文件——&gt;偏好设置，设置如下：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993af5c7afec466eaec981af9ac662ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1613&h=657&s=64676&e=png&b=fafafa" width="60%"/></p><p>修改好后，图片引用路径就在和博文同名的文件夹（新建博文名为test）的图片，如图所示：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc88f5524f094d118bedc8456e650126~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918&h=103&s=12423&e=png&b=ffffff" width="60%"/></p><p><strong>第三步</strong>：安装插件</p><p>在根目录下打开git bash，然后运行以下命令，如果有安装淘宝镜像，第一个改为cnpm即可。</p><pre><code class="hljs">npm install https://github.com/xcodebuild/hexo-asset-image.git</code></pre><p>运行结果如下图所示，图为安装成功：</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/059d60bdaded4a0fa0f1ac61286f187e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=242&s=25251&e=png&b=000000" width="70%"/></p><p>该插件的作用：将图片等静态资源的引用路径转化为绝对路径。</p><p>【注】我最开始不是用的上面命令安装的，用的是<code>npm install hexo-asset-image -- save</code>，该命令安装的是插件 hexo-asset-image 1.0 ，这个版本有点问题，安装后图片不能正常显示，查看图片路径被渲染成了 <code>/.xx/abc.png</code> 的格式（xx 是域名后缀）。最后采用上面的命令才成功。</p><p>如何卸载该插件？路径：<code>\blog\node_modules\hexo-asset-image</code>，直接删除文件夹，我试过没问题。</p><h1 id="🌸-第二阶段：将图片保存到图床"><a href="#🌸-第二阶段：将图片保存到图床" class="headerlink" title="🌸 第二阶段：将图片保存到图床"></a>🌸 第二阶段：将图片保存到图床</h1><p>网上查了一些有关md文件中图片的保存位置，发现除了在本地保存外，还可以采用图床进行保存，可以尝试一下<a href="https://github.com/Molunerfinn/PicGo">PicGo</a> 这个图床上传工具，也方便md文件在其他站的上传。</p><p>参考资料：<a href="https://blog.csdn.net/weixin_61529967/article/details/132273065">前端小雪</a>、<a href="https://blog.csdn.net/weixin_43447266/article/details/132490718">刘昕hrf</a>、<a href="https://blog.csdn.net/weixin_45525272/article/details/125387761">杨 戬</a></p><p>我根据上面三个参考回答实现了将图片保存到gitee图床中。</p><p>我的图床：gitee平台</p><h1 id="🌸-第三阶段：图片采用网络地址"><a href="#🌸-第三阶段：图片采用网络地址" class="headerlink" title="🌸 第三阶段：图片采用网络地址"></a>🌸 第三阶段：图片采用网络地址</h1><p>参考<a href="https://blog.csdn.net/mqdxiaoxiao/article/details/96770756">野猿新一</a>的回答，图片路径还是引用网络地址，想要在hexo博客中查看到网络地址的图片，直接在文章Front-matter下加一句：<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code>即可，如下图所示：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0f3200872db4755a847a50c37e6327a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=291&s=28703&e=png&b=f9f9f9" width="70%"/></p><p>最终发现就是加了这一句就可以显示网络地址图片了，我哭死┭┮﹏┭┮。也不需要插件了，也不需要找个地方保存图片！</p><p>还有一个小问题就是，hexo博客网络图片下方可能会出现image.png，如果所示：</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4cccaa212ee4ca0ac5b2cd4f85c41d7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=809&h=170&s=55087&e=png&b=f5f5f5" width="60%" /></p><p>解决办法就是把alt这一块（下图圈的地方）去掉即可：</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43fc18d732d14116a6f8fedf7de8de30~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1331&h=174&s=61361&e=png&b=fffefe" width="60%" /></p><p>本篇结束！</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 git基本操作（上），命令总结清单在最后</title>
    <link href="/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95%E5%9C%A8%E6%9C%80%E5%90%8E/"/>
    <url>/2023/08/31/%F0%9F%93%A3-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%8C%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E6%B8%85%E5%8D%95%E5%9C%A8%E6%9C%80%E5%90%8E/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本篇是学习(<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">廖雪峰Git学习</a>)所写的学习总结笔记</p><h1 id="📚-git简介"><a href="#📚-git简介" class="headerlink" title="📚 git简介"></a>📚 git简介</h1><p>git 是一个版本控制工具，可以用于团队协作。git可以记录之前修改过的内容版本，方便在需要的时候回退到之前的版本，还支持团队内部进行协作更新内容。</p><p>用起来大概就是下面这样子，可以记录修改的版本，谁修改的，修改了哪些内容以及日期：</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecd727d76fe64229bfd2e1d715d2fd02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1154&h=335&e=png&b=ffffff" width:"50%" /></p><p>Git是分布式版本控制系统，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。</p><p>Git还具有极其强大的分支管理</p><h1 id="📚-git安装"><a href="#📚-git安装" class="headerlink" title="📚 git安装"></a>📚 git安装</h1><p>在这里只描述windows上安装git</p><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>因为是分布式版本控制系统，所以需要知道你是谁。注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="🌸-名词解释"><a href="#🌸-名词解释" class="headerlink" title="🌸 名词解释"></a>🌸 名词解释</h2><ul><li><p><strong>工作区</strong>：本地电脑存放文件的文件夹</p></li><li><p>**暂存区(index&#x2F;stage)**：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。版本库中包含2个部分，一部分就是暂存区,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；</p></li><li><p><strong>本地仓库</strong>：.git文件夹里还包括git自动创建的第一个分支：master，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；</p></li><li><p><strong>远程仓库</strong>：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，更新后推送到远程仓库中即可；</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1e326bcd19941c1816661245c2a40e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=795&h=427&e=png&b=fdfdfd"  width="50%"/></p></li></ul><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h2 id="🌸-本地仓库"><a href="#🌸-本地仓库" class="headerlink" title="🌸 本地仓库"></a>🌸 本地仓库</h2><p><strong>1.创建版本库：</strong><br>    什么是版本库呢？英文名<strong>repository</strong>，可以简单理解为一个文件夹，该文件夹下的文件都可以被Git管理起来。</p><p>通过<code>git init</code>命令将这个文件夹变为git可以管理的仓库。建好仓库之后，会出现一个.git文件，该文件是git跟踪管理版本库的，千万不能修改！如果没有该文件，说明是默认隐藏的，输入<code>ls -ah</code>就可以看见。</p><p><strong>2.在版本库中加文件</strong></p><p>所有的版本控制系统其实只能监控文本文件的改动，比如txt文件，网页，所有的程序代码等，git也不例外。而图片、视频这些二进制文件，虽然也能用版本控制系统管理，但是不能跟踪文件的变化，word文件也是二进制文件。</p><p>接下来就是上次文件的步骤：首先新建一个readme.txt文件，并随便写入一些内容</p><ul><li><code>git add readme.txt</code></li><li><code>git commit -m &quot;write readme txt&quot;</code></li></ul><p><code>git add readme.txt</code> 表示告诉git,将文件添加到暂存区中，无输出则成功。也可以采用<code>git add .</code>表示添加变更的文件到暂存区；</p><p><code>git commit -m &quot;本次提交的说明&quot;</code> 表示告诉git，将代码提交到仓库，后面附带对本次提交的说明。该语句执行完会返回一个文件被修改，插入了n行内容（取决于你写了多少内容）。为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件。</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70ca0240e2ca4c1193b646f0e9a1df1d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=156&e=png&b=000000" width="50%" /><p>如果文件有修改，则再执行以上2个步骤即可。</p><h1 id="📚-时光穿梭机"><a href="#📚-时光穿梭机" class="headerlink" title="📚 时光穿梭机"></a>📚 时光穿梭机</h1><h2 id="🌸-版本回退"><a href="#🌸-版本回退" class="headerlink" title="🌸 版本回退"></a>🌸 版本回退</h2><p>要回到之前的版本，我们可以使用<code>git log --pretty=oneline</code>命令显示从最近到最远的提交日志。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6d23155076742b1a7dcace8365cc55f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=84&e=png&b=000000"  width="70%"/></p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本。假如我们要回到第一版本，可以使用<code>git reset --hard 版本号</code>，版本号就是黄色的那一个字符串。</p><p>1.回退到第一版本，当前在第三版本</p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7111c1745a1242c29dd0e5c9f5818686~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=362&s=52170&e=png&b=000000" width="50%" /><p>2.回退到第三版本，当前在第一版本</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94fd6cce736346f5941d55d1530a7ee8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=157&e=png&b=000000" width="50%" /><p>3.如果想回到新的版本，但是找不到版本号：可以使用git reflog来查看你的每一次命令（从近到远）</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f53986ed2b84dca806390fe52c19b8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=410&e=png&b=000000" width="50%" /><p>在上图中就可以找到最新版本的版本号，版本号可以不写全，但也不能写太少，防止版本号重复。</p><h2 id="🌸-撤销修改"><a href="#🌸-撤销修改" class="headerlink" title="🌸 撤销修改"></a>🌸 撤销修改</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改，意思就是，把文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li><p>文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；利用<code>cat</code>命令可以查看文件里的内容，这里要撤销最新的修改，最后一行（已成功）</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9163aac12fa247a9b317752e7513c3e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=483&h=233&e=png&b=000000"  width="50%" /></p></li><li><p>文件已经添加到暂存区(stage)。可以使用<code>git reset HEAD 文件名+后缀</code>来把暂存区的修改撤销掉（unstage），重新放回工作区。然后<code>git checkout -- file</code>即可</p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d07765f66a4466b52c60ee8848975e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=459&h=386&e=png&b=000000"  width="40%"/></p></li></ul><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程，如果提交到远程仓库就G啦。</p><h2 id="🌸-删除文件"><a href="#🌸-删除文件" class="headerlink" title="🌸 删除文件"></a>🌸 删除文件</h2><p>在工作区删除文件之后，工作区和版本库就不一样了，git status可以告知你删除了什么文件。下面分为2种情况</p><ul><li>确实要删除文件，在版本库中也有删除。则直接用命令<code>git rm &lt;file&gt;</code>删掉，并且<code>git commit</code></li><li>如果是误删。在工作区删除了文件，但是版本库中还有，则恢复文件：<code>git checkout -- &lt;file&gt;</code>。<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul><blockquote><p>【注】未添加到版本库的文件被删除掉是不能被恢复的！</p></blockquote><p>常见错误的解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs git">//取消http代理<br>git config --global --unset http.proxy<br>//取消https代理 <br>git config --global --unset https.proxy<br><br>git config --global http.sslVerify &quot;false&quot;<br></code></pre></td></tr></table></figure><h2 id="🌸-命令总结："><a href="#🌸-命令总结：" class="headerlink" title="🌸 命令总结："></a>🌸 命令总结：</h2><ul><li><p>初始化版本库</p><ul><li><code>git init</code> 创建版本库</li></ul></li><li><p>添加文件</p><ul><li><code>git add &lt;file&gt;</code> 将文件加入版本库，<code>git add .</code>添加所有的变更文件到暂存区</li><li><code>git commit -m &quot;提交说明内容&quot;</code> 将文件提交到版本库</li></ul></li><li><p>回退文件版本</p><ul><li><code>git status</code> 查看仓库当前的状态</li><li><code>git diff 文件名+后缀</code> 查看某文件的更改内容</li><li><code>git log</code> 显示从最近到最远的提交日志，<code>git log --pretty=oneline</code>显示的内容更精简。</li><li><code>git reset --hard 版本号</code> 回退到某个版本</li><li><code>git reflog</code> 如果不知道版本号，可以查看之前使用过的命令，从而找到版本号</li></ul></li><li><p>撤销修改</p><ul><li><code>git checkout -- &lt;file&gt;</code>可以丢弃工作区的修改</li><li><code>git reset HEAD 文件名+后缀</code>来把暂存区的修改撤销掉（unstage）</li></ul></li></ul><p>上篇在此结束，您花了5分钟又学到了新的知识，如果对你还有一点帮助的话，不妨给个小赞鼓励一下吧😊，感谢观看！</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📣 用hexo搭建个人博客（持续更新中）</title>
    <link href="/2023/08/30/%F0%9F%93%A3-%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <url>/2023/08/30/%F0%9F%93%A3-%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>本文记录自己搭建个人博客的历程，欢迎收看~</p><h1 id="📚-搭建基础的个人博客"><a href="#📚-搭建基础的个人博客" class="headerlink" title="📚 搭建基础的个人博客"></a>📚 搭建基础的个人博客</h1><blockquote><p><strong>前提：需安装了git 和 nodejs</strong></p></blockquote><ol><li>安装hexo。先新建一个文件夹，在该文件夹下打开git bash，然后运行<code>npm install -g hexo-cli</code></li></ol>  <p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cf3229ac3df4442b4be56bd18e0aea4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=708&h=353&s=35036&e=png&b=f7f7f7" width="50%"/></p>  <ol start="2"><li>初始化hexo，命令为：<code>hexo init</code> ，出现下图结果就表示初始化成功！</li></ol>  <p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a26b0a3e34474736ad89da964b780fce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=101&s=10725&e=png&b=000000" width="70%"/></p>  <p>  新建完成后，在路径下会产生一些文件和文件夹：</p>  <p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b966396263f42a8b814307a95898acc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=319&s=29387&e=png&b=fffefe" width="50%" /></p>    <ul><li><code>_config.yml</code>：俗称站点配置文件，很多与博客网站的格式、内容相关的设置都需要在里面改。</li><li><code>node_modules</code>:存储Hexo插件的文件，可以实现各种扩展功能。一般不需要管。</li><li><code>package.json</code>：相关描述的，比如名字、版本。</li><li><code>scaffolds</code>：模板文件夹，里面的<code>post.md</code>文件可以设置每一篇博客的模板。具体用起来就知道能干嘛了。</li><li><code>source</code>：非常重要。所有的个人文件都在里面！</li><li><code>themes</code>：主题文件夹，可以从<a href="https://link.juejin.cn/?target=https://hexo.io/themes/" title="https://hexo.io/themes/">Hexo主题官网</a>或者网上大神的Github主页下载各种各样美观的主题，让自己的网站变得逼格高端的关键！</li></ul><ol start="3"><li>启动服务器</li></ol><p>命令为：<code>hexo server</code>，或者简写：<code>hexo s</code>，然后打开浏览器，在地址栏输入：localhost:4000回车就可以得到如下结果：(ctrl+c可关闭服务)</p><p align=center><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f108fb71f11e48a393a221ea96c47829~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1844&h=1084&s=647678&e=png&b=f4f3f3" alt="image.png" width="50%" /></p><p>至此，您的Hexo博客已经搭建在本地。</p><p>4.上传到github</p><p>在github创建仓库，仓库名为：&lt;Github账号名称&gt;.github.io（必须是这个，否则后续打不开）。安装<code>hexo-deployer-git</code>插件。在命令行（即Git Bash）运行以下命令即可（也可以走淘宝镜像，淘宝镜像就是换成cnpm）：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>添加SSH key，如果已添加可以不用管。如果未添加，可以参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">添加SSH key</a>，我这里已经添加，接着下一步；</p><ol start="5"><li>修改<code>_config.yml</code>（在站点目录下）。文件末尾修改为：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># Deployment</span><br><span class="hljs-meta">## Docs: https:<span class="hljs-comment">//hexo.io/docs/one-command-deployment</span></span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:LuoyNothing/LuoyNothing.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure>6.生成页面并上传到github</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 生成页面：<br>hexo g<br><span class="hljs-regexp">//</span> 上传到github: <br>hexo d<br></code></pre></td></tr></table></figure><p>执行完上面两个命令，并出现下图结果即表示上传成功。</p><p align=center><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d714419ddf40fc9c44f7d6ac4a8eb8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=303&s=44296&e=png&b=000000" width="50%" /></p><p>至此，您的Hexo博客已经搭建在GitHub上，访问域名为：<a href="https://luoynothing.github.io/">https://luoynothing.github.io/</a></p><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe722b935d254d849c4a5f8a24f29300~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1086&s=911964&e=png&b=f5f4f4" width="50%" /></p><p>访问博客，开始的页面是初始化页面，没有做美化和增加内容。</p><h2 id="🌸-域名绑定"><a href="#🌸-域名绑定" class="headerlink" title="🌸 域名绑定"></a>🌸 域名绑定</h2><p>还未绑定</p><h1 id="📚-文档学习"><a href="#📚-文档学习" class="headerlink" title="📚 文档学习"></a>📚 文档学习</h1><p>官网文档：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><h2 id="🌸-修改主题"><a href="#🌸-修改主题" class="headerlink" title="🌸 修改主题"></a>🌸 修改主题</h2><p>我的博客修改的主题是fluid（<a href="https://hexo.fluid-dev.com/docs/start/"> Hexo Fluid 用户手册</a>）,github(<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid Hexo 主题</a>)，以下是详细步骤：</p><ol><li>下载主题</li></ol><p><strong>方式一</strong>：推荐通过 npm 直接安装，进入博客目录执行命令：<code>npm install --save hexo-theme-fluid</code></p><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的_config.yml内容复制过去。</p><p><strong>方式二</strong>：下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a>解压到 themes 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p>我采用的是方式二。</p><ol start="2"><li>然后采用hexo三连，就可以在本地查看到主题修改<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 启动本地服务器，用于预览主题。<br>hexo s<br></code></pre></td></tr></table></figure>下图表示换主题成功！然后可以用<code>localhost:4000</code>来访问个人博客</li></ol><p align=center><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5643b5e6987401997f520c8cad74c84~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=631&s=57034&e=png&b=000000" width="50%" /></p><ol start="3"><li>部署到github上：</li></ol><p>hexo三连：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 部署到远程仓库里<br>hexo d<br></code></pre></td></tr></table></figure><p>然后可以用<a href="https://luoynothing.github.io/">https://luoynothing.github.io/</a> 来访问个人博客了。</p><h2 id="🌸-发布文章"><a href="#🌸-发布文章" class="headerlink" title="🌸 发布文章"></a>🌸 发布文章</h2><p>1.新建md文件。在网站根目录下git bash，输入<code>hexo new &lt;title&gt;</code>，执行该命令，Hexo会在<code>/source/_posts</code>目录下创建一篇新的文章。</p><p>2.上传到github，就是hexo三连操作。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">// 清除缓存文件 `db.json` 和已生成的静态文件 `public`。<br>hexo cl <br>// 生成网站静态文件到默认设置的 `public` 文件夹。<br>hexo g<br>// 部署到远程仓库里<br>hexo d<br></code></pre></td></tr></table></figure><h2 id="🌸-常见问题"><a href="#🌸-常见问题" class="headerlink" title="🌸 常见问题"></a>🌸 常见问题</h2><p>1.hexo引用网络图片无法显示问题。</p><p>答：在文章的头部位置添加：<code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code> 即可</p><p>2.Nunjucks Error: 解决方案</p><p>答：最主要原因是用<code>&#123; &#123; &#125; &#125;</code>或<code>&#123; ％ ％ &#125;</code>包装的内容将被解析，并可能导致问题。比如写公式的时候就容易解析出错，所以可以采用如下解决方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;% raw %&#125;// 敏感内容前加上这个<br>Hello &#123;&#123; sensitive &#125;&#125;// 敏感内容被包装在中间<br>&#123;% endraw %&#125;// 敏感内容后加上这个<br></code></pre></td></tr></table></figure><p>3.添加自定义HTML文件</p><p><a href="https://blog.csdn.net/weixin_58068682/article/details/116611715">Hexo博客技巧：添加自定义html页面</a></p><h1 id="📚-博客更新说明"><a href="#📚-博客更新说明" class="headerlink" title="📚 博客更新说明"></a>📚 博客更新说明</h1><p><strong>2023-8-30</strong></p><p>1.成功搭建博客</p><p>2.博客文章：</p><p>​1.封面字段：标题、发布时间、关键字</p><p>​摘要：去掉摘要</p><p>​2.封面进去：发布时间、更新时间、字数、阅读时长​</p><p>3.标签和分类：</p><p>分类1：前端</p><p>​子类：html css等</p><p>分类2：持续更新</p><p>标签：相当于关键字吧，里面的某个知识点</p><p>4.博客中的图片不显示问题</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
